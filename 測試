/**
 * murain-api â€” Full Worker (Airtable backend) + 7-11 å®˜æ–¹ e-map + ZeroCard
 *
 * Endpoints (JSON unless ç‰¹åˆ¥æ¨™ç¤º):
 *   GET  /ping
 *   POST /op/auth                         { op_key }
 *   POST /cart/create                     { streamer_name, customer_type?="live" }
 *   GET  /product/:sku
 *   GET  /cart/:cart_token
 *   POST /cart/add                        { cart_token, sku, qty, price?, op_key? }
 *   POST /cart/note                       { cart_token, note }
 *   POST /cart/clear                      { cart_token, op_key }      // éœ€ OP
 *   POST /cart/remove                     { cart_token, sku, op_key } // éœ€ OP
 *   POST /checkout                        { cart_token, payment_method, shipping_info }
 *
 *   (HTML) GET  /cvs/map?src=cod|paid|dep_old|dep_new_p|dep_new_f|zc[&cart_token=...&customer=...&mode=...]
 *   (HTML) POST /cvs/callback     â† 7-11 å®˜æ–¹ e-map å›å‚³ï¼ˆä¹Ÿç›¸å®¹ /cvs_callbackï¼‰
 *
 *   POST /zero-card/start                { order_id } â†’ { ok, payment_url }
 *   POST/GET /zero-card/notify           ï¼ˆä¸­ç§ŸèƒŒæ™¯é€šçŸ¥ï¼‰
 *
 * Required Env:
 *   OP_KEY="88"
 *   FRONT_ORIGIN="https://murain.tw"
 *   PREVIEW_ORIGIN (optional)
 *   AIRTABLE_BASE_ID, AIRTABLE_TOKEN
 *   AT_PRODUCTS="Products", AT_CARTS="CartToken", AT_CART_ITEMS="CartItems", AT_ORDERS="Orders"
 *
 *   ZERO_CARD_API_BASE="https://uatapi.chaileaseholding.com/api_zero_card"
 *   ZERO_CARD_MERCHANT_ID="..."   // ä¸­ç§Ÿå•†å®¶ç·¨è™Ÿ
 *   ZERO_CARD_API_KEY="..."       // ä¸­ç§Ÿ API Key
 */


function nowISO(){ return new Date().toISOString(); }
function rid(prefix=""){ return prefix + Math.random().toString(36).slice(2) + Date.now().toString(36); }
function toPayuniTradeNo(orderId) {
  let t = String(orderId || "").replace(/[^A-Za-z0-9]/g, "");
  if (!t) t = "O" + Date.now().toString(10);
  // å»ºè­°å–å°¾å·´æ¯”è¼ƒä¸å®¹æ˜“æ’ï¼ˆä½†ä½ æœƒå­˜åˆ° Airtable æœƒæ›´å®‰å…¨ï¼‰
  if (t.length > 20) t = t.slice(-20);
  return t;
}
// -------------------- LINE push helper --------------------
// éœ€åœ¨ Worker ç’°å¢ƒè®Šæ•¸è¨­å®šï¼šLINE_CHANNEL_ACCESS_TOKEN
async function linePush(env, userId, text) {
  const token = env.LINE_CHANNEL_ACCESS_TOKEN;
  if (!token || !userId || !text) return;

  try {
    await fetch("https://api.line.me/v2/bot/message/push", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + token
      },
      body: JSON.stringify({
        to: userId,
        messages: [{ type: "text", text }]
      })
    });
  } catch (e) {
    console.log("LINE push failed", e);
  }
}
async function linePushFlex(env, userId, altText, contents) {
  const token = env.LINE_CHANNEL_ACCESS_TOKEN;

  // â˜… Debugï¼šçœ‹çœ‹ token / userId æœ‰æ²’æœ‰
  console.log("linePushFlex run", {
    hasToken: !!token,
    hasUserId: !!userId,
    hasContents: !!contents,
    userId: userId || ""
  });

  if (!token || !userId || !contents) {
    console.log("linePushFlex missing param", {
      hasToken: !!token,
      hasUserId: !!userId,
      hasContents: !!contents
    });
    return;
  }

  const alt = altText || "è¨‚å–®é€šçŸ¥";

  try {
    const res = await fetch("https://api.line.me/v2/bot/message/push", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + token
      },
      body: JSON.stringify({
        to: userId,
        messages: [
          {
            type: "flex",
            altText: alt,
            contents
          }
        ]
      })
    });

    const text = await res.text().catch(() => "");
    console.log("linePushFlex response", {
      status: res.status,
      ok: res.ok,
      body: text.slice(0, 200)
    });
  } catch (e) {
    console.log("LINE Flex push failed", e);
  }
}
// âœ… å…±ç”¨ï¼šå°¾æ¬¾çµå¸³é€£çµï¼ˆCron / å¾Œå° / OP å…¨éƒ¨èµ°åŒä¸€æ”¯ï¼‰
// - å¼·åˆ¶åªåƒã€Œorder_idã€ï¼ˆOD...ï¼‰ï¼Œä¸æ¥å— rec.id
// - æ”¯æ´ env.TAIL_CHECKOUT_PATHï¼ˆå¯æ”¹è·¯å¾‘ï¼‰
// - é è¨­èµ°å°¾æ¬¾ LIFFï¼ˆä½ ä¹Ÿå¯ä»¥æ”¹æˆä¸€å®šè¦ env æ‰èµ°ï¼‰
function buildTailCheckoutUrl(env, orderId) {
  const oid = String(orderId || "").trim();
  if (!oid) return ""; // âœ… é˜²å‘†ï¼šæ²’æœ‰ order_id å°±ä¸è¦ç”¢ç”Ÿé€£çµ

  const front = (env.FRONT_ORIGIN || "https://murain.tw").replace(/\/+$/, "");
  let tailPath = env.TAIL_CHECKOUT_PATH || "/tail-checkout.html";
  if (!tailPath.startsWith("/")) tailPath = "/" + tailPath;

  const endpoint = `${front}${tailPath}?order_id=${encodeURIComponent(oid)}`;

  // âœ… å°¾æ¬¾å°ˆç”¨ LIFF IDï¼ˆå„ªå…ˆ envï¼›æ²’è¨­å°±ç”¨ä½ ç¾æœ‰å›ºå®šå€¼é¿å…å£ï¼‰
  const liffId = String(env.LIFF_TAIL_ID || env.LIFF_ID_TAIL || "2008430261-52jlBH4y").trim();

  return liffId
    ? `https://liff.line.me/${liffId}?url=${encodeURIComponent(endpoint)}`
    : endpoint;
}
function buildCheckoutUrl(cartToken) {
  const LIFF_ID = '2008430261-KLwoQjm4';
  // âœ… ä¸è¦ force=1ï¼Œè®“å‰ç«¯å¯ä»¥åš pending è‡ªå‹•çºŒä»˜ï¼ˆguardPendingPayï¼‰
  const endpoint = `https://murain.tw/liff-checkout?cart_token=${encodeURIComponent(cartToken)}`;
  return `https://liff.line.me/${LIFF_ID}?url=${encodeURIComponent(endpoint)}`;
}
// âœ… é«˜ç´šç²¾ç·»ç‰ˆï¼šçµå–®å®Œæˆé€šçŸ¥å¡ï¼ˆé€šç”¨7-11è²¨åˆ°ä»˜æ¬¾ã€é¢äº¤ã€ç·šä¸Šæ”¯ä»˜å¯©æ ¸æˆåŠŸï¼‰
function buildSimpleConfirmBubble({
  topLabel = "PAYMENT SUCCESSFUL", // é ‚éƒ¨å°æ¨™
  title = "çµå¸³å®Œæˆ",              // ä¸»æ¨™é¡Œ
  amountLabel = "æ‡‰ä»˜é‡‘é¡",
  amountText = "-",
  payMethodLabel = "-",            // ä»˜æ¬¾æ–¹å¼
  rows = [],                       // å…¶ä»–è©³ç´°è³‡è¨Š
  buttonLabel = "æŸ¥çœ‹è¨‚å–®",
  buttonUrl = "https://murain.tw"
} = {}) {
  const safeRows = Array.isArray(rows) ? rows : [];

  // --- ç¶“å…¸é…è‰² ---
  const C_BG = "#050608";          // æ·±é»‘åº•
  const C_GOLD = "#D4AF37";        // ç¶“å…¸é‡‘ (æ–‡å­—)
  const C_BRIGHT_GOLD = "#FFD700"; // âœ¨ äº®é‡‘è‰² (åœ–ç¤ºå°ˆç”¨)
  const C_SUB_GOLD = "#BFA372";    // æ·ºé‡‘ (å°æ¨™)
  const C_TEXT = "#FFFFFF";        // ç™½å­—
  const C_GRAY = "#999999";        // ç°å­—

  // çµ±ä¸€çš„åˆ—æ¨£å¼ helper
  const renderRow = (label, value, isHighlight = false) => ({
    type: "box",
    layout: "baseline",
    spacing: "sm",
    contents: [
      { type: "text", text: String(label || ""), flex: 3, size: "sm", color: C_GRAY, align: "start" },
      { 
        type: "text", 
        text: String((value ?? "-") || "-"), 
        flex: 6, 
        size: "sm", // âœ… å…¨éƒ¨çµ±ä¸€å¤§å°
        color: isHighlight ? C_GOLD : C_TEXT, // é‡é»é …ç›®é¡¯ç¤ºé‡‘è‰²
        weight: isHighlight ? "bold" : "regular",
        wrap: true, 
        align: "end" 
      }
    ]
  });

  // æº–å‚™å…§å®¹åˆ—
  const contentRows = [
    { label: String(amountLabel || "ä»˜æ¬¾ç¸½é¡"), value: amountText, highlight: true },
    { label: "ä»˜æ¬¾æ–¹å¼", value: payMethodLabel, highlight: false }, 
    ...safeRows
  ].filter(r => r.value && r.value !== "-" && r.value !== "");

  return {
    type: "bubble",
    size: "mega",
    body: {
      type: "box",
      layout: "vertical",
      paddingAll: "18px", // âœ… å…§è·ç¸®å°ï¼Œå¡ç‰‡æ›´çŸ­
      backgroundColor: C_BG,
      contents: [
        
        // 1. âœ¨ åœ“åœˆæ‰“å‹¾åœ–ç¤º (ä¿æŒäº®çœ¼ï¼Œä½†é…åˆçŸ­ç‰ˆå¾®èª¿å°ºå¯¸)
        {
          type: "box",
          layout: "vertical",
          alignItems: "center", 
          margin: "xs",
          contents: [
            {
              type: "box",
              layout: "vertical",
              width: "54px",        // 54px (åœ¨çŸ­ç‰ˆä¸­å·²é¡¯å¾—å¾ˆå¤§)
              height: "54px",
              cornerRadius: "27px", 
              borderWidth: "3px",   
              borderColor: C_BRIGHT_GOLD,
              justifyContent: "center",
              alignItems: "center",
              contents: [
                {
                  type: "text",
                  text: "âœ”",        
                  size: "xl",      
                  color: C_BRIGHT_GOLD,    
                  weight: "bold",
                  margin: "none"    
                }
              ]
            }
          ]
        },

        // 2. æ¨™é¡Œæ–‡å­—å€ (ç·Šæ¹Šæ’åˆ—)
        {
          type: "box",
          layout: "vertical",
          spacing: "none",
          margin: "md", // é–“è·ç¸®å°
          alignItems: "center", 
          contents: [
            { type: "text", text: String(topLabel || ""), size: "xxs", color: C_SUB_GOLD, weight: "bold"},
            { type: "text", text: String(title || ""), size: "lg", color: C_TEXT, weight: "bold", margin: "xs" }
          ]
        },

        // âŒ ç§»é™¤åˆ†éš”ç·š (Separator)ï¼Œè®“è¦–è¦ºæ›´é€£è²«é«˜ç´šï¼Œä¸”ç¯€çœé«˜åº¦

        // 3. è©³ç´°è³‡è¨Šåˆ—è¡¨ (ç·Šæ¥æ¨™é¡Œä¸‹æ–¹)
        {
          type: "box",
          layout: "vertical",
          spacing: "sm",
          margin: "lg", // èˆ‡æ¨™é¡Œä¿æŒé©ç•¶è·é›¢
          contents: contentRows.map(r => renderRow(r.label, r.value, r.highlight))
        },

        // 4. æŒ‰éˆ• (åº•éƒ¨)
        {
          type: "box",
          layout: "vertical",
          margin: "lg", // é–“è·ç¸®å°
          contents: [
            {
              type: "button",
              style: "primary",
              color: "#c6a15b", 
              action: { type: "uri", label: String(buttonLabel || "æŸ¥çœ‹è¨‚å–®"), uri: String(buttonUrl || "https://murain.tw") },
              height: "sm"
            }
          ]
        }
      ]
    }
  };
}

// 7-11å–è²¨ä»˜æ¬¾å¡ç‰‡é€šçŸ¥
function buildCod711CheckoutFlexBubble(params) {
  const { customerName, orderId, amountText, storeName, storeAddr } = params || {};

  const memberUrl = `https://liff.line.me/2008430261-EGZPg3Qp`;

  const storeLines = [storeName, storeAddr].filter(Boolean).join(" ");

  return buildSimpleConfirmBubble({
    topLabel: "ORDER CONFIRMED",
    title: "7-11 å–è²¨ä»˜æ¬¾",
    amountText: amountText || "-",
    rows: [
      { label: "è¨‚å–®ç·¨è™Ÿ", value: orderId || "-" },
      { label: "æ”¶ä»¶äºº", value: customerName || "-" },
      { label: "å–è²¨é–€å¸‚", value: storeLines || "-" }
    ],
    buttonLabel: "æŸ¥çœ‹è¨‚å–®",
    buttonUrl: memberUrl
  });
}
// 7-11 å–è²¨ä»˜æ¬¾ï½œçµå¸³å®Œæˆ Flex å¡ç‰‡
function buildShippingFlexBubble(params) {
  const { customerName, orderId, trackingNo, shipPlace, amountText, payMethodLabel } = params || {};
  const memberUrl = `https://liff.line.me/2008430261-EGZPg3Qp`;

  return buildSimpleConfirmBubble({
    topLabel: "SHIPPING",
    title: "å‡ºè²¨é€šçŸ¥",
    amountText: amountText || "-",
    rows: [
      { label: "è¨‚å–®ç·¨è™Ÿ", value: orderId || "-" },
      { label: "ç‰©æµå–®è™Ÿ", value: trackingNo || "-" },
      { label: "å–è²¨åœ°é»", value: shipPlace || "-" },
      { label: "ä»˜æ¬¾æ–¹å¼", value: payMethodLabel || "-" },
      { label: "æ”¶ä»¶äºº", value: customerName || "-" }
    ],
    buttonLabel: "æŸ¥çœ‹è¨‚å–®",
    buttonUrl: memberUrl
  });
}


// âœ… å‡ºè²¨é€šçŸ¥ï¼ˆå¤§å™¨å¥¢è¯ç¶  - å®Œæ•´é–€å¸‚è³‡è¨Šç‰ˆ - ä½èª¿ç„¡ç²—é«”ä¿®å¾©ç‰ˆï¼‰
function buildShippingFlexBubbleV2(params) {
  const {
    customerName,
    pickupPhone,
    orderId,
    trackingNo,
    shipPlace,
    amountText,
    payMethodLabel
  } = params || {};

  const memberUrl = `https://liff.line.me/2008430261-EGZPg3Qp`;
  const tn = String(trackingNo || "").trim();
  const hasTracking = !!tn;
  
  // é¡¯ç¤ºå®Œæ•´é–€å¸‚è³‡æ–™
  const fullShipPlace = String(shipPlace || "-");

  // --- æ·±é‚ƒå¥¢è¯ç¶ é…è‰²æ–¹æ¡ˆ ---
  const C_BG = "#0A0F0D";       
  const C_ACCENT = "#4E6B5A";   
  const C_GOLD_GREEN = "#A7C4B2"; 
  const C_TEXT_MAIN = "#E0E5E2"; 
  const C_TEXT_SUB = "#627068";

  // è³‡è¨Šåˆ—ï¼šå°‡æ•¸å€¼éƒ¨åˆ†çš„ weight æ”¹ç‚º regular
  const kvRow = (label, value) => ({
    type: "box",
    layout: "horizontal",
    margin: "xs",
    contents: [
      { type: "text", text: String(label || ""), size: "xs", color: C_TEXT_SUB, flex: 3 },
      { 
        type: "text", 
        text: String((value ?? "-") || "-"), 
        size: "xs", 
        color: "#BFC7C1", 
        flex: 7, 
        align: "end", 
        weight: "regular",
        wrap: true 
      }
    ]
  });

  return {
    type: "bubble",
    size: "mega",
    body: {
      type: "box",
      layout: "vertical",
      paddingAll: "16px",
      backgroundColor: C_BG,
      contents: [
        
        // 1. Header & Amount
        {
          type: "box",
          layout: "horizontal",
          contents: [
            {
              type: "box",
              layout: "vertical",
              flex: 6,
              contents: [
                // ä¿®å¾©è™•ï¼šsize å¾ 11px æ”¹ç‚º xxs
                { type: "text", text: "SHIPPING NOTICE", size: "xxs", color: C_GOLD_GREEN, weight: "bold" },
                { type: "text", text: "å·²å‡ºè²¨", size: "lg", color: C_TEXT_MAIN, weight: "bold", margin: "xs" }
              ]
            },
            {
              type: "box",
              layout: "vertical",
              flex: 4,
              contents: [
                // é‡‘é¡ï¼šè¨­ç‚º xs å¤§å°ã€ä½èª¿è‰²ã€ç„¡ç²—é«”
                { 
                  type: "text", 
                  text: String(amountText || "-"), 
                  size: "xs", 
                  color: C_TEXT_SUB, 
                  weight: "regular", 
                  align: "end" 
                },
                { 
                  type: "text", 
                  text: String(payMethodLabel || ""), 
                  size: "xs", 
                  color: C_TEXT_SUB, 
                  align: "end",
                  margin: "xs" 
                }
              ]
            }
          ]
        },

        { type: "separator", margin: "md", color: "#1E2622" },

        // 2. ç‰©æµå–®è™Ÿå€å¡Š
        {
          type: "box",
          layout: "horizontal",
          margin: "md",
          contents: [
            // ä¿®å¾©è™•ï¼šsize å¾ 11px æ”¹ç‚º xxs
            { type: "text", text: "ç‰©æµå–®è™Ÿ", size: "md", weight: "bold", color: C_GOLD_GREEN, gravity: "center" },
            { type: "text", text: hasTracking ? tn : "-", size: "md", color: C_TEXT_MAIN, align: "end", weight: "bold", gravity: "center" }
          ]
        },

        // 3. è©³ç´°è³‡è¨Š
        {
          type: "box",
          layout: "vertical",
          spacing: "xs",
          margin: "md",
          contents: [
            kvRow("æ”¶ä»¶å§“å", customerName),
            kvRow("è¯çµ¡é›»è©±", pickupPhone),
            kvRow("å–è²¨é–€å¸‚", fullShipPlace)
          ]
        }
      ]
    },

    // 4. Footer
    footer: {
      type: "box",
      layout: "vertical",
      paddingAll: "16px",
      paddingTop: "0px",
      backgroundColor: C_BG,
      contents: [
        {
          type: "button",
          style: "primary",
          color: C_ACCENT,
          action: { type: "uri", label: "æŸ¥çœ‹è¨‚å–®è©³æƒ…", uri: memberUrl },
          height: "md"
        }
      ]
    }
  };
}

// ä»˜æ¬¾æˆåŠŸ Flex å¡ç‰‡ï¼ˆå…±ç”¨ï¼šè¨‚é‡‘ & å…¨é¡ï¼‰
function buildPayOkFlexBubble(params) {
  const {
    orderId,
    amountText,
    payMethodLabel,
    amountLabel = "ä»˜æ¬¾ç¸½é¡",
    extraRows = [] // âœ… æ–°å¢ï¼šå¯æ’å…¥é¡å¤–åˆ—ï¼ˆä¾‹å¦‚ï¼šä»˜æ¬¾è¨‚é‡‘ï¼‰
  } = params || {};

  const memberUrl = `https://liff.line.me/2008430261-EGZPg3Qp`;

  const safeExtra = Array.isArray(extraRows) ? extraRows : [];

  return buildSimpleConfirmBubble({
    topLabel: "PAYMENT",
    title: "ä»˜æ¬¾æˆåŠŸ",
    amountLabel,
    amountText: amountText || "-",
    rows: [
      { label: "è¨‚å–®ç·¨è™Ÿ", value: orderId || "-" },
      ...safeExtra,
      { label: "ä»˜æ¬¾æ–¹å¼", value: payMethodLabel || "-" }
    ],
    buttonLabel: "æŸ¥çœ‹è¨‚å–®",
    buttonUrl: memberUrl
  });
}

// âœ… ä»˜æ¬¾æˆåŠŸ Flex å¡ç‰‡ï¼ˆé«˜ç´šé»‘é‡‘å¥¢è¯ç‰ˆ - å…¨çµ±ä¸€åˆ—è¡¨ç‰ˆï¼‰
function buildPaymentSuccessFlexBubble(params) {
  const {
    orderId,
    amountText,
    payMethodLabel,
    amountLabel = "ä»˜æ¬¾ç¸½é¡",
    extraRows = []
  } = params || {};

  const memberUrl = `https://liff.line.me/2008430261-EGZPg3Qp`;
  const safeExtra = Array.isArray(extraRows) ? extraRows : [];

  // âœ¨ é«˜ç´šæ„Ÿé…è‰²ç›¤
  const colors = {
    bg: "#141414",          // æ·±é‚ƒé»‘èƒŒæ™¯
    card: "#1C1C1E",        // æ¶ˆå…‰é»‘å¡ç‰‡
    accent: "#D4B06A",      // é¦™æª³é‡‘
    textMain: "#F5F5F5",    // è¿‘ä¹ç™½
    textSub: "#8E8E93",     // é«˜ç´šç°
    line: "#3A3A3C",        // æ·±ç°åˆ†éš”ç·š
  };

  // è¼”åŠ©å‡½å¼ï¼šæ¨™æº–æ˜ç´°è¡Œ (çµ±ä¸€è¦æ ¼)
  const kvRow = (label, value, valueColor = colors.textMain, isBold = false) => ({
    type: "box",
    layout: "baseline",
    spacing: "sm",
    margin: "sm", // çµ±ä¸€é–“è·
    contents: [
      { 
        type: "text", 
        text: String(label || ""), 
        size: "sm", 
        color: colors.textSub, 
        flex: 3 // å›ºå®šæ¨™é¡Œå¯¬åº¦æ¯”ä¾‹ï¼Œç¢ºä¿å·¦å´å°é½Š
      },
      { 
        type: "text", 
        text: String((value ?? "-") || "-"), 
        size: "sm", // âš¡ï¸ çµ±ä¸€å­—é«”å¤§å°ï¼Œé‡‘é¡ä¸æ”¾å¤§
        color: valueColor, 
        flex: 7, // å›ºå®šå…§å®¹å¯¬åº¦æ¯”ä¾‹
        align: "end", // æ•¸å€¼é å³å°é½Šï¼Œè¦–è¦ºæ›´æ•´é½Š
        weight: isBold ? "bold" : "regular",
        wrap: true 
      }
    ]
  });

  // âš¡ï¸ çµ±ä¸€çš„è³‡æ–™åˆ—è¡¨ (ä¾ç…§é †åºæ’åˆ—ï¼šé‡‘é¡ -> ä»˜æ¬¾æ–¹å¼ -> è¨‚å–®ç·¨è™Ÿ -> å…¶ä»–)
  const allRows = [
    kvRow(amountLabel || "ä»˜æ¬¾ç¸½é¡", amountText || "-"), // âš¡ï¸ ä¿®æ”¹ï¼šç§»é™¤ç‰¹æ®Šé¡è‰²å’Œç²—é«”ï¼Œèˆ‡å…¶ä»–æ¬„ä½å®Œå…¨ä¸€è‡´
    kvRow("ä»˜æ¬¾æ–¹å¼", payMethodLabel || "-"),
    kvRow("è¨‚å–®ç·¨è™Ÿ", orderId || "-"),
    ...safeExtra
      .filter(r => r && r.label && r.value)
      .map(r => kvRow(r.label, r.value))
  ];

  return {
    type: "bubble",
    size: "mega",
    body: {
      type: "box",
      layout: "vertical",
      backgroundColor: colors.bg,
      paddingAll: "0px",
      contents: [
        // 1. é ‚éƒ¨è£é£¾æ¢
        {
          type: "box",
          layout: "horizontal",
          height: "4px",
          backgroundColor: colors.accent,
          contents: [{ type: "filler" }]
        },

        // 2. å¡ç‰‡ä¸»é«”
        {
          type: "box",
          layout: "vertical",
          backgroundColor: colors.card,
          paddingAll: "20px",
          contents: [
            // Header: Icon + æ¨™é¡Œ
            {
              type: "box",
              layout: "horizontal",
              alignItems: "center",
              spacing: "md",
              contents: [
                // å·¦å´ Icon
                {
                  type: "box",
                  layout: "vertical",
                  width: "40px",
                  height: "40px",
                  cornerRadius: "20px",
                  backgroundColor: colors.accent,
                  justifyContent: "center",
                  alignItems: "center",
                  flex: 0,
                  contents: [
                    { type: "text", text: "âœ“", size: "20px", weight: "bold", color: "#000000" }
                  ]
                },
                // å³å´æ¨™é¡Œæ–‡å­—
                {
                  type: "box",
                  layout: "vertical",
                  justifyContent: "center",
                  contents: [
                    { type: "text", text: "PAYMENT SUCCESS", size: "xxs", weight: "bold", color: colors.accent },
                    { type: "text", text: "ä»˜æ¬¾å®Œæˆ", size: "lg", weight: "bold", color: colors.textMain }
                  ]
                }
              ]
            },

            // åˆ†éš”ç·š
            { type: "separator", margin: "lg", color: colors.line },

            // âš¡ï¸ çµ±ä¸€åˆ—è¡¨å€åŸŸ
            {
              type: "box",
              layout: "vertical",
              margin: "lg",
              spacing: "none",
              contents: allRows
            }
          ]
        }
      ]
    },

    // åº•éƒ¨æŒ‰éˆ•
    footer: {
      type: "box",
      layout: "vertical",
      backgroundColor: colors.card,
      paddingAll: "16px",
      paddingTop: "0px",
      contents: [
        {
          type: "button",
          style: "primary",
          color: colors.accent,
          height: "sm",
          action: { type: "uri", label: "å‰å¾€æœƒå“¡ä¸­å¿ƒ", uri: memberUrl }
        },
        {
          type: "text",
          text: "Thank you for your purchase.",
          size: "xxs",
          color: "#444444",
          align: "center",
          margin: "sm"
        }
      ]
    },
    styles: {
      footer: { separator: false }
    }
  };
}



// ä¸­ç§Ÿåˆ†æœŸ / ä»˜æ¬¾å¤±æ•— Flex å¡ç‰‡ï¼ˆâœ… éœ§è‰²é«˜ç´šæ„Ÿ + é«˜è½‰åŒ–ç‡æ¨£å¼ï¼‰
function buildPaymentFailFlexBubble(params) {
  const { customerName, orderId, amountText, failReason, retryUrl } = params || {};

  const who = String(customerName || "è²´è³“");
  const oid = String(orderId || "-");
  const amt = String(amountText || "-");
  // const reason = String(failReason || "ä»˜æ¬¾æœªå®Œæˆï¼Œè«‹é‡æ–°å˜—è©¦"); // ç§»é™¤åŸå› è®Šæ•¸ï¼Œå› ç‚ºä¸‹æ–¹ä¸å†é¡¯ç¤º
  const url = String(retryUrl || "https://murain.tw");

  // ğŸ¨ éœ§è‰²é«˜ç´šæ„Ÿèª¿è‰²ç›¤ (Premium Mist Palette)
  const colors = {
    bg: "#1C1C1E",        // æ¥µè‡´éœ§é»‘ (Matte Black)
    card: "#2C2C2E",      // æ·±å²©ç° (Dark Granite)ï¼Œè³ªæ„Ÿæ·±åº•
    danger: "#B7545B",    // éœ§é¢ä¹¾ç‡¥ç«ç‘°ç´… (Muted Rose)ï¼Œé«˜ç´šä¸”ä¸åˆºçœ¼
    dangerBg: "#3A2A2B",  // è­¦ç¤ºåœ–ç¤ºçš„æ·±è‰²åº•åº§ (Tone-on-Tone)
    textMain: "#E5E5E5",  // éœ§ç™½ (éæ­»ç™½)
    textSub: "#98989D",   // è³ªæ„Ÿç°
    line: "#3A3A3C"       // æ¥µç´°åˆ†éš”ç·š
  };

  return {
    type: "bubble",
    size: "mega", // ğŸ‘ˆ æ”¹å› megaï¼šæ¢å¾©æ¨™æº–å¯¬åº¦ï¼Œè§£æ±ºå¤ªçª„çš„å•é¡Œ
    body: {
      type: "box",
      layout: "vertical",
      backgroundColor: colors.bg,
      paddingAll: "0px",
      contents: [
        // é ‚éƒ¨ç´°æ¢
        { type: "box", layout: "horizontal", height: "4px", backgroundColor: colors.danger, contents: [] },
        {
          type: "box",
          layout: "vertical",
          backgroundColor: colors.card,
          paddingAll: "20px",
          spacing: "md",
          contents: [
            // æ¨™é¡Œå€ï¼šç›´æ¥é¡¯ç¤ºå®Œæ•´æç¤ºèª
            { 
              type: "text", 
              text: "ä»˜æ¬¾æœªå®Œæˆï¼Œè«‹é‡æ–°å˜—è©¦", 
              size: "lg", 
              weight: "bold", 
              color: colors.textMain, 
              align: "center", 
              margin: "xs",
              wrap: true // åŠ ä¸Š wrap ç¢ºä¿é•·æ¨™é¡Œèƒ½æ›è¡Œ
            }, 
            { type: "text", text: "Transaction Incomplete", size: "xxs", weight: "bold", color: colors.danger, align: "center" },

            // âœ¨ é«˜ç´šæ„Ÿ Icon è¨­è¨ˆ
            {
              type: "box",
              layout: "vertical",
              alignItems: "center",
              justifyContent: "center",
              margin: "lg",
              contents: [
                {
                  type: "box",
                  layout: "vertical",
                  width: "48px",
                  height: "48px",
                  backgroundColor: colors.dangerBg,
                  cornerRadius: "24px",
                  justifyContent: "center",
                  alignItems: "center",
                  contents: [
                    {
                      type: "text",
                      text: "!",
                      size: "xl",
                      weight: "bold",
                      color: colors.danger,
                      align: "center",
                      offsetBottom: "1px"
                    }
                  ]
                }
              ]
            },

            // åˆ†éš”ç·š
            { type: "box", layout: "horizontal", height: "1px", backgroundColor: colors.line, margin: "lg", contents: [] },

            // è³‡è¨Šå€ï¼šç·Šæ¹Šæ’ç‰ˆ (å·²ç§»é™¤åŸå› æ¬„ä½)
            {
              type: "box",
              layout: "vertical",
              margin: "lg",
              spacing: "sm",
              contents: [
                {
                  type: "box",
                  layout: "baseline",
                  contents: [
                    { type: "text", text: "æ‡‰ä»˜é‡‘é¡", size: "xs", color: colors.textSub, flex: 3 },
                    { type: "text", text: amt, size: "md", weight: "bold", color: colors.textMain, flex: 7, wrap: true, align: "end" }
                  ]
                },
                {
                  type: "box",
                  layout: "baseline",
                  contents: [
                    { type: "text", text: "è¨‚å–®ç·¨è™Ÿ", size: "xs", color: colors.textSub, flex: 3 },
                    { type: "text", text: oid, size: "xs", color: colors.textMain, flex: 7, wrap: true, align: "end" }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    footer: {
      type: "box",
      layout: "vertical",
      backgroundColor: colors.bg,
      paddingAll: "16px",
      contents: [
        // æŒ‰éˆ•å„ªåŒ–
        {
          type: "button",
          style: "primary",
          color: colors.danger,
          height: "sm",
          action: { type: "uri", label: "ç«‹å³å®Œæˆè¨‚å–® â–¸", uri: url },
        },
        // ğŸ›ï¸ å¿ƒç†æš—ç¤ºå°å­—
        {
          type: "text",
          text: "æ‚¨çš„å•†å“å·²æš«æ™‚ä¿ç•™ï¼Œè«‹å„˜é€Ÿçµå¸³",
          size: "xxs",
          color: colors.textSub,
          align: "center",
          margin: "md"
        }
      ]
    }
  };
}
async function sendPayResultFlex(env, rec, opts) {
  if (!rec || !rec.fields) return; 
  const f = rec.fields || {}; 
  const { success, failReason } = opts || {};
  

  // â˜… Debugï¼šçœ‹é€™æ”¯ function æœ‰æ²’æœ‰è¢«å‘¼å«åˆ°ã€token / line_user_id ç‹€æ…‹
  console.log("sendPayResultFlex start", {
    order_id: f.order_id || "",
    success,
    failReason: failReason || "",
    hasToken: !!env.LINE_CHANNEL_ACCESS_TOKEN,
    line_user_id_field: f.line_user_id || "",
  });

  // 1) å…ˆå¾ shipping_info è§£æå‡ºæ”¶ä»¶äºº & LINE
  let shipInfo = {};
  try {
    if (f.shipping_info) shipInfo = JSON.parse(f.shipping_info);
  } catch (e) {
    console.log("sendPayResultFlex: shipping_info parse error", e);
    shipInfo = {};
  }


  const ship = shipInfo.ship || {};
  let line   = shipInfo.line || shipInfo.line_profile || {};

  let lineUserId =
    line.user_id ||
    line.userId ||
    line.LINE_USER_ID ||
    f.line_user_id ||
    "";

  let displayName =
    line.display_name ||
    line.displayName ||
    line.name ||
    f.line_name ||
    "";

  // 2) å¦‚æœè¨‚å–®è£¡é‚„æ˜¯æ²’æœ‰ LINE â†’ ç”¨é›»è©± / Email å» LineMembers æ‰¾
  if (!lineUserId) {
    const phone = ship.phone || "";
    const email = ship.email || "";

    if (phone || email) {
      const TM = env.AT_LINE_MEMBERS || "LineMembers";
      const parts = [];
      if (phone) parts.push(`{Phone}='${esc(phone)}'`);
      if (email) parts.push(`{Email}='${esc(email)}'`);

      if (parts.length) {
        const formula =
          parts.length === 1 ? parts[0] : `OR(${parts.join(",")})`;
        try {
          const res = await at(env, "GET", TM, "", null, {
            filterByFormula: formula,
            maxRecords: "1",
          });
          const mrec = res.records && res.records[0];
          if (mrec && mrec.fields) {
            const mf = mrec.fields;
            lineUserId =
              mf.LineUserId ||
              mf.LINE_USER_ID ||
              mf.line_user_id ||
              lineUserId;

            if (!displayName) {
              displayName =
                mf.DisplayName ||
                mf.display_name ||
                mf.Name ||
                displayName;
            }
          }
        } catch (e) {
          console.log("sendPayResultFlex: LineMembers search error", e);
        }
      }
    }
  }

  // 3) é‚„æ˜¯æ²’æœ‰ lineUserId â†’ ä¸ç™¼ï¼Œé¿å… LINE 400
  if (!lineUserId) {
    console.log(
      "sendPayResultFlex: no lineUserId, skip",
      f.order_id || ""
    );
    return;
  }

   // â˜… Debugï¼šçœŸçš„è¦æ¨æ’­ä¹‹å‰å†å°ä¸€æ¬¡
   console.log("sendPayResultFlex push", {
    order_id: f.order_id || "",
    userId: lineUserId,
  });

  const orderId = String(f.order_id || "").trim();
  const customerName =
    (displayName || String(ship.name || "").trim() || "è²´è³“").trim();

  // é‡‘é¡ï¼šå„ªå…ˆç”¨ net_amountï¼ˆæ‰£æ‰è³¼ç‰©é‡‘å¾Œçš„å¯¦éš›æ‡‰æ”¶ï¼‰
  const total = Number(
    f.net_amount ??
    f.total_amount ??
    f.total ??
    0
  ) || 0;

  const amountText = total
    ? `NT$ ${total.toLocaleString("zh-TW")}`
    : "";

  const pm = String(f.payment_method || "");
  let payMethodLabel = "";

  // è·Ÿä½ åŸæœ¬çš„ä¸€æ¨£ï¼Œæˆ‘åªæ•´ç†ä¸€ä¸‹
  switch (pm) {
    // ç·šä¸Šåˆ·å¡ / ç¬¬ä¸‰æ–¹
    case "paid_linepay":
      payMethodLabel = "LINE Pay ç·šä¸Šä»˜æ¬¾";
      break;
      case "paid_af":
        case "paid_aftee_direct":
        case "aftee_direct":
          payMethodLabel = "AFTEE å…ˆäº«å¾Œä»˜";
          break;
    case "paid_card_once":
      payMethodLabel = "ä¿¡ç”¨å¡ä¸€æ¬¡ä»˜æ¸…";
      break;
    case "paid_card_inst_3":
      payMethodLabel = "ä¿¡ç”¨å¡åˆ† 3 æœŸ";
      break;
    case "paid_card_inst_6":
      payMethodLabel = "ä¿¡ç”¨å¡åˆ† 6 æœŸ";
      break;
    case "paid_card_inst_9":
      payMethodLabel = "ä¿¡ç”¨å¡åˆ† 9 æœŸ";
      break;

    // ä¸­ç§Ÿé›¶å¡
    case "zero_card_3":
      payMethodLabel = "ä¸­ç§Ÿåˆ†æœŸ 3 æœŸï¼ˆé›¶åˆ©ç‡ï¼‰";
      break;
    case "zero_card_6":
      payMethodLabel = "ä¸­ç§Ÿåˆ†æœŸ 6 æœŸ";
      break;
    case "zero_card_9":
      payMethodLabel = "ä¸­ç§Ÿåˆ†æœŸ 9 æœŸ";
      break;
    case "zero_card_12":
      payMethodLabel = "ä¸­ç§Ÿåˆ†æœŸ 12 æœŸ";
      break;
    case "zero_card_18":
      payMethodLabel = "ä¸­ç§Ÿåˆ†æœŸ 18 æœŸ";
      break;
    case "zero_card_24":
      payMethodLabel = "ä¸­ç§Ÿåˆ†æœŸ 24 æœŸ";
      break;

      case "yufu_inst_3":
      payMethodLabel = "è£•å¯Œåˆ†æœŸ 3 æœŸï¼ˆé›¶åˆ©ç‡ï¼‰";
      break;
    case "yufu_inst_6":
      payMethodLabel = "è£•å¯Œåˆ†æœŸ 6 æœŸ";
      break;
    case "yufu_inst_9":
      payMethodLabel = "è£•å¯Œåˆ†æœŸ 9 æœŸ";
      break;
    case "yufu_inst_12":
      payMethodLabel = "è£•å¯Œåˆ†æœŸ 12 æœŸ";
      break;
    case "yufu_inst_24":
      payMethodLabel = "è£•å¯Œåˆ†æœŸ 24 æœŸ";
      break;
    case "yufu_inst_36":
      payMethodLabel = "è£•å¯Œåˆ†æœŸ 36 æœŸ";
      break;

      case "atm_full_tail":
      payMethodLabel = "åŒ¯æ¬¾/è³¼ç‰©é‡‘";
      break;

    // è²¨åˆ°ä»˜æ¬¾
    case "cod_711":
      payMethodLabel = "7-11 å–è²¨ä»˜æ¬¾";
      break;
    case "cod_post":
      payMethodLabel = "å®…é…è²¨åˆ°ä»˜æ¬¾";
      break;

    // åŒ¯æ¬¾ï¼è¨‚é‡‘ï¼ˆä¸ç´°åˆ†æ–°èˆŠå®¢ï¼‰
    case "deposit_new_partial":
    case "deposit_old_partial":
    case "deposit_new":
    case "deposit_old":
    case "atm_deposit":
      payMethodLabel = "å®šé‡‘åŒ¯æ¬¾";
      break;

    case "deposit_new_full":
    case "deposit_old_full":
    case "deposit_new_full_711":
    case "deposit_new_full_post":
    case "atm_full":
      payMethodLabel = "å…¨é¡åŒ¯æ¬¾";
      break;

    default:
      payMethodLabel = pm || "";
  }

  if (success) {
    // --- é€™è£¡è£œ 2 ç¨®é‡‘é¡ï¼šå¯¦æ”¶(å¯èƒ½æ‰£è³¼ç‰©é‡‘) / è¨‚å–®ç¸½é¡ ---
    const orderTotal = Number(f.total_amount ?? f.total ?? 0) || 0;
    const paidTotal  = Number(f.net_amount ?? f.total_amount ?? f.total ?? 0) || 0;
  
    const orderTotalText = orderTotal ? `NT$ ${orderTotal.toLocaleString("zh-TW")}` : "";
    const paidTotalText  = paidTotal  ? `NT$ ${paidTotal.toLocaleString("zh-TW")}`  : "";
  
    // âœ… åˆ¤æ–·æ˜¯å¦ã€Œè¨‚é‡‘åŒ¯æ¬¾ã€
    const isDeposit =
      pm === "deposit_new_partial" ||
      pm === "deposit_old_partial" ||
      pm === "deposit_new" ||
      pm === "deposit_old" ||
      pm === "atm_deposit";
  
    // âœ… ç›¡é‡æŠ“åˆ°è¨‚é‡‘é‡‘é¡ï¼ˆå¤šä¾†æºå®¹éŒ¯ï¼‰
    const depObj = (ship && ship.deposit) || shipInfo.deposit || {};
    const depAmt = Number(
      f.deposit_amount ??
      depObj.amount ??
      depObj.deposit_amount ??
      ship.deposit_amount ??
      0
    ) || 0;
  
    const depText = depAmt ? `NT$ ${depAmt.toLocaleString("zh-TW")}` : "";
  
    const bubble = buildPaymentSuccessFlexBubble({
      orderId,
      payMethodLabel,
  
      // è¨‚é‡‘åŒ¯æ¬¾æˆåŠŸï¼šä¸»åˆ—é¡¯ç¤ºã€Œè¨‚å–®ç¸½é¡ã€
  amountLabel: isDeposit ? "è¨‚å–®ç¸½é¡" : "ä»˜æ¬¾ç¸½é¡",
  amountText:  isDeposit ? (orderTotalText || paidTotalText) : paidTotalText,

  // è¨‚é‡‘åŒ¯æ¬¾æˆåŠŸï¼šå¤šä¸€åˆ—ã€Œä»˜æ¬¾è¨‚é‡‘ã€
  extraRows: isDeposit && depText ? [{ label: "ä»˜æ¬¾å®šé‡‘", value: depText }] : []
});
  
    await linePushFlex(
      env,
      lineUserId,
      `è¨‚å–® ${orderId} ä»˜æ¬¾æˆåŠŸ`,
      bubble
    );
  } else {
    // âŒ ä»˜æ¬¾å¤±æ•—ï¼šä¸€éµé‡æ–°çµå¸³ï¼ˆç”±å¾Œç«¯é‡å»ºæ–° cart_token å†å°å›çµå¸³é ï¼‰
    const apiBase = (env.API_BASE || "https://api.murain.tw").replace(/\/+$/, "");
    const retryUrl = `${apiBase}/order/retry-checkout?order_id=${encodeURIComponent(orderId)}`;
  
    const bubble = buildPaymentFailFlexBubble({
      customerName,
      orderId,
      amountText,
      retryUrl,
    });
  
    await linePushFlex(
      env,
      lineUserId,
      `è¨‚å–® ${orderId} ä»˜æ¬¾æœªæˆåŠŸ`,
      bubble
    );
  } // end else
}   // end sendPayResultFlex

// å°¾æ¬¾æé†’ Flex å¡ç‰‡ï¼ˆæ‰‹å‹•ï¼‹è‡ªå‹•å…±ç”¨ï¼‰
function buildTailRemindFlexBubble(params) {
  const {
    customerName,
    orderId,
    holdUntilText,
    tailAmountText,
    tailUrl,
  } = params || {};

  const name  = (customerName || "è²´è³“").toString().trim() || "è²´è³“";
  const order = (orderId || "").toString().trim();
  const hold  = (holdUntilText || "").toString().trim();
  const tail  = (tailAmountText || "").toString().trim();
  const url   = (tailUrl || "https://murain.tw").toString().trim();

  return {
    type: "bubble",
    size: "kilo",
    header: {
      type: "box",
      layout: "vertical",
      backgroundColor: "#1A1A1A",
      paddingAll: "20px",
      contents: [
        {
          type: "text",
          text: "è«‹å®Œæˆæœ€å¾Œä»˜æ¬¾",
          weight: "bold",
          color: "#D4AF37",
          size: "lg",      // æ¯”å‰›å‰›æ›´å¤§
          align: "center"
        }
      ]
    },
    body: {
      type: "box",
      layout: "vertical",
      paddingAll: "24px",
      contents: [
        {
          type: "text",
          text: `${name} æ‚¨å¥½`,
          size: "xxs",
          color: "#aaaaaa",
          weight: "bold"
        },
        {
          type: "text",
          text: "æ‚¨çš„è¨‚å–®ä¿ç•™æœŸå³å°‡æˆªæ­¢ã€‚\nç‚ºç¢ºä¿æ‚¨çš„æ¬Šç›Šï¼Œè«‹æ–¼æœŸé™å…§å®Œæˆçµå¸³ã€‚",
          size: "sm",
          color: "#333333",
          wrap: true,
          margin: "md"
        },
        {
          type: "separator",
          margin: "xl",
          color: "#f0f0f0"
        },
        {
          type: "box",
          layout: "vertical",
          margin: "xl",
          spacing: "md",
          contents: [
            {
              type: "box",
              layout: "horizontal",
              contents: [
                {
                  type: "text",
                  text: "è¨‚å–®ç·¨è™Ÿ",
                  color: "#aaaaaa",
                  size: "xxs",
                  flex: 2
                },
                {
                  type: "text",
                  text: order || "-",
                  wrap: false,
                  color: "#666666",
                  size: "xs",
                  flex: 4
                }
              ]
            },
            {
              type: "box",
              layout: "horizontal",
              contents: [
                {
                  type: "text",
                  text: "ä¿ç•™æœŸé™",
                  color: "#aaaaaa",
                  size: "xxs",
                  flex: 2
                },
                {
                  type: "text",
                  text: hold || "-",
                  wrap: true,
                  color: "#333333",
                  size: "sm",
                  weight: "bold",
                  flex: 4
                }
              ]
            },
            {
              type: "box",
              layout: "horizontal",
              contents: [
                {
                  type: "text",
                  text: "å°¾æ¬¾é‡‘é¡",
                  color: "#aaaaaa",
                  size: "xxs",
                  flex: 2
                },
                {
                  type: "text",
                  text: tail || "-",
                  wrap: true,
                  color: "#C5A065",
                  size: "xl",
                  weight: "bold",
                  flex: 4
                }
              ]
            }
          ]
        }
      ]
    },
    footer: {
      type: "box",
      layout: "vertical",
      paddingAll: "24px",
      paddingTop: "0px",
      contents: [
        {
          type: "button",
          style: "primary",
          height: "sm",
          color: "#1A1A1A",
          action: {
            type: "uri",
            label: "å‰å¾€çµå¸³",
            uri: url
          }
        }
      ]
    },
    styles: {
      footer: {
        backgroundColor: "#ffffff"
      }
    }
  };
}

function nt(n){
  return "NT$ " + (Math.round(Number(n || 0) || 0)).toLocaleString("zh-TW");
}

function tailPayMethodLabel(pm){
  const p = String(pm || "").trim().toLowerCase();

  // ---- COD / 7-11 ----
  if (p === "cod_711" || p === "cod711" || p === "pickup_711" || p === "pickup711") {
    return "7-11 å–è²¨ä»˜æ¬¾";
  }

  // ---- Credit only tail ----
  if (p === "credit_only_tail") return "è³¼ç‰©é‡‘æŠ˜æŠµï¼ˆå°¾æ¬¾ 0 å…ƒï¼‰";

  // ---- ATM / mixed ----
  if (p === "atm_full_tail") return "åŒ¯æ¬¾/è³¼ç‰©é‡‘";
  if (p === "atm" || p === "atm_full" || p === "atm_partial") return "ATM åŒ¯æ¬¾";

  // ---- PayUNI online paid_* ----
  if (p === "paid_linepay") return "LINE Pay";
  if (p === "paid_card_once") return "ä¿¡ç”¨å¡ä¸€æ¬¡ä»˜æ¸…";

  const m1 = p.match(/^paid_card_inst_(\d+)$/);
  if (m1) return `ä¿¡ç”¨å¡åˆ†æœŸ ${m1[1]} æœŸ`;

  // ---- AFTEE ----
  if (p === "paid_af" || p === "paid_aftee" || p === "paid_aftee_direct") return "AFTEE å…ˆäº«å¾Œä»˜";

  // ---- Installment ----
  const m2 = p.match(/^zero_card_(\d+)$/);
  if (m2) return `ä¸­ç§Ÿç„¡å¡åˆ†æœŸ ${m2[1]} æœŸ`;

  const m3 = p.match(/^yufu_inst_(\d+)$/);
  if (m3) return `è£•å¯Œåˆ†æœŸ ${m3[1]} æœŸ`;

  return String(pm || "-");
}

function buildTailCheckoutCompleteFlexBubble(params){
  const {
    orderId,
    parentOrderId,
    tailAmount,
    creditUsed,
    netAmount,
    paymentMethod,
    buttonUrl
  } = params || {};

  const net = Math.max(0, Math.round(Number(netAmount || 0) || 0));
  const tail = Math.max(0, Math.round(Number(tailAmount || 0) || 0));
  const cu   = Math.max(0, Math.round(Number(creditUsed || 0) || 0));

  const isPaidByCredit = (tail > 0 && cu > 0 && net === 0);

  const amountLabel = isPaidByCredit ? "å°¾æ¬¾é‡‘é¡" : "å°¾æ¬¾æ‡‰ä»˜";
  const amountText  = isPaidByCredit ? nt(tail) : nt(net);

  const rows = isPaidByCredit
    ? [
        { label: "åŸè¨‚å–®", value: parentOrderId || "-" },
        { label: "è³¼ç‰©é‡‘æŠ˜æŠµ", value: nt(cu) },
        { label: "å¯¦ä»˜é‡‘é¡", value: nt(0) }
      ]
    : [
        { label: "åŸè¨‚å–®", value: parentOrderId || "-" },
        { label: "å°¾æ¬¾åŸé¡", value: nt(tail) },
        { label: "è³¼ç‰©é‡‘æŠ˜æŠµ", value: nt(cu) }
      ];

  return buildSimpleConfirmBubble({
    topLabel: isPaidByCredit ? "PAYMENT" : "TAIL PAYMENT",
    title: isPaidByCredit ? "å°¾æ¬¾å·²ä»˜æ¸…" : "å°¾æ¬¾çµå¸³å®Œæˆ",
    amountLabel,
    amountText,
    rows: [
      { label: "å°¾æ¬¾å–®è™Ÿ", value: orderId || "-" },
      ...rows
    ],
    payMethodLabel: tailPayMethodLabel(paymentMethod),
    buttonLabel: "æŸ¥çœ‹è¨‚å–®",
    buttonUrl: buttonUrl || "https://murain.tw"
  });
}

async function sendTailCheckoutCompleteFlex(env, opts){
  const {
    lineUserId,
    orderId,
    parentOrderId,
    tailAmount,
    creditUsed,
    netAmount,
    paymentMethod
  } = opts || {};

  if (!lineUserId) return;

  const memberLiffId =
    String(env.LIFF_MEMBER_ID || env.LIFF_ID_MEMBER || LIFF_MEMBER_ID_DEFAULT || "2008430261-EGZPg3Qp").trim();
  const memberUrl = memberLiffId.startsWith("http")
    ? memberLiffId
    : `https://liff.line.me/${memberLiffId}`;

  const bubble = buildTailCheckoutCompleteFlexBubble({
    orderId,
    parentOrderId,
    tailAmount,
    creditUsed,
    netAmount,
    paymentMethod,
    buttonUrl: memberUrl
  });

  await linePushFlex(env, lineUserId, "å°¾æ¬¾çµå¸³é€šçŸ¥", bubble);
}
// -------------------- CORS helpers --------------------

async function sendCheckoutCompleteFlex(env, opts) {
  const {
    lineUserId,
    displayName,
    orderId,
    amount,
    paymentMethod,
    shipping_info
  } = opts || {};

  if (!lineUserId || !orderId) return;

  const shipInfo = shipping_info || {};
  const ship = shipInfo.ship || {};

  // amount å¯èƒ½æ˜¯ number æˆ– "NT$ 7,000"
  let n = 0;
  if (typeof amount === "number") n = amount;
  else if (typeof amount === "string") n = Number(amount.replace(/[^\d.-]/g, ""));
  else n = Number(amount || 0);
  if (!Number.isFinite(n)) n = 0;

  const amountText = `NT$ ${Math.round(n).toLocaleString("zh-TW")}`;
  const pm = String(paymentMethod || "").trim().toLowerCase();

  // æ”¶ä»¶äººé¡¯ç¤º
  const customerName = (displayName || ship.name || "è²´è³“").toString().trim() || "è²´è³“";

      // âœ… 1) 7-11 å–è²¨ä»˜æ¬¾
  if (pm === "cod_711") {
    const storeObj  = ship.store || shipInfo.store || {};
    const storeName = ship.store_name || storeObj.name || shipInfo.store_name || "";
    const storeAddr = ship.store_addr || storeObj.addr || shipInfo.store_addr || "";

    // âœ… æ”¶ä»¶äººï¼šå„ªå…ˆæ”¶ä»¶è³‡æ–™ï¼ˆshipï¼‰ï¼Œæ²’æœ‰æ‰é€€å› LINE åç¨±
    const shipReceiverName = String(
      ship.name ??
      ship.receiver_name ??
      ship.recipient_name ??
      ship.to_name ??
      shipInfo.name ??
      shipInfo.receiver_name ??
      shipInfo.recipient_name ??
      shipInfo.customer_name ??
      ""
    ).trim();

    const receiverName =
      shipReceiverName ||
      String(displayName || "").trim() ||
      "è²´è³“";

    const bubble = buildCod711CheckoutFlexBubble({
      customerName: receiverName,
      orderId,
      amountText,
      storeName,
      storeAddr
    });

    await linePushFlex(env, lineUserId, `è¨‚å–® ${orderId} çµå¸³å®Œæˆ`, bubble);
    return;
  }
  // âœ… 2) é¢äº¤ä»˜ç¾ï¼ˆä½ è¦çš„ï¼šçµå¸³å®Œæˆå°±é€šçŸ¥ï¼‰
  if (pm === "meetup_cash") {
    // å…¼å®¹å„ç¨®ä½ å¯èƒ½å­˜çš„æ¬„ä½å‘½å
    const meetupTime =
      ship.meetup_time ||
      ship.meetupTime ||
      ship.meetup?.time ||
      shipInfo.meetup_time ||
      shipInfo.meetupTime ||
      shipInfo.meetup?.time ||
      "-";

    // ä½ å›ºå®šåœ°å€ï¼ˆä¹Ÿå¯æ”¹æˆ env.MEETUP_ADDRESSï¼‰
    const meetupAddr = "å°å—å¸‚ä½³é‡Œå€ç¾©æ°‘è¡—339è™Ÿä¸€æ¨“";

    const memberUrl = `https://liff.line.me/2008430261-EGZPg3Qp`;

    const bubble = buildSimpleConfirmBubble({
      topLabel: "ORDER CONFIRMED",
      title: "é¢äº¤ä»˜ç¾",
      amountText,
      rows: [
        { label: "è¨‚å–®ç·¨è™Ÿ", value: orderId || "-" },
        { label: "é¢äº¤æ™‚é–“", value: meetupTime || "-" },
        { label: "é¢äº¤åœ°é»", value: meetupAddr }
      ],
      buttonLabel: "æŸ¥çœ‹è¨‚å–®",
      buttonUrl: memberUrl
    });

    await linePushFlex(env, lineUserId, `è¨‚å–® ${orderId} çµå¸³å®Œæˆ`, bubble);
    return;
  }

    // âœ… 3) åŒ¯æ¬¾å®šé‡‘ï¼ˆä¿ç•™ï¼‰
  // å‰ç«¯ï¼špayment_method='deposit_old'ï¼Œä¸” ship.deposit.type='old'ï¼ˆæœ‰ last5/hold_until/amountï¼‰
  if (
    pm === "deposit_old" ||
    pm === "atm_deposit" ||
    pm === "deposit_old_partial" ||
    (ship.deposit && String(ship.deposit.type || "").toLowerCase() === "old")
  ) {
    const dep = ship.deposit || {};
    const last5 =
      String(dep.last5 || ship.deposit_last5 || shipInfo.deposit_last5 || "").trim();
    const holdUntilRaw =
      String(dep.hold_until || ship.hold_until || shipInfo.hold_until || "").trim();

    // å®šé‡‘é‡‘é¡ï¼šæœ‰å¡«å°±é¡¯ç¤ºå®šé‡‘ï¼Œæ²’å¡«å°±é¡¯ç¤ºè¨‚å–®æ‡‰ä»˜é‡‘é¡
    const depAmount = Number(dep.amount ?? ship.deposit_amount ?? shipInfo.deposit_amount ?? 0);
    const showAmountText =
      Number.isFinite(depAmount) && depAmount > 0
        ? `NT$ ${Math.round(depAmount).toLocaleString("zh-TW")}`
        : amountText;

    // å–è²¨è³‡è¨Šï¼ˆ711 / post / meetupï¼‰
    let shipPlace = "-";
    if (String(ship.type || "").toLowerCase() === "711") {
      const storeObj = ship.store || shipInfo.store || {};
      const storeName = ship.store_name || storeObj.name || shipInfo.store_name || "";
      const storeAddr = ship.store_addr || storeObj.addr || shipInfo.store_addr || "";
      shipPlace = [storeName, storeAddr].filter(Boolean).join(" ") || "-";
    } else if (String(ship.type || "").toLowerCase() === "post") {
      const postObj = ship.post || shipInfo.post || {};
      const zip = postObj.zip || "";
      const addr = postObj.addr || "";
      shipPlace = [zip, addr].filter(Boolean).join(" ") || "-";
    } else if (String(ship.type || "").toLowerCase() === "meetup") {
      const meetupTime =
        ship.meetup_time || ship.meetupTime || ship.meetup?.time ||
        shipInfo.meetup_time || shipInfo.meetupTime || shipInfo.meetup?.time || "-";
      shipPlace = `é¢äº¤ ${meetupTime}`;
    }

    const holdUntilText = holdUntilRaw ? holdUntilRaw.slice(0, 10) : "";

    const memberUrl = `https://liff.line.me/2008430261-EGZPg3Qp`;

    const rows = [
      { label: "è¨‚å–®ç·¨è™Ÿ", value: orderId || "-" },
      { label: "å–è²¨æ–¹å¼", value: shipPlace || "-" },
      ...(last5 ? [{ label: "å¸³è™Ÿå¾Œäº”ç¢¼", value: last5 }] : []),
      ...(holdUntilText ? [{ label: "ä¿ç•™åˆ°æœŸæ—¥", value: holdUntilText }] : [])
    ];

    const bubble = buildSimpleConfirmBubble({
      topLabel: "ORDER CONFIRMED",
      title: "æ”¶åˆ°åŒ¯æ¬¾é€šçŸ¥ï½œå°å¹«æ‰‹å°å¸³ä¸­",
      amountText: showAmountText,
      rows,
      buttonLabel: "æŸ¥çœ‹æ ¸å°é€²åº¦",
      buttonUrl: memberUrl
    });

    await linePushFlex(env, lineUserId, `è¨‚å–® ${orderId} çµå¸³å®Œæˆ`, bubble);
    return;
  }

  // âœ… 4) åŒ¯æ¬¾ï¼ˆå…¨é¡ï¼‰
  // å‰ç«¯ï¼špayment_method='deposit_new_full'ï¼Œä¸” ship.deposit.type='new_full'ï¼ˆé€šå¸¸æœ‰ last5ï¼‰
  if (
    pm === "deposit_new_full" ||
    pm === "atm_full" ||
    pm === "bank_transfer" ||
    (ship.deposit && String(ship.deposit.type || "").toLowerCase() === "new_full")
  ) {
    const dep = ship.deposit || {};
    const last5 =
      String(dep.last5 || ship.deposit_last5 || shipInfo.deposit_last5 || "").trim();

    let shipPlace = "-";
    if (String(ship.type || "").toLowerCase() === "711") {
      const storeObj = ship.store || shipInfo.store || {};
      const storeName = ship.store_name || storeObj.name || shipInfo.store_name || "";
      const storeAddr = ship.store_addr || storeObj.addr || shipInfo.store_addr || "";
      shipPlace = [storeName, storeAddr].filter(Boolean).join(" ") || "-";
    } else if (String(ship.type || "").toLowerCase() === "post") {
      const postObj = ship.post || shipInfo.post || {};
      const zip = postObj.zip || "";
      const addr = postObj.addr || "";
      shipPlace = [zip, addr].filter(Boolean).join(" ") || "-";
    } else if (String(ship.type || "").toLowerCase() === "meetup") {
      const meetupTime =
        ship.meetup_time || ship.meetupTime || ship.meetup?.time ||
        shipInfo.meetup_time || shipInfo.meetupTime || shipInfo.meetup?.time || "-";
      shipPlace = `é¢äº¤ ${meetupTime}`;
    }

    const memberUrl = `https://liff.line.me/2008430261-EGZPg3Qp`;

    const rows = [
      { label: "è¨‚å–®ç·¨è™Ÿ", value: orderId || "-" },
      { label: "å–è²¨æ–¹å¼", value: shipPlace || "-" },
      ...(last5 ? [{ label: "å¸³è™Ÿå¾Œäº”ç¢¼", value: last5 }] : [])
    ];

    const bubble = buildSimpleConfirmBubble({
      topLabel: "ORDER CONFIRMED",
      title: "æ”¶åˆ°åŒ¯æ¬¾é€šçŸ¥ï½œå°å¹«æ‰‹å°å¸³ä¸­",
      amountText,
      rows,
      buttonLabel: "æŸ¥çœ‹æ ¸å°é€²åº¦",
      buttonUrl: memberUrl
    });

    await linePushFlex(env, lineUserId, `è¨‚å–® ${orderId} çµå¸³å®Œæˆ`, bubble);
    return;
  }
  // âœ… 5) è£•å¯Œåˆ†æœŸï¼ˆå¯©æ ¸ä¸­ï¼‰
  if (pm.startsWith("yufu_inst_")) {
    const months = pm.split("_").pop() || "";
    // å–è²¨è³‡è¨Šï¼ˆ711 / post / meetupï¼‰
    let shipPlace = "-";
    if (String(ship.type || "").toLowerCase() === "711") {
      const storeObj = ship.store || shipInfo.store || {};
      const storeName = ship.store_name || storeObj.name || shipInfo.store_name || "";
      const storeAddr = ship.store_addr || storeObj.addr || shipInfo.store_addr || "";
      shipPlace = [storeName, storeAddr].filter(Boolean).join(" ") || "-";
    } else if (String(ship.type || "").toLowerCase() === "post") {
      const postObj = ship.post || shipInfo.post || {};
      const zip = postObj.zip || "";
      const addr = postObj.addr || "";
      shipPlace = [zip, addr].filter(Boolean).join(" ") || "-";
    } else if (String(ship.type || "").toLowerCase() === "meetup") {
      const meetupTime =
        ship.meetup_time || ship.meetupTime || ship.meetup?.time ||
        shipInfo.meetup_time || shipInfo.meetupTime || shipInfo.meetup?.time || "-";
      shipPlace = `é¢äº¤ ${meetupTime}`;
    }

    const memberUrl = `https://liff.line.me/2008430261-EGZPg3Qp`;

      const rows = [
        { label: "è¨‚å–®ç·¨è™Ÿ", value: orderId || "-" },
        { 
          label: "ç‹€æ…‹", 
          // å»ºè­°å¯«æ³•ï¼šç²¾ç°¡èªå¥ä»¥å…ç‰ˆé¢å¤ªæ“ 
          value: "æ”¶ç°¡è¨Šâ”å¡«å¯«â”æˆªåœ–å›å‚³" 
        },
        { label: "æœŸæ•¸", value: months ? `${months} æœŸ` : "-" }
        // å–è²¨æ–¹å¼å·²ç§»é™¤
      ];

    const bubble = buildSimpleConfirmBubble({
      topLabel: "INSTALLMENT",
      title: "è£•å¯Œåˆ†æœŸï½œå¾…æ”¶å–ç°¡è¨Š",
      amountText,
      rows,
      buttonLabel: "æŸ¥çœ‹è¨‚å–®",
      buttonUrl: memberUrl
    });

    await linePushFlex(env, lineUserId, `è£•å¯Œåˆ†æœŸç”³è«‹å·²é€å‡º`, bubble);
    return;
  }

  // å…¶ä»–ä»˜æ¬¾æ–¹å¼å…ˆä¸æ¨æ’­ï¼ˆé¿å…ä½ ç¾åœ¨åˆå¤šä¸€å †å¡ç‰‡ï¼‰
}


function allowedOrigins(env){
  const s = new Set();

  if (env.FRONT_ORIGIN)  s.add(String(env.FRONT_ORIGIN).trim());
  if (env.PREVIEW_ORIGIN) s.add(String(env.PREVIEW_ORIGIN).trim());

  // âœ… LINE LIFF å…§å»ºç€è¦½å™¨å¸¸è¦‹ Origin
  s.add("https://liff.line.me");
  s.add("https://access.line.me");

  return s;
}
function buildCors(env, origin){
  const headers = {
    "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
    "Access-Control-Allow-Headers": "content-type, authorization",
    "Access-Control-Max-Age": "86400",
    "Vary": "Origin"
  };
  if (origin && allowedOrigins(env).has(origin)) {
    headers["Access-Control-Allow-Origin"] = origin;
  }
  return headers;
}
function j(env, origin, data, status=200, extraHeaders={}){
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "content-type":"application/json; charset=utf-8",
      ...buildCors(env, origin),
      ...extraHeaders
    }
  });
}
function html(body, status=200){
  return new Response(body, { status, headers: { "content-type":"text/html; charset=utf-8" } });
}

// ===== PayUNIï¼šAES-256-GCM + SHA256ï¼ˆä¾å®˜æ–¹ PHP / Node.js ç¯„ä¾‹ï¼‰ =====

// Uint8Array â†’ base64
function u8ToBase64(u8) {
  let bin = "";
  u8.forEach(b => bin += String.fromCharCode(b));
  return btoa(bin);
}

// å­—ä¸² â†’ 16é€²ä½å­—ä¸²
function strToHex(str) {
  let hex = "";
  for (let i = 0; i < str.length; i++) {
    hex += str.charCodeAt(i).toString(16).padStart(2, "0");
  }
  return hex;
}

// 16é€²ä½å­—ä¸² â†’ å­—ä¸²
function hexToStr(hex) {
  let str = "";
  for (let i = 0; i < hex.length; i += 2) {
    const code = parseInt(hex.substr(i, 2), 16);
    if (!Number.isNaN(code)) {
      str += String.fromCharCode(code);
    }
  }
  return str;
}

// base64 â†’ Uint8Array
function base64ToU8(b64) {
  const bin = atob(b64);
  const len = bin.length;
  const u8  = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    u8[i] = bin.charCodeAt(i);
  }
  return u8;
}

// PayUNI å›å‚³ EncryptInfo è§£å¯†ï¼šå¾—åˆ°åŸæœ¬çš„ query string åƒæ•¸
async function payuniDecrypt(encryptStr, merKey, merIV) {
  const te = new TextEncoder();
  const td = new TextDecoder();

  const keyBytes = te.encode(String(merKey).trim());   // 32 bytes
  const ivBytes  = te.encode(String(merIV).trim());    // 16 bytes

  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    keyBytes,
    { name: "AES-GCM", length: 256 },
    false,
    ["decrypt"]
  );

  // EncryptInfo æ˜¯ strToHex(cipherB64 + ":::" + tagB64)
  const mergedStr = hexToStr(String(encryptStr).trim());
  const parts = mergedStr.split(":::");
  if (parts.length !== 2) {
    throw new Error("payuni_decrypt_invalid_encryptinfo");
  }
  const [cipherB64, tagB64] = parts;

  const cipherBytes = base64ToU8(cipherB64);
  const tagBytes    = base64ToU8(tagB64);

  // WebCrypto decrypt éœ€è¦ã€Œcipher + tagã€åˆä½µ
  const full = new Uint8Array(cipherBytes.length + tagBytes.length);
  full.set(cipherBytes, 0);
  full.set(tagBytes, cipherBytes.length);

  const plainBuf = await crypto.subtle.decrypt(
    { name: "AES-GCM", iv: ivBytes, tagLength: 128 },
    cryptoKey,
    full
  );

  const plaintext = td.decode(plainBuf); // MerID=...&MerTradeNo=...

  const obj = {};
  const params = new URLSearchParams(plaintext);
  for (const [k, v] of params.entries()) {
    obj[k] = v;
  }
  return obj;
}


// SHA256( key + encryptStr + iv ) â†’ å¤§å¯« 16é€²ä½ï¼ˆå®˜æ–¹æ–‡ä»¶å¯«æ­»é€™å€‹æ ¼å¼ï¼‰:contentReference[oaicite:0]{index=0}
async function payuniHash(encryptStr, merKey, merIV) {
  const txt = String(merKey).trim() + String(encryptStr).trim() + String(merIV).trim();
  const data = new TextEncoder().encode(txt);
  const buf = await crypto.subtle.digest("SHA-256", data);
  const arr = new Uint8Array(buf);
  let hex = "";
  arr.forEach(b => { hex += b.toString(16).padStart(2, "0"); });
  return hex.toUpperCase();
}

// EncryptInfoï¼š
// 1. å…ˆæŠŠç‰©ä»¶è½‰æˆ query string (ç›¸ç•¶æ–¼ PHP http_build_query / Node querystring.stringify)
 // 2. ç”¨ AES-256-GCM(key, iv) åŠ å¯†
// 3. æŠŠã€ŒcipherBase64:::tagBase64ã€æ•´ä¸²è½‰æˆ hex ç•¶ EncryptInfo
async function payuniEncrypt(encData, merKey, merIV) {
  const te = new TextEncoder();

  // 1) ç‰©ä»¶ â†’ URL encoded query string
  const params = new URLSearchParams();
  for (const [k, v] of Object.entries(encData || {})) {
    if (v === undefined || v === null || v === "") continue;
    params.append(k, String(v));
  }
  const plaintext = params.toString(); // MerID=AAA&MerTradeNo=BBB&...

  // 2) AES-256-GCM åŠ å¯†
  const keyBytes = te.encode(String(merKey).trim());   // 32 bytes
  const ivBytes  = te.encode(String(merIV).trim());    // 16 bytes

  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    keyBytes,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt"]
  );

  const cipherBuf = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv: ivBytes, tagLength: 128 },
    cryptoKey,
    te.encode(plaintext)
  );

  // WebCryptoï¼šå›å‚³ = cipher + tag (æœ€å¾Œ 16 bytes æ˜¯ tag)
  const full = new Uint8Array(cipherBuf);
  if (full.length < 16) throw new Error("payuni_encrypt_output_too_short");
  const tagBytes   = full.slice(full.length - 16);
  const dataBytes  = full.slice(0, full.length - 16);

  const cipherB64  = u8ToBase64(dataBytes);
  const tagB64     = u8ToBase64(tagBytes);

  const merged     = `${cipherB64}:::${tagB64}`;
  const encryptStr = strToHex(merged).trim();  // å’Œå®˜æ–¹ Encrypt ç¯„ä¾‹ç›¸åŒæ ¼å¼

  return encryptStr;
}

// å»ºç«‹ PayUNI é€å‡ºç”¨çš„æ¬„ä½ï¼šForm POST â†’ MerID, Version, EncryptInfo, HashInfo:contentReference[oaicite:4]{index=4}
async function buildPayuniRequest(env, orderFields, apiOrigin) {
  const merId = env.PAYUNI_MER_ID;
  const key   = env.PAYUNI_KEY;
  const iv    = env.PAYUNI_IV;
  if (!merId || !key || !iv) {
    throw new Error("PAYUNI_CONFIG_MISSING");
  }

  const front = (env.FRONT_ORIGIN || "https://murain.tw").replace(/\/$/, "");
  // âœ… PAYUNI_API_BASE é˜²å‘†ï¼šé¿å…ä½ ä¸å°å¿ƒå¡«åˆ° .../api/upp æˆ–å°‘äº† /apiï¼Œå°è‡´å‡ºç¾ã€Œç„¡APIå°æ‡‰ç¨‹å¼ã€
let apiBase = String(env.PAYUNI_API_BASE || "https://api.payuni.com.tw/api").trim();

// å»æ‰å°¾ç«¯ /
apiBase = apiBase.replace(/\/+$/g, "");

// å¦‚æœä½ å¡«åˆ° .../upp /linepay /aftee_directï¼Œå…ˆå‰ªæ‰ï¼ˆå¾Œé¢æœƒå†è‡ªè¡ŒåŠ ä¸Šæ­£ç¢º modeï¼‰
apiBase = apiBase.replace(/\/(upp|linepay|aftee_direct)$/i, "");

// è‹¥ä½ åªå¡« domainï¼ˆä¾‹å¦‚ https://api.payuni.com.twï¼‰ï¼Œè£œä¸Š /api
if (!/\/api$/i.test(apiBase)) {
  apiBase = apiBase.replace(/\/+$/g, "") + "/api";
}

  // â˜… å¯¦éš›è«‹æ¬¾é‡‘é¡ï¼štotal_amount - credit_usedï¼ˆè‡³å°‘ 0ï¼‰
const baseTotal   = Number(orderFields.total_amount || orderFields.total || 0) || 0;
const creditUsed  = Number(orderFields.credit_used || 0) || 0;
const payAmount   = baseTotal - creditUsed;
const tradeAmt    = Math.max(0, Math.round(payAmount));

  // âœ… ç”¨ Airtable è¨˜ä¸‹ä¾†çš„ payuni_trade_noï¼Œç¢ºä¿ã€Œé€å‡º/å›å‚³/notifyã€æ°¸é åŒä¸€å€‹
const merTradeNo =
String(orderFields.payuni_trade_no || "").trim() ||
toPayuniTradeNo(orderFields.order_id || orderFields.id || ("O" + Date.now()));

  // shipping_info è§£æï¼ˆä½ çš„çµæ§‹æ˜¯ { ship: {...}, line: {...} }ï¼‰
  let shipInfo = {};
  try {
    shipInfo = JSON.parse(orderFields.shipping_info || "{}");
  } catch (e) {
    shipInfo = {};
  }
  const usrMail = String(shipInfo?.ship?.email || shipInfo?.email || "");
  const prodDesc = String(orderFields.items_text || "MURAIN å•†å“").slice(0, 550);

  const ts        = Math.floor(Date.now() / 1000); // Timestamp = time()
  // æ”¹æˆè®“ PayUni å› POST åˆ°å¾Œç«¯ï¼Œè€Œä¸æ˜¯ç›´æ¥æ‰“ HTML
const returnURL = apiOrigin.replace(/\/+$/, "") + "/payuni/return";
  const notifyURL = (env.PAYUNI_NOTIFY_URL || (apiOrigin + "/payuni/notify"));

  // ---- EncryptInfo é™£åˆ—ï¼ˆä¾å®˜æ–¹ã€ŒEncryptInfoè³‡æ–™åŠ å¯†é™£åˆ—ã€ï¼‰ ----:contentReference[oaicite:6]{index=6}
  const encData = {
    MerID: merId,
    MerTradeNo: merTradeNo,
    TradeAmt: tradeAmt,
    Timestamp: ts,
    ReturnURL: returnURL,
    NotifyURL: notifyURL,
    ProdDesc: prodDesc,
    UsrMail: usrMail,
    Lang: "zh-tw"
  };

  const pm = String(orderFields.payment_method || "");

  // æ”¯ä»˜å·¥å…·åƒæ•¸ï¼ˆC=é¸å¡«ï¼Œ1 = å•Ÿç”¨ï¼‰:contentReference[oaicite:7]{index=7}
  if (pm === "paid_card_once") {
    encData.Credit = 1;             // ä¿¡ç”¨å¡ä¸€æ¬¡ä»˜æ¸…
  } else if (pm.startsWith("paid_card_inst_")) {
    const n = pm.split("_").pop();   // 3 / 6 / 9 ...
    encData.CreditInst = String(n);  // âœ… åªå•Ÿç”¨åˆ†æœŸï¼Œä¸å•Ÿç”¨ä¸€æ¬¡ä»˜æ¸…
  } else if (pm === "paid_linepay") {
    encData.LinePay = 1;
  } else if (pm === "paid_af" || pm === "paid_aftee_direct" || pm === "aftee_direct") {
    encData.Aftee = 1;
  } else if (pm === "paid_atm") {
    encData.ATM = 1;
  }

  const encryptStr = await payuniEncrypt(encData, key, iv);

  // 2) HashInfo
  const hashInfo = await payuniHash(encryptStr, key, iv);

    // âœ… å‰å°è·³è½‰ä¸€å¾‹èµ° UPPï¼ˆæ•´åˆå¼æ”¯ä»˜é ï¼‰
// âŒ ä¸è¦ç”¨ linepay / aftee_direct / credit é€™äº›ã€Œå¹•å¾Œ APIã€ç•¶è·³è½‰ç¶²å€
const base = String(apiBase || "").replace(/\/+$/g, "");
const url  = base + "/upp";
const version = "1.0";

  return {
    url,
    MerID: merId,
    Version: version,
    EncryptInfo: encryptStr,
    HashInfo: hashInfo
  };
}
// ===== ECPay ç™¼ç¥¨ï¼šAES-128-CBC + è‡ªå‹•é–‹ç«‹ B2C é›»å­ç™¼ç¥¨ =====

// åƒæ•¸åŠ å¯†ï¼šå…ˆ JSON.stringifyï¼Œå†æ•´ä¸² urlencodeï¼Œæœ€å¾Œåš AES-128-CBCï¼ˆKey / IV ç”±ç¶ ç•Œæä¾›ï¼‰
async function ecpayEncryptData(dataObj, hashKey, hashIV) {
  const json = JSON.stringify(dataObj || {});
  const urlEncoded = encodeURIComponent(json);

  const te = new TextEncoder();
  const keyBytes = te.encode(String(hashKey).trim()); // 16 bytes
  const ivBytes  = te.encode(String(hashIV).trim());  // 16 bytes

  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    keyBytes,
    { name: "AES-CBC", length: 128 },
    false,
    ["encrypt"]
  );

  const cipherBuf = await crypto.subtle.encrypt(
    { name: "AES-CBC", iv: ivBytes },
    cryptoKey,
    te.encode(urlEncoded)
  );

  const cipherBytes = new Uint8Array(cipherBuf);
  return u8ToBase64(cipherBytes);
}

// è§£å¯†å›ä¾†æ–¹ä¾¿é™¤éŒ¯ç”¨ï¼ˆæ­£å¼ç’°å¢ƒå¯ä»¥ä¿ç•™ logï¼Œç”¨ä¾†æŸ¥éŒ¯ï¼‰
async function ecpayDecryptData(dataStr, hashKey, hashIV) {
  if (!dataStr) return null;

  const te = new TextEncoder();
  const keyBytes = te.encode(String(hashKey).trim());
  const ivBytes  = te.encode(String(hashIV).trim());

  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    keyBytes,
    { name: "AES-CBC", length: 128 },
    false,
    ["decrypt"]
  );

  const cipherBytes = Uint8Array.from(atob(dataStr), c => c.charCodeAt(0));
  const plainBuf = await crypto.subtle.decrypt(
    { name: "AES-CBC", iv: ivBytes },
    cryptoKey,
    cipherBytes
  );

  const urlEncoded = new TextDecoder().decode(plainBuf).trim();
  try {
    const jsonStr = decodeURIComponent(urlEncoded);
    return JSON.parse(jsonStr);
  } catch (e) {
    console.log("ecpayDecryptData parse error", e, urlEncoded);
    return null;
  }
}

// ä¾ order_id æ‰¾ Orders å†é–‹ç™¼ç¥¨
async function issueEcpayInvoiceByOrderId(env, orderId) {
  try {
    const T = env.AT_ORDERS || "Orders";
    const rec = await atFindByField(env, T, "order_id", orderId);
    if (!rec) {
      console.log("ECPay Invoice: order not found", orderId);
      return;
    }
    await issueEcpayInvoiceForOrder(env, rec);
  } catch (e) {
    console.log("ECPay Invoice: issue by orderId error", orderId, e);
  }
}

// å¯¦éš›çµ„ç™¼ç¥¨è³‡æ–™ + å‘¼å«ç¶ ç•Œ B2CInvoice/Issue
async function issueEcpayInvoiceForOrder(env, rec) {
  try {
    if (!rec || !rec.fields) return;
    const f = rec.fields;

    const T          = env.AT_ORDERS || "Orders";
    const merchantId = env.ECPAY_INV_MERCHANT_ID;
    const hashKey    = env.ECPAY_INV_HASH_KEY;
    const hashIV     = env.ECPAY_INV_HASH_IV;
    const apiBase    = (env.ECPAY_INV_API_BASE || "https://einvoice.ecpay.com.tw").replace(/\/+$/, "");

    if (!merchantId || !hashKey || !hashIV || !apiBase) {
      console.log("ECPay Invoice: missing env, skip");
      return;
    }

    // å·²ç¶“æœ‰ç™¼ç¥¨è™Ÿç¢¼å°±ä¸è¦é‡è¤‡é–‹
    if (f.invoice_no) {
      console.log("ECPay Invoice: already issued", f.order_id, f.invoice_no);
      return;
    }

    // åƒ…é™ã€Œå·²ä»˜æ¬¾ã€çš„ç·šä¸Šæ”¯ä»˜ / é›¶å¡è¨‚å–®
    if (String(f.pay_status || "") !== "paid_ok") {
      console.log("ECPay Invoice: pay_status not paid_ok, skip", f.order_id, f.pay_status);
      return;
    }
    // åƒ…é™ã€Œå·²ä»˜æ¬¾ã€çš„ç·šä¸Šæ”¯ä»˜ / é›¶å¡ / è£•å¯Œè¨‚å–®
if (String(f.pay_status || "") !== "paid_ok") {
  console.log("ECPay Invoice: pay_status not paid_ok, skip", f.order_id, f.pay_status);
  return;
}

// âœ… pay_channel å¯èƒ½æ˜¯ç©ºçš„ï¼šç”¨ payment_method æ¨æ–·
let ch = String(f.pay_channel || "").trim().toLowerCase();
const pm = String(f.payment_method || "").trim().toLowerCase();

if (!ch) {
  if (pm.startsWith("paid_")) ch = "payuni";
  else if (pm.startsWith("zero_card_")) ch = "zero_card";
  else if (pm.startsWith("yufu_inst_")) ch = "yufu";
}

if (ch !== "payuni" && ch !== "zero_card" && ch !== "yufu") {
  console.log("ECPay Invoice: not eligible channel, skip", f.order_id, { ch, pm });
  return;
}

    const orderId = String(f.order_id || "").trim();
    if (!orderId) {
      console.log("ECPay Invoice: missing order_id, skip");
      return;
    }

      // â˜… æ±ºå®šç™¼ç¥¨é‡‘é¡èˆ‡è³¼ç‰©é‡‘è³‡è¨Š
    // baseTotal = åŸå§‹è¨‚å–®é‡‘é¡ï¼ˆæœªæ‰£è³¼ç‰©é‡‘ï¼‰
    let baseTotal = 0;
    if (f.total_amount !== undefined && f.total_amount !== null && f.total_amount !== "") {
      baseTotal = Number(f.total_amount) || 0;
    } else if (f.total !== undefined && f.total !== null && f.total !== "") {
      baseTotal = Number(f.total) || 0;
    }

    // å·²ä½¿ç”¨çš„è³¼ç‰©é‡‘ï¼ˆæ²’æœ‰å°±ç•¶ 0ï¼‰
    const creditUsed = Math.round(Number(f.credit_used || 0) || 0);

    // å„ªå…ˆç”¨ net_amountï¼ˆæ–°è¨‚å–®éƒ½æœ‰ï¼‰ï¼ŒèˆŠè¨‚å–®å°±ç”¨ baseTotal - creditUsed
    let rawTotal = 0;
    if (f.net_amount !== undefined && f.net_amount !== null && f.net_amount !== "") {
      rawTotal = Number(f.net_amount) || 0;
    } else {
      rawTotal = baseTotal - creditUsed;
    }

    // ç™¼ç¥¨é‡‘é¡å–å››æ¨äº”å…¥æ•´æ•¸
    const total = Math.round(rawTotal);

    // 0 å…ƒæˆ–è² æ•¸å°±ä¸è¦é–‹ç™¼ç¥¨
    if (!total || total <= 0) {
      console.log(
        "ECPay Invoice: total_amount - credit_used <= 0, skip",
        orderId,
        "baseTotal=", baseTotal,
        "creditUsed=", creditUsed,
        "rawTotal=", rawTotal
      );
      return;
    }

    // â˜… ç™¼ç¥¨å‚™è¨»ï¼šæŠŠè³¼ç‰©é‡‘æŠ˜æŠµå¯«é€²å»
    let invoiceRemark = String(f.invoice_remark || f.Remark || "").trim();
    if (creditUsed > 0) {
      const bonusText =
        (baseTotal ? `åŸåƒ¹ ${baseTotal} å…ƒï¼›` : "") +
        `è³¼ç‰©é‡‘æŠ˜æŠµ ${creditUsed} å…ƒ`;
      invoiceRemark = invoiceRemark
        ? invoiceRemark + "ï¼›" + bonusText
        : bonusText;
    }

    // è§£æ shipping_info æ‹¿åˆ°å®¢äººè³‡æ–™
    let shipInfo = {};
    try {
      if (f.shipping_info) shipInfo = JSON.parse(f.shipping_info);
    } catch (e) {
      console.log("ECPay Invoice: shipping_info JSON parse error", e);
      shipInfo = {};
    }

    const ship  = shipInfo.ship || {};
    const name  = String(ship.name  || "").trim();
    const phone = String(ship.phone || "").trim();
    const email = String(ship.email || "").trim();
    const addr  = String(
      ship.addr ||
      (ship.store && ship.store.addr) ||
      ""
    ).trim();

    // B2Cï¼šæ²’çµ±ç·¨å°±ç©ºå­—ä¸²ï¼Œä¹‹å¾Œè‹¥è¦ B2B å¯ä»¥å¾ shipInfo.tax_id å¸¶é€²ä¾†
    const customerIdentifier = String(shipInfo.tax_id || "").trim();

    // â˜… å“åçµ±ä¸€ï¼šç¶²è·¯è³¼ç‰©è¨‚å–®é‡‘é¡
    const items = [{
      ItemSeq:    1,
      ItemName:   "ç¶²è·¯è³¼ç‰©è¨‚å–®é‡‘é¡",
      ItemCount:  1,
      ItemWord:   "ä»¶",
      ItemPrice:  total,
      ItemTaxType:"1",  // æ‡‰ç¨…
      ItemAmount: total,
      ItemRemark: ""
    }];

    const dataPayload = {
      MerchantID: merchantId,
      RelateNumber: orderId,
      CustomerID: "",
      CustomerIdentifier: customerIdentifier,
      CustomerName: name,
      CustomerAddr: addr,
      CustomerPhone: phone,
      CustomerEmail: email,
      ClearanceMark: "",
      Print: "0",          // ä¸åˆ—å°
      Donation: "0",       // ä¸æè´ˆ
      LoveCode: "",
      CarrierType: "",
      CarrierNum: "",
      TaxType: "1",        // æ‡‰ç¨…
      SalesAmount: total,  // å«ç¨…ç¸½é¡
      InvoiceRemark: invoiceRemark,
      Items: items,
      InvType: "07",       // ä¸€èˆ¬ç¨…
      vat: "1"             // å«ç¨…åƒ¹
    };

    const payload = {
      MerchantID: merchantId,
      RqHeader: { Timestamp: Math.floor(Date.now() / 1000) },
      Data: await ecpayEncryptData(dataPayload, hashKey, hashIV)
    };

    const res = await fetch(apiBase + "/B2CInvoice/Issue", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    let json;
    try {
      json = await res.json();
    } catch (e) {
      console.log("ECPay Invoice: response not JSON", orderId, e);
      return;
    }

    if (!json || json.TransCode !== 1) {
      console.log("ECPay Invoice: TransCode != 1", orderId, json);
      try {
        await at(env, "PATCH", T, "", {
          records: [{ id: rec.id, fields: { invoice_rtn_code: String(json?.TransCode || ""), invoice_rtn_msg: String(json?.TransMsg || json?.Message || "TransCode!=1") } }]
        });
      } catch {}
      return;
    }

    const dataResp = await ecpayDecryptData(json.Data, hashKey, hashIV);
    if (!dataResp) {
      console.log("ECPay Invoice: cannot decrypt Data", orderId, json);
      return;
    }

    console.log("ECPay Invoice response", orderId, dataResp);

    const rtnCode = String(dataResp.RtnCode || "");
    const rtnMsg  = dataResp.RtnMsg || "";
    const invNo   = dataResp.InvoiceNumber || dataResp.InvoiceNo || "";
    const invDate = dataResp.InvoiceDate || "";
    const randNo  = dataResp.RandomNumber || "";

    // å›å¯« Airtableï¼ˆæˆåŠŸæˆ–å¤±æ•—éƒ½è¨˜ rtn_code / rtn_msgï¼Œæ–¹ä¾¿é™¤éŒ¯ï¼‰
    try {
      const fields = {
        invoice_rtn_code: rtnCode,
        invoice_rtn_msg:  rtnMsg
      };
      if (invNo)   fields.invoice_no      = invNo;
      if (invDate) fields.invoice_date    = invDate;
      if (randNo)  fields.invoice_random  = randNo;

      await at(env, "PATCH", T, "", {
        records: [{ id: rec.id, fields }]
      });
      console.log("ECPay Invoice: Airtable updated", orderId, rtnCode, invNo);
    } catch (e) {
      console.log("ECPay Invoice: Airtable update error", orderId, e);
    }

  } catch (e) {
    console.log("ECPay Invoice: error", e);
  }
}




// ===== ZeroCard helperï¼šå‘¼å«ä¸­ç§Ÿ reserve_ec æ‹¿ payment_url_web =====
async function zeroCardReserve(env, apiOrigin, orderFields){
  const apiBase = (env.ZERO_CARD_API_BASE || "").replace(/\/+$/, "");
  if (!apiBase || !env.ZERO_CARD_MERCHANT_ID || !env.ZERO_CARD_API_KEY) {
    throw new Error("ZEROCARD_CONFIG_MISSING");
  }

  // â˜… æ–°å¢ï¼šå‰å°ç¶²å€ï¼ˆçµ¦ display_url ç”¨ï¼‰
  const front = (env.FRONT_ORIGIN || "https://murain.tw").replace(/\/$/, "");

  // è§£æ shipping_info
  let shippingInfo = {};
  try {
    shippingInfo = JSON.parse(orderFields.shipping_info || "{}");
  } catch (e) {
    shippingInfo = {};
  }
  const ship = shippingInfo.ship || {};

  const buyerEmail = ship.email || shippingInfo.email || "";
  const buyerName  = ship.name  || shippingInfo.customer_name || "MURAIN å®¢æˆ¶";
  const buyerPhone = ship.phone || "";

  let shippingAddress = "";
  if (ship.type === "711" && ship.store) {
    const s = ship.store;
    shippingAddress = (`7-11 ${s.name || ""} (${s.id || ""}) ${s.addr || ""}`).trim();
  } else if (ship.type === "post" && ship.post) {
    const p = ship.post;
    shippingAddress = (`${p.zip || ""} ${p.addr || ""}`).trim();
  }

  // å¾ payment_method æŠ“å‡ºåˆ†æœŸæœŸæ•¸ï¼Œä¾‹å¦‚ zero_card_3 / zero_card_6 ...
  const pm = String(orderFields.payment_method || "");
  const installment = parseInt(pm.replace("zero_card_", ""), 10) || 3;

  // â˜… fee_typeï¼š3 æœŸç”±å•†å®¶å¸æ”¶ï¼Œå…¶å®ƒæœŸæ•¸ç”±æ¶ˆè²»è€…è² æ“”
  //   fee_type = "vendor"  â†’ å•†å®¶è² æ“”æ‰‹çºŒè²»
  //   fee_type = "consumer"â†’ æ¶ˆè²»è€…è² æ“”æ‰‹çºŒè²» :contentReference[oaicite:3]{index=3}
  const feeType = (installment === 3) ? "vendor" : "consumer";

  // â˜… å¯¦éš›åˆ†æœŸé‡‘é¡ï¼štotal_amount - credit_used
  const baseAmount  = Number(orderFields.total_amount || 0) || 0;
  const creditUsed2 = Number(orderFields.credit_used || 0) || 0;
  const payAmount2  = Math.max(0, baseAmount - creditUsed2);

  const notifyUrl = apiOrigin.replace(/\/+$/, "") + "/zero-card/notify";

  const body = {
    order_id:     orderFields.order_id,
    product_name: "MURAIN å•†å“åˆ†æœŸ",
    amount:       payAmount2,
    installment,
    fee_type:     feeType,
    notify_url:   notifyUrl,

     // â˜… æ–°å¢ï¼šä¸­ç§Ÿä»˜æ¬¾å®Œè¦å›ä¾†çœ‹çš„çµæœé 
     display_url:  front + "/order-result.html",
     
    valid_days:   3,
    buyer_data: {
      email:            buyerEmail,
      shipping_address: shippingAddress
    }
  };

  const resp = await fetch(apiBase + "/payments/reserve_ec", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "0Card-Merchant-Id": String(env.ZERO_CARD_MERCHANT_ID),
      "0Card-API-Key": String(env.ZERO_CARD_API_KEY)
    },
    body: JSON.stringify(body)
  });

  const text = await resp.text();
  let data;
  try {
    data = JSON.parse(text);
  } catch (e) {
    throw new Error("ZEROCARD_BAD_JSON: " + text);
  }

  if (!resp.ok || data.result !== "000") {
    throw new Error("ZEROCARD_ERROR " + (data.result || resp.status) + " " + (data.result_message || ""));
  }

  const info = data.info_reserve || {};
  const url = info.payment_url_web || info.payment_url_app || "";
  if (!url) {
    throw new Error("ZEROCARD_NO_URL");
  }
  return url;
}
async function atListAll(env, tableName, params = {}) {
  const out = [];
  let offset = null;

  while (true) {
    // ç”¨ URLSearchParams / object éƒ½å¯ä»¥ï¼Œé€™è£¡ç”¨ object ä½†æŠŠå‹åˆ¥æ”¾å¯¬
    /** @type {any} */
    const p = Object.assign({}, params || {}, { pageSize: 100 }); // âœ… æ°¸é  <=100

    if (offset) p.offset = offset;

    const res = await at(env, "GET", tableName, "", null, p);
    out.push(...(res.records || []));

    offset = res.offset;
    if (!offset) break;
  }

  return out;
}

// -------------------- Airtable helpers --------------------
async function at(env, method, table, path="", data=null, params={}){
  const url = new URL(`https://api.airtable.com/v0/${env.AIRTABLE_BASE_ID}/${encodeURIComponent(table)}${path}`);
  for (const [k,v] of Object.entries(params||{})) url.searchParams.set(k, v);
  const init = {
    method,
    headers: {
      "Authorization": `Bearer ${env.AIRTABLE_TOKEN}`,
      "Content-Type": "application/json"
    }
  };
  if (data) init.body = JSON.stringify(data);
  const r = await fetch(url, init);
  if (!r.ok) {
    const txt = await r.text().catch(()=> "");
    throw new Error(`Airtable ${method} ${table}${path} ${r.status} ${txt}`);
  }
  return await r.json();
}
function esc(v){ return String(v??"").replace(/'/g, "''"); }
async function atFindByField(env, table, field, value){
  const filter = `({${field}}='${esc(value)}')`;
  const res = await at(env, "GET", table, "", null, { filterByFormula: filter, maxRecords: "1" });
  return res.records?.[0] || null;
}
async function findActiveOrderByCartToken(env, cartToken) {
  const T = env.AT_ORDERS || "Orders";
  const k = escFormula(String(cartToken || "").trim());
  if (!k) return null;

  const res = await at(env, "GET", T, "", null, {
    filterByFormula: `AND(
      {cart_token}='${k}',
      NOT(OR(
        {pay_status}='cancelled',
        {pay_status}='failed',
        {status}='cancelled'
      ))
    )`,
    maxRecords: "1",
    "sort[0][field]": "created_at",
    "sort[0][direction]": "desc"
  });

  return res.records?.[0] || null;
}
async function atListByField(env, table, field, value){
  const filter = `({${field}}='${esc(value)}')`;
  const res = await at(env, "GET", table, "", null, { filterByFormula: filter, pageSize: "50" });
  return res.records || [];

}

async function isBoundMember(env, lineUserId) {
  if (!lineUserId) return false;
  const TM = env.AT_LINE_MEMBERS || "LineMembers";

  // è‹¥ä½ å·²ç¶“æœ‰ atFindByField å°±ç”¨å®ƒï¼›æ²’æœ‰çš„è©±ç”¨ atListByField ä¹Ÿè¡Œ
  if (typeof atFindByField === "function") {
    const rec = await atFindByField(env, TM, "LineUserId", lineUserId);
    return !!rec;
  }
  const rows = await atListByField(env, TM, "LineUserId", lineUserId);
  return !!(rows && rows[0]);
}

// â¬‡â¬‡â¬‡ åœ¨é€™è£¡åŠ ä¸Š getCreditBalance â¬‡â¬‡â¬‡
// âœ… CreditsLedger å³æ™‚åŠ ç¸½ï¼ˆæ’é™¤ hold/voidï¼‰
async function getCreditBalance(env, lineUserId) {
  const T = env.AT_CREDITS_LEDGER || "CreditsLedger";
  const uid = String(lineUserId || "").trim();
  if (!uid) return 0;

  let total = 0;
  let offset = "";

  do {
    const res = await at(env, "GET", T, "", null, {
      filterByFormula: `{LineUserId}='${esc(uid)}'`,
      pageSize: "100",
      offset: offset || ""
    });

    const records = res.records || [];
    for (const rec of records) {
      const f = rec.fields || {};
      const type = String(f.Type || "").toLowerCase();
      const status = String(f.Status || "").toLowerCase();

      // âœ… é—œéµï¼šhold åªæ˜¯ã€Œé–ä½ã€ï¼Œä¸æ˜¯ã€ŒåŠ å€¼ã€ï¼Œä¸è¦ç®—é€²é¤˜é¡
      if (type === "hold") continue;
      // âœ… è¢« releaseCreditHoldIfNeeded void æ‰çš„ï¼Œä¹Ÿä¸è¦ç®—
      if (status === "hold" || status === "void") continue;

      total += Number(f.Amount || 0) || 0; // æ­£æ•¸=ç™¼æ”¾ï¼›è² æ•¸=ä½¿ç”¨
    }

    offset = res.offset || "";
  } while (offset);

  return Math.max(0, Math.round(total));
}

function shortOrderId(oid) {
  const s = String(oid || "").trim();
  if (!s) return "";
  // ä½ è¦é¡¯ç¤ºå®Œæ•´ä¹Ÿå¯ä»¥ï¼Œé€™è£¡ç”¨å°¾ç¢¼æ¯”è¼ƒä¹¾æ·¨
  return s.slice(-6);
}

function creditDisplayName(type, orderId, reason = "") {
  const t = String(type || "").trim().toLowerCase();
  const oid = String(orderId || "").trim();
  const tail = shortOrderId(oid);
  const suffix = tail ? `ï¼ˆå°¾ç¢¼ ${tail}ï¼‰` : (oid ? `ï¼ˆ${oid}ï¼‰` : "");

  // âœ… ä½ æˆªåœ–å‡ºç¾çš„å¹¾ç¨® typeï¼Œæˆ‘éƒ½å¹«ä½ å°æ‡‰æˆå¥½çœ‹çš„ä¸­æ–‡
  if (t === "use" || t === "spend") return `è³¼ç‰©é‡‘æŠ˜æŠµ${suffix}`;
  if (t === "refund") return `è³¼ç‰©é‡‘é€€å›${suffix}`;
  if (t === "hold") return `è³¼ç‰©é‡‘é æ‰£${suffix}`;
  if (t === "hold_release") return `è³¼ç‰©é‡‘é æ‰£é‡‹æ”¾${suffix}`;

  if (t === "tail") return `å°¾æ¬¾å…¥å¸³${suffix}`;
  if (t === "cod_paid_now_tail") return `å°¾æ¬¾è²¨åˆ°ä»˜æ¬¾æ‰£æ¬¾${suffix}`;

  if (t === "paid_success") return `é‡‘æµ/ç³»çµ±æ‰£æ¬¾${suffix}`;
  if (t === "birthday") return "ç”Ÿæ—¥ç¦®";

  // fallbackï¼šå¦‚æœä½ æœ‰å‚³ reason å°±ç”¨ reasonï¼Œå¦å‰‡æ‰é€€å› type
  return String(reason || "").trim() || (t ? `${t}${suffix}` : `å¸³å‹™ç•°å‹•${suffix}`);
}

async function creditLedgerAdd(env, fields) {
  const T = env.AT_CREDITS_LEDGER || "CreditsLedger";

  // âœ… CreatedAt åœ¨ Airtable æ˜¯ computed â†’ ä¸èƒ½å¯«å…¥
  const f = { ...(fields || {}) };
  delete f.CreatedAt;
  delete f.created_at;

  const payload = {
    records: [{
      fields: f
    }]
  };

  return await at(env, "POST", T, "", payload);
}
async function creditLedgerExists(env, orderId, type = "use") {
    const T = env.AT_CREDITS_LEDGER || "CreditsLedger";
    const oid = String(orderId || "").trim();
    const tp  = String(type || "").trim();
    if (!oid) return false;
  
    const filter = `AND({OrderId}='${esc(oid)}', {Type}='${esc(tp)}')`;
    const res = await at(env, "GET", T, "", null, {
      filterByFormula: filter,
      maxRecords: "1"
    });
  
    return !!(res.records && res.records[0]);
  }

  async function getMemberCreditInfo(env, lineUserId) {
    const T = env.AT_LINE_MEMBERS || "LineMembers";
  
    // âœ… LineMembers ç”¨ LineUserId æ‰¾
    const rows = await atListByField(env, T, "LineUserId", lineUserId);
    const rec = rows && rows[0];
    if (!rec) return null;
  
    const f = rec.fields || {};
  
    // âœ… é¤˜é¡ä»¥ CreditsLedger åŠ ç¸½ç‚ºæº–ï¼ˆä½  member-info ä¹Ÿæ˜¯é€™å¥—ï¼‰
    let store = 0;
    try {
      store = Math.round(Number(await getCreditBalance(env, lineUserId) || 0));
    } catch (e) {
      store = 0;
    }
  
    // âœ… hold åªå­˜åœ¨ LineMembers.credit_hold
    const hold  = Math.round(Number(f.credit_hold || 0) || 0);
    const avail = Math.max(0, store - hold);
  
    return { rec, store, hold, avail };
  }
  
  
  // âœ… å»ºå–®æ™‚ï¼šåªä¿ç•™ï¼ˆä¸å¯¦æ‰£ StoreCreditï¼‰
  async function holdCreditForOrder(env, { lineUserId, orderRecId, orderId, amount, reason = "hold" }) {
    const n = Math.round(Number(amount || 0) || 0);
    const oid = String(orderId || "").trim();
    const uid = String(lineUserId || "").trim();
    if (!uid || !orderRecId || !oid || n <= 0) return;
  
    // âœ… åŒå–®å»é‡ï¼šé¿å…é€£é» / é‡é€ é€ æˆ credit_hold +2
    try {
      const o = await at(env, "GET", env.AT_ORDERS || "Orders", `/${orderRecId}`);
      const of = o?.fields || {};
      if (of.credit_hold_done) return;
    } catch (e) {
      // æŸ¥ä¸åˆ°å°±ç•¶æ²’åšéï¼Œç¹¼çºŒ
    }
  
    const info = await getMemberCreditInfo(env, uid);
    if (!info?.rec?.id) throw new Error("member_not_found");
  
    if (n > (info.avail || 0)) {
      throw new Error(`insufficient_credit_available:${info.avail}`);
    }
  
    // æœƒå“¡ï¼šcredit_hold += amount
    await at(env, "PATCH", env.AT_LINE_MEMBERS || "LineMembers", `/${info.rec.id}`, {
      fields: { credit_hold: (info.hold || 0) + n }
    });
  
    // Ledgerï¼šè¨˜ä¸€ç­† hold
    await creditLedgerAdd(env, {
      LineUserId: uid,
      Type: "hold",
      Amount: Math.abs(n),
      Reason: String(reason || "hold"),
      DisplayName: creditDisplayName("hold", oid, String(reason || "hold")),
      OrderId: oid,
      Status: "hold"
    });
  
    // è¨‚å–®ï¼šæ¨™è¨˜å·² holdï¼ˆå»é‡ç”¨ï¼‰
    await at(env, "PATCH", env.AT_ORDERS || "Orders", `/${orderRecId}`, {
      fields: {
        credit_hold_done: true,
        credit_hold_amount: n,
        credit_hold_reason: String(reason || "hold"),
        credit_hold_at: new Date().toISOString()
      }
    });
  
    return true;
  }
  
  async function spendHeldCreditOnPaid(env, { lineUserId, orderRecId, orderId, amount, reason }) {
    const info = await getMemberCreditInfo(env, lineUserId);
    if (!info) return;
  
    const oid = String(orderId || "").trim();
    const n   = Math.round(Number(amount || 0) || 0);
    if (!oid || n <= 0) return;
    // âœ… å»é‡ï¼šåŒå–® use å·²å­˜åœ¨å°±ä¸è¦å†å‹• holdï¼ˆé¿å… notify/return é‡æ‰“ï¼‰
try {
  const alreadyUse = await creditLedgerExists(env, oid, "use");
  if (alreadyUse) {
    if (orderRecId) {
      await at(env, "PATCH", env.AT_ORDERS || "Orders", "", {
        records: [{ id: orderRecId, fields: { credit_spend_done: true, credit_spend_at: nowISO() } }]
      });
    }
    return;
  }
} catch (e) {}
  
    // âœ… 1) å…ˆæŠŠ hold æ¸›å›ä¾†ï¼ˆé‡‹æ”¾ä¿ç•™ï¼‰
    const hold2 = Math.max(0, info.hold - n);
    await at(env, "PATCH", env.AT_LINE_MEMBERS || "LineMembers", `/${info.rec.id}`, {
      fields: { credit_hold: hold2 }
    });
  
    // âœ… 2) çœŸæ­£æ‰£æ¬¾ï¼šå¯«ä¸€ç­† ledger useï¼ˆä½  spendCredit å…§å»ºå·²åšå»é‡ï¼šåŒå–® use ä¸æœƒé‡æ‰£ï¼‰
    await spendCredit(env, {
      lineUserId,
      orderId: oid,
      amount: n,
      reason: reason || "paid_success_hold_capture"
    });
  
    // âœ… 3) è¨‚å–®æ¨™è¨˜
    if (orderRecId) {
      await at(env, "PATCH", env.AT_ORDERS || "Orders", "", {
        records: [{
          id: orderRecId,
          fields: {
            credit_spend_done: true,
            credit_spend_at: nowISO()
          }
        }]
      });
    }
  }
  
  // âœ… ä»˜æ¬¾å¤±æ•—/å–æ¶ˆ/é€¾æ™‚ï¼šé‡‹æ”¾ holdï¼ˆcredit_hold -= amountï¼‰
async function releaseCreditHold(env, { lineUserId, orderRecId, amount, reason }) {
    // âœ… åŒå–®å»é‡ï¼šå·² release éå°±ä¸è¦å†æ¸› hold
if (orderRecId) {
  try {
    const od = await at(env, "GET", env.AT_ORDERS || "Orders", `/${orderRecId}`);
    if (od?.fields?.credit_hold_release_done) return;
  } catch (e) {}
}
    const info = await getMemberCreditInfo(env, lineUserId);
    if (!info) return;
  
    const n = Math.round(Number(amount || 0) || 0);
    if (n <= 0) return;
  
    const hold2 = Math.max(0, info.hold - n);
  
    await at(env, "PATCH", env.AT_LINE_MEMBERS || "LineMembers", `/${info.rec.id}`, {
      fields: { credit_hold: hold2 }
    });
  
    // âœ… åªåšã€Œé‡‹æ”¾ holdã€æ¨™è¨˜ï¼Œä¸è¦ç”¨ credit_refund_done
    if (orderRecId) {
      await at(env, "PATCH", env.AT_ORDERS || "Orders", "", {
        records: [{
          id: orderRecId,
          fields: {
            credit_hold_release_done: true,
            credit_hold_release_at: nowISO(),
            credit_hold_release_reason: reason || ""
          }
        }]
      });
    }
  }
  // âœ… å°åŒ…è£ï¼šçµ¦æ£„å–®æ¸…ç†ç”¨ï¼ˆåªè¦è©²å–®æœ‰åšé hold ä¸”é‚„æ²’ spendï¼Œå°±é‡‹æ”¾ï¼‰
async function releaseCreditHoldIfNeeded(env, orderId, reason = "auto_abandoned") {
  const oid = String(orderId || "").trim();
  if (!oid) return;

  const T = env.AT_ORDERS || "Orders";
  const rows = await atListByField(env, T, "order_id", oid);
  const rec = rows && rows[0];
  if (!rec) return;

  const f = rec.fields || {};
  const used = Math.round(Number(f.credit_used || 0) || 0);

  // æ²’ç”¨è³¼ç‰©é‡‘ / æ²’åš hold / å·²ç¶“ spend / å·²é‡‹æ”¾ â†’ éƒ½ä¸ç”¨å‹•
  if (!(used > 0)) return;
  if (!f.credit_hold_done) return;
  if (f.credit_spend_done) return;
  if (f.credit_hold_release_done) return;

  // æ‰¾ line_user_idï¼ˆå„ªå…ˆ Orders.line_user_idï¼Œæ²’æœ‰å°±å¾ shipping_info è£œï¼‰
  let uid = String(f.line_user_id || "").trim();
  if (!uid) {
    try {
      const shipInfo = f.shipping_info ? JSON.parse(f.shipping_info) : {};
      const line = shipInfo.line || shipInfo.line_profile || {};
      uid = String(
        line.user_id || line.userId || line.LINE_USER_ID || shipInfo.line_user_id || ""
      ).trim();
    } catch (e) {}
  }

  if (!uid) return;

  // âœ… é‡‹æ”¾ï¼ˆreleaseCreditHold æœƒè² è²¬å¯« credit_hold_release_done ç­‰æ¬„ä½ï¼‰
  await releaseCreditHold(env, {
    lineUserId: uid,
    orderRecId: rec.id,
    amount: used,
    reason: `${reason}:${oid}`
  });
}
async function spendCredit(env, { lineUserId, orderId, amount, reason = "è³¼ç‰©é‡‘æŠ˜æŠµ" }) {
  const n = Math.round(Number(amount || 0) || 0);
  const oid = String(orderId || "").trim();
  const uid = String(lineUserId || "").trim();
  if (!uid || !oid || n <= 0) return;

  const already = await creditLedgerExists(env, oid, "use");
  if (already) return;

  const rs = String(reason || "è³¼ç‰©é‡‘æŠ˜æŠµ").trim();

  await creditLedgerAdd(env, {
    LineUserId: uid,
    Type: "use",
    Amount: -Math.abs(n),
    Reason: rs,
    DisplayName: creditDisplayName("use", oid, rs), // è‹¥ä½ æœ‰åŠ  DisplayName
    OrderId: oid,
  });
}
async function refundCredit(env, { lineUserId, orderId, amount, reason = "è³¼ç‰©é‡‘é€€å›" }) {
  const n = Math.round(Number(amount || 0) || 0);
  const uid = String(lineUserId || "").trim();
  const oid = String(orderId || "").trim();
  if (!uid || !oid || n <= 0) return;

  const rs = String(reason || "è³¼ç‰©é‡‘é€€å›").trim();

  await creditLedgerAdd(env, {
    LineUserId: uid,
    Type: "refund",
    Amount: Math.abs(n),
    Reason: rs,
    DisplayName: creditDisplayName("refund", oid, rs),
    OrderId: oid,
  });
}

// âœ… çµ¦ã€Œç·šä¸Šæ”¯ä»˜æˆåŠŸã€ç”¨ï¼šå¦‚æœé€™å¼µå–®æœ‰ credit_used ä¸”é‚„æ²’çœŸçš„æ‰£ï¼Œå°±åœ¨é€™è£¡æ‰£
async function spendCreditIfNeeded(env, orderRec) {
  const f = orderRec?.fields || {};
  const orderId = String(f.order_id || "").trim();

  // åŸæœ¬åªçœ‹ Orders.line_user_idï¼Œé€™è£¡è£œï¼šå¾ shipping_info æŠ“ line user id
  let lineUserId = String(f.line_user_id || "").trim();
  if (!lineUserId) {
    try {
      const shipInfo = f.shipping_info ? JSON.parse(f.shipping_info) : {};
      const line = shipInfo.line || shipInfo.line_profile || {};
      lineUserId = String(
        line.user_id || line.userId || line.LINE_USER_ID || ""
      ).trim();
    } catch (e) {}
  }

  const creditUsed = Math.round(Number(f.credit_used || 0) || 0);

  const spendDone  = !!f.credit_spend_done;
const refundDone = !!f.credit_refund_done;

if (!orderId || !lineUserId) return;
if (!(creditUsed > 0)) return;

if (refundDone) return;
if (spendDone) return;
if (String(f.pay_status || "") !== "paid_ok") return;

await spendCredit(env, { lineUserId, orderId, amount: creditUsed, reason: "paid_success" });

const T = env.AT_ORDERS || "Orders";
await at(env, "PATCH", T, "", {
  records: [{
    id: orderRec.id,
    fields: {
      credit_spend_done: true,
      credit_spend_at: nowISO(),
      credit_spend_reason: "paid_success"
    }
  }]
});
}
// âœ… å–æ¶ˆ/ä½œå»¢æ™‚ï¼šè‹¥æ›¾ã€Œé æ‰£ã€å°±é‡‹æ”¾ï¼›è‹¥æ›¾ã€Œå¯¦æ‰£ã€å°±é€€æ¬¾ï¼ˆå¯« ledger + æ¨™è¨˜ Ordersï¼‰
// ç”¨æ³•ï¼šawait refundCreditIfNeeded(env, rec, "cancelled")
async function refundCreditIfNeeded(env, rec, reason = "cancelled") {
  try {
    const f = rec?.fields || {};
    const T = env.AT_ORDERS || "Orders";

// æŠ“è¨‚å–®
const orderId = String(f.order_id || f.OrderId || f.orderId || "").trim();

// æŠ“ uidï¼šå…ˆ Orders.line_user_idï¼Œæ²’æœ‰å°±å¾ shipping_info è£œ
let uid = String(f.line_user_id || f.LineUserId || f.lineUserId || "").trim();
if (!uid) {
  try {
    const shipInfo = f.shipping_info ? JSON.parse(f.shipping_info) : {};
    const line = shipInfo.line || shipInfo.line_profile || shipInfo.lineProfile || {};
    uid = String(
      line.user_id || line.userId || line.LINE_USER_ID ||
      shipInfo.line_user_id || shipInfo.lineUserId || ""
    ).trim();
  } catch (e) {}
}
const creditUsed = Math.round(Number(
  f.credit_used ??
  f.creditUse ??
  f.credit_amount ??
  f.creditAmount ??
  0
) || 0);
    if (!uid || !orderId || creditUsed <= 0) return;

    const holdDone   = f.credit_hold_done === true;
    const holdRelDone= f.credit_hold_release_done === true;
    const spendDone  = f.credit_spend_done === true;
    const refundDone = f.credit_refund_done === true;

    // A) åªæœ‰ã€Œé æ‰£ã€ä½†å°šæœªå¯¦æ‰£ï¼šå–æ¶ˆæ™‚æ‡‰è©²é‡‹æ”¾ holdï¼ˆä¸èƒ½åš refundï¼Œå¦å‰‡é¤˜é¡æœƒè¢«åŠ å›å…©æ¬¡ï¼‰
    if (holdDone && !holdRelDone && !spendDone) {
      await releaseCreditHoldIfNeeded(env, orderId, String(reason || "cancelled"));

      //ï¼ˆå¯é¸ï¼‰åŒæ­¥åœ¨ Orders ç•™ç—•è·¡ï¼Œé¿å…é‡è¤‡é‡‹æ”¾
      await at(env, "PATCH", T, "", {
        records: [{
          id: rec.id,
          fields: {
            credit_hold_release_reason: String(reason || "cancelled")
          }
        }]
      });
      return;
    }

    // B) å·²ç¶“ã€Œå¯¦æ‰£ã€ï¼šå–æ¶ˆæ™‚è¦è£œå›ï¼ˆå¯« refund ledgerï¼‰+ æ¨™è¨˜ Orders
    if (spendDone && !refundDone) {
      // âœ… å»é‡ï¼šé¿å…åŒä¸€å–®é‡è¤‡ refundï¼ˆç”¨ ledger å»é‡æœ€ç©©ï¼‰
      const alreadyRefund = await creditLedgerExists(env, orderId, "refund");
      if (!alreadyRefund) {
        await refundCredit(env, {
          lineUserId: uid,
          orderId,
          amount: creditUsed,
          reason: String(reason || "refund")
        });
      }

      await at(env, "PATCH", T, "", {
        records: [{
          id: rec.id,
          fields: {
            credit_refund_done: true,
            credit_refund_at: nowISO(),
            credit_refund_reason: String(reason || "refund")
          }
        }]
      });
    }
  } catch (e) {
    console.log("[refundCreditIfNeeded] error:", e?.message || e);
  }
}
// -------------------- Business helpers --------------------
async function getProductBySKU(env, sku){
  const T = env.AT_PRODUCTS || "Products";
  const rec = await atFindByField(env, T, "SKU", sku) || await atFindByField(env, T, "sku", sku);
  if (!rec) return null;
  const f = rec.fields || {};
  return { sku: f.SKU ?? f.sku ?? sku, name: f.Name ?? f.name ?? "", price: Number(f.Price ?? f.price ?? 0) };
}
async function ensureCart(env, cart_token, streamer_name="", customer_type="live", line_user_id="", customer_name=""){
  const T = env.AT_CARTS || "CartToken";
  let rec = await atFindByField(env, T, "CartToken", cart_token);

  if (!rec){
    const fields = {
      CartToken: cart_token,
      status: "open",
      customer_type,
      created_at: nowISO()
    };

    // âœ… streamer_name æœ‰å€¼æ‰å¯«ï¼ˆé¿å… Airtable å–®é¸/é€£çµæ¬„ä½ INVALID_VALUEï¼‰
    if (Array.isArray(streamer_name)) {
      if (streamer_name.length) fields.streamer_name = streamer_name;
    } else {
      const sn = String(streamer_name || "").trim();
      if (sn) fields.streamer_name = sn;
    }
    // âœ… æœ‰å€¼æ‰å¯«ï¼Œé¿å…ç©ºå€¼è¦†è“‹
    if (line_user_id)  fields.line_user_id  = line_user_id;
    if (customer_name) fields.customer_name = customer_name;

    const r = await at(env, "POST", T, "", { records:[{ fields }]});
    rec = r.records[0];
  } else {
    // âœ… å·²å­˜åœ¨ï¼šåªåœ¨ã€ŒåŸæœ¬æ²’å€¼ã€æ™‚è£œä¸Šï¼Œé¿å…æ´—æ‰
    const f = rec.fields || {};
    const patch = {};
    if (line_user_id && !String(f.line_user_id || "").trim())  patch.line_user_id  = line_user_id;
    if (customer_name && !String(f.customer_name || "").trim()) patch.customer_name = customer_name;

    if (Object.keys(patch).length) {
      await at(env, "PATCH", T, "", { records:[{ id: rec.id, fields: patch }] });
      rec.fields = { ...(rec.fields||{}), ...patch };
    }
  }

  return rec;
}

async function touchCart(env, cart_token) {
  const CT = env.AT_CARTS || "CartToken";
  const rec = await atFindByField(env, CT, "CartToken", cart_token);
  if (!rec) return;

  await at(env, "PATCH", CT, "", {
    records: [{
      id: rec.id,
      fields: { updated_at: nowISO() }
    }]
  });
}
async function cartItems(env, cart_token){
  const list = await listCartItemsAnyToken(env, cart_token);
  return (list || []).map(r => ({ id:r.id, ...(r.fields||{}) }));
}
function creditPolicy(payment_method = "") {
  const pm = String(payment_method || "").trim();

  // âœ… â¶ è¨‚é‡‘åŒ¯æ¬¾ï¼šå®Œå…¨ç¦æ­¢ä½¿ç”¨è³¼ç‰©é‡‘
  // ä½ ç³»çµ±ç¾åœ¨ã€Œæ¨™æº–å‘½åã€æ˜¯ deposit_new_partial / deposit_old_partial / atm_deposit
  //ï¼ˆæˆ‘ä¹Ÿé †æ‰‹ä¿ç•™ä½ å¯èƒ½æ›¾ç”¨éçš„ dep_* å‘½åï¼Œé¿å…èˆŠå–®ï¼‰
  const DISALLOW_SET = new Set([
    "deposit_new_partial",
    "deposit_old_partial",
    "deposit_new",
    "deposit_old",
    "atm_deposit",

    // ç›¸å®¹èˆŠå‘½å
    "dep_new_partial",
    "dep_old_partial",
    "dep_new",
    "dep_old",
  ]);
  if (DISALLOW_SET.has(pm)) return "DISALLOW";

  // âœ… â· ç·šä¸Šæ”¯ä»˜/ä¸­ç§Ÿï¼šæˆåŠŸä»˜æ¬¾æ‰æ‰£
  if (pm.startsWith("paid_") || pm.startsWith("zero_card_") || pm.startsWith("yufu_inst_")) {
    return "ON_PAID";
  }

  // âœ… â¸ COD / é¢äº¤ä»˜ç¾ / åŒ¯æ¬¾å…¨é¡ï¼šé€å‡ºè¨‚å–®å°±æ‰£
  //ï¼ˆåŒæ¨£ç›¸å®¹ä½ å¯èƒ½å­˜åœ¨çš„å…¨é¡å‘½åï¼‰
  const AT_CHECKOUT_SET = new Set([
    "meetup_cash",
    "bank_transfer",
    "atm_full",
    "cod_711",
    "cod_post",

    "deposit_new_full",
    "deposit_old_full",
    "deposit_new_full_711",
    "deposit_new_full_post",
  ]);
  if (AT_CHECKOUT_SET.has(pm) || pm.startsWith("cod_") || pm.startsWith("deposit_new_full") || pm.startsWith("deposit_old_full")) {
    return "AT_CHECKOUT";
  }

  // é è¨­ä¿å®ˆï¼šé¿å…ä¸å°å¿ƒå…ˆæ‰£
  return "ON_PAID";
}
async function upsertCartItem(env, cart_token, sku, name, price, qty){
  const T = env.AT_CART_ITEMS || "CartItems";
  const list = await listCartItemsAnyToken(env, cart_token);
  const existing = list.find(r => ((r.fields?.SKU ?? r.fields?.sku) === sku));
  if (existing){
    const f = existing.fields || {};
    const newQty   = Number(f.Qty ?? f.qty ?? 0) + Number(qty||0);
    const newPrice = Number(price ?? (f.Price ?? f.price ?? 0));
    await at(env, "PATCH", T, "", { records:[{ id: existing.id, fields: { Qty: newQty, Price: newPrice } }] });
  } else {
    await at(env, "POST", T, "", { records:[{ fields:{ CartToken: cart_token, SKU: sku, Name: name, Price: Number(price||0), Qty: Number(qty||0) } }]});
  }

  // âœ… æ–°å¢ï¼šæ›´æ–° CartToken.updated_at
  await touchCart(env, cart_token);
}

async function listCartItemsAnyToken(env, cart_token) {
  const T = env.AT_CART_ITEMS || "CartItems";
  const k = esc(cart_token);
  return await atListAllParams(env, T, {
    filterByFormula: `OR({CartToken}='${k}', {cart_token}='${k}')`
  });
}
async function removeItem(env, cart_token, sku){
  const T = env.AT_CART_ITEMS || "CartItems";
  const list = await listCartItemsAnyToken(env, cart_token);
  const target = list.find(r => ((r.fields?.SKU ?? r.fields?.sku) === sku));
  if (target) {
    const u = new URL(`https://api.airtable.com/v0/${env.AIRTABLE_BASE_ID}/${encodeURIComponent(T)}`);
    u.searchParams.append("records[]", target.id);
    const r = await fetch(u, { method:"DELETE", headers:{ "Authorization":`Bearer ${env.AIRTABLE_TOKEN}` } });
    if (!r.ok) throw new Error("Airtable delete failed");
  }
}
async function clearCart(env, cart_token){
  const T = env.AT_CART_ITEMS || "CartItems";
  const list = await listCartItemsAnyToken(env, cart_token);
  if (!list.length) return;
  const ids = list.map(r=>r.id);
  const batch=10;
  for(let i=0;i<ids.length;i+=batch){
    const u = new URL(`https://api.airtable.com/v0/${env.AIRTABLE_BASE_ID}/${encodeURIComponent(T)}`);
    ids.slice(i,i+batch).forEach(id=>u.searchParams.append("records[]", id));
    const r = await fetch(u, { method:"DELETE", headers:{ "Authorization":`Bearer ${env.AIRTABLE_TOKEN}` } });
    if (!r.ok) throw new Error("Airtable batch delete failed");
  }
}
function sumCart(list){
  let total = 0, items=[];
  for(const r of list){
    const f = r || {};
    const sku=f.SKU??f.sku??""; const name=f.Name??f.name??"";
    const price=Number(f.Price??f.price??0); const qty=Number(f.Qty??f.qty??0);
    const subtotal=price*qty; items.push({sku,name,price,qty,subtotal}); total+=subtotal;
  }
  return { total, items };
}

// ä¾è¨‚å–®å•†å“æ˜ç´°èª¿æ•´åº«å­˜ï¼ˆsign = -1 æ‰£åº«å­˜ï¼›+1 è£œåº«å­˜ï¼‰
// âœ… é˜²æ­¢æ‰£æˆè² æ•¸ï¼šå…ˆæª¢æŸ¥å…¨éƒ¨ SKU éƒ½è¶³å¤ ï¼Œå†é–‹å§‹å¯«å›
async function adjustStockByItems(env, items, sign) {
  const P = env.AT_PRODUCTS || "Products";
  if (!Array.isArray(items) || !items.length) return;

  // 1) å½™ç¸½åŒ SKU çš„ qty
  const needMap = new Map();
  for (const it of items) {
    const sku = String(it?.sku || "").trim();
    const qty = Number(it?.qty || 0) || 0;
    if (!sku || qty <= 0) continue;
    needMap.set(sku, (needMap.get(sku) || 0) + qty);
  }
  if (!needMap.size) return;

  // 2) å…ˆæŸ¥ä¸€æ¬¡ï¼ŒæŠŠ rec/cache èµ·ä¾†ï¼ˆé¿å…å¾Œé¢å†æŸ¥ä¸€æ¬¡ï¼‰
  const recMap = new Map(); // sku -> { rec, current, next, qty }
  for (const [sku, qty] of needMap.entries()) {
    const rec =
  (await atFindByField(env, P, "SKU", sku)) ||
  (await atFindByField(env, P, "sku", sku));
    if (!rec) {
      throw Object.assign(new Error(`product_not_found: ${sku}`), { status: 400 });
    }
    const f = rec.fields || {};
    const current = Number(f.StockQty ?? 0) || 0;
    const next = current + sign * qty;

    // åªæœ‰æ‰£åº«å­˜æ™‚æ‰éœ€è¦æ“‹è² æ•¸ï¼ˆè£œåº«å­˜ä¸éœ€è¦ï¼‰
    if (sign < 0 && next < 0) {
      throw Object.assign(
        new Error(`insufficient_stock sku=${sku} current=${current} need=${qty}`),
        { status: 409 }
      );
    }

    recMap.set(sku, { rec, current, next, qty });
  }

  // 3) å…¨éƒ¨ OK æ‰é–‹å§‹å¯«å›
  for (const [sku, info] of recMap.entries()) {
    await at(env, "PATCH", P, "", {
      records: [{ id: info.rec.id, fields: { StockQty: info.next } }]
    });
  }
}
// æœƒå“¡ä¸­å¿ƒ LIFF IDï¼ˆæ²’æœ‰è¨­ç’°å¢ƒè®Šæ•¸æ™‚å°±ç”¨é€™å€‹é è¨­å€¼ï¼‰
const LIFF_MEMBER_ID_DEFAULT = "2008430261-EGZPg3Qp";
// -------------------- è‡ªå‹•ï¼šä»Šæ—¥å°¾æ¬¾æé†’ï¼ˆä¿ç•™åˆ°æœŸï¼Œè‡ªå‹•ç™¼ LINEï¼‰ --------------------
function taipeiTodayStr() {
  // Cloudflare æ˜¯è·‘åœ¨ UTCï¼Œé€™è£¡æ‰‹å‹•æ›æˆå°åŒ—æ™‚é–“ï¼ˆUTC+8ï¼‰å†å–æ—¥æœŸ
  const now = new Date();
  const utc = now.getTime() + now.getTimezoneOffset() * 60000;
  const tw  = new Date(utc + 8 * 60 * 60000);
  const yyyy = tw.getFullYear();
  const mm   = String(tw.getMonth() + 1).padStart(2, "0");
  const dd   = String(tw.getDate()).padStart(2, "0");
  return `${yyyy}-${mm}-${dd}`;
}

async function runDepositTailReminder(env) {
  const T = env.AT_ORDERS || "Orders";
  const records = await atListAll(env, T);
  const todayStr = taipeiTodayStr();

  let candidate = 0;
  let sent = 0;

  for (const rec of records) {
    const f = rec.fields || {};
    const pm = String(f.payment_method || "");

    // åªè™•ç†ã€Œè¨‚é‡‘ / åŒ¯æ¬¾ã€é¡çš„è¨‚å–®
    const isDepositPm =
      pm.startsWith("deposit") || pm.startsWith("atm");
    if (!isDepositPm) continue;

    const hasDeposit  = Number(f.deposit_amount || 0) > 0;
    const depReceived = !!f.deposit_received;   // å·²æ”¶åˆ°è¨‚é‡‘
    const noticeSent  = !!f.pay_notice_sent;    // å·²ç™¼ä¿ç•™é€šçŸ¥

    if (!hasDeposit || !depReceived || !noticeSent) continue;

    const payStatus = String(f.pay_status || "");
    const status    = String(f.status || "");

    // å·²å®Œæˆ / å·²å–æ¶ˆ / å¤±æ•—çš„å°±ä¸ç”¨æé†’
    if (
      payStatus === "paid_ok" ||
      payStatus === "cancelled" ||
      payStatus === "failed" ||
      status === "shipped" ||
      status === "cancelled"
    ) {
      continue;
    }

    // ä¿ç•™æ—¥æœŸï¼ˆhold_until å„ªå…ˆï¼Œæ²’æœ‰å°±ç”¨ deposit_expire_atï¼‰
    const holdDateRaw =
      (f.hold_until || f.deposit_expire_at || "").slice(0, 10);
    if (!holdDateRaw) continue;

    // åªåœ¨ã€Œä»Šå¤©ä¿ç•™åˆ°æœŸã€çš„é‚£ä¸€å¤©æé†’
    if (holdDateRaw !== todayStr) continue;

    // â˜… åŠ ä¸Šè³¼ç‰©é‡‘ï¼šç”¨ã€Œå¯¦éš›æ‡‰æ”¶ net_totalã€å»ç®—å°¾æ¬¾
    const grossTotal   = Number(f.total_amount || f.total || 0) || 0;
    const creditUsed   = Number(f.credit_used || 0) || 0;
    const netTotal     = grossTotal - creditUsed;     // æ‰£æ‰è³¼ç‰©é‡‘å¾Œçš„æ‡‰æ”¶
    const deposit      = Number(f.deposit_amount || 0) || 0;
    const tailAmount   = netTotal - deposit;

    if (!(tailAmount > 0)) continue; // æ²’æœ‰å°¾æ¬¾å°±ä¸ç”¨æé†’

    candidate++;

    // ---- æ‰¾ LINE userIdï¼ˆæ²¿ç”¨ /admin/order/confirm-pay çš„é‚è¼¯ï¼‰ ----
    let shipInfo = {};
    try {
      shipInfo = JSON.parse(f.shipping_info || "{}");
    } catch (e) {
      shipInfo = {};
    }

    const ship = shipInfo.ship || {};
    let line   = shipInfo.line || shipInfo.line_profile || {};

    let lineUserId =
      line.user_id ||
      line.userId ||
      line.LINE_USER_ID ||
      f.line_user_id ||
      "";

    let displayName =
      line.display_name ||
      line.displayName ||
      line.name ||
      f.line_name ||
      "";

    // æ²’å­˜åˆ° Ordersï¼Œå°±ç”¨é›»è©± / Email å» LineMembers æ‰¾
    if (!lineUserId) {
      const phone = ship.phone || "";
      const email = ship.email || "";
      if (phone || email) {
        const TM = env.AT_LINE_MEMBERS || "LineMembers";
        const parts = [];
        if (phone) parts.push(`{Phone}='${esc(phone)}'`);
        if (email) parts.push(`{Email}='${esc(email)}'`);
        if (parts.length) {
          const formula =
            parts.length === 1 ? parts[0] : `OR(${parts.join(",")})`;
          try {
            const res = await at(env, "GET", TM, "", null, {
              filterByFormula: formula,
              maxRecords: "1",
            });
            const mrec = res.records && res.records[0];
            if (mrec) {
              const mf = mrec.fields || {};
              lineUserId =
                mf.LineUserId ||
                mf.LINE_USER_ID ||
                mf.line_user_id ||
                "";
              displayName =
                displayName ||
                mf.DisplayName ||
                mf.display_name ||
                mf.Name ||
                "";
            }
          } catch (e) {
            console.log("tail_remind LineMembers search error", e);
          }
        }
      }
    }

    if (!lineUserId) {
      console.log(
        "tail_remind skip (no lineUserId)",
        f.order_id || rec.id
      );
      continue;
    }

    // ---- çµ„å°¾æ¬¾çµå¸³é€£çµ ----
    const front = (env.FRONT_ORIGIN || "https://murain.tw").replace(
      /\/$/,
      ""
    );
    let tailPath = env.TAIL_CHECKOUT_PATH || "/tail-checkout.html";
    if (!tailPath.startsWith("/")) tailPath = "/" + tailPath;

    const orderId = String(f.order_id || "").trim();
if (!orderId) {
  console.log("tail_remind skip: missing order_id", rec.id);
  continue;
}

const tailUrl = buildTailCheckoutUrl(env, orderId);

    // ---- çµ„ LINE æ–‡å­— ----
    const namePrefix = displayName ? `${displayName} æ‚¨å¥½ï¼Œ` : "";
    const holdText = holdDateRaw.replace(/-/g, "/"); // 2025/12/05 é€™ç¨®
const tailText = "NT$ " + tailAmount.toLocaleString("zh-TW");

const bubble = buildTailRemindFlexBubble({
  customerName: displayName || "",
  orderId,
  holdUntilText: holdText,
  tailAmountText: tailText,
  tailUrl
});

try {
  await linePushFlex(env, lineUserId, "å®šé‡‘å°¾æ¬¾æé†’", bubble);
      sent++;
      console.log("tail_remind sent", orderId, lineUserId);
    } catch (e) {
      console.log("tail_remind send error", orderId, e);
    }
  }

  console.log(
    "[tail_remind]",
    todayStr,
    "å€™é¸ç­†æ•¸",
    candidate,
    "æˆåŠŸç™¼é€",
    sent
  );
}

// â˜… æ–°å¢ï¼šæ¸…ç†ã€Œç·šä¸Šä»˜æ¬¾è·³è½‰ä¸­é€”é—œæ‰ã€çš„æ£„å–®ï¼ˆè£œå›åº«å­˜ / é‡‹æ”¾è³¼ç‰©é‡‘ hold / è§£é–è³¼ç‰©è»Šï¼‰
// é è¨­ï¼šè¶…é 30 åˆ†é˜ä»æœªä»˜æ¬¾ â†’ è‡ªå‹•ä½œå»¢
async function runAbandonedOnlineCleanup(env, minutes = 30) {
  const T  = env.AT_ORDERS || "Orders";
  const CT = env.AT_CARTS  || "CartToken";

  const cutoffMs = Date.now() - Math.max(1, Number(minutes) || 30) * 60 * 1000;

  // åªæ’ˆã€Œå¯èƒ½éœ€è¦è·³è½‰ä»˜æ¬¾ã€ä¸”ä» pending/submitted çš„å–®
  // ï¼ˆæ’é™¤ cod_/atm_/deposit_/meetup_cashï¼›ä¹Ÿæ’é™¤ paid_ok / shipped / completedï¼‰
  const formula = `AND(
    OR(
      LEFT(LOWER({payment_method}&""),5)="paid_",
      LOWER({payment_method}&"")="aftee_direct",
      LOWER({payment_method}&"")="paid_aftee_direct"
    ),
    OR(
      LOWER({pay_status}&"")="pending",
      LOWER({pay_status}&"")="submitted",
      {pay_status}=""
    ),
    NOT(OR(
      LOWER({pay_status}&"")="paid_ok",
      LOWER({pay_status}&"")="deposit_ok",
      LOWER({status}&"")="shipped",
      LOWER({status}&"")="completed"
    ))
  )`;

  let cleaned = 0;
  let offset = "";

  while (true) {
    const res = await at(env, "GET", T, "", null, {
      filterByFormula: formula,
      pageSize: "100",
      ...(offset ? { offset } : {})
    });

    const records = (res && res.records) || [];
    for (const r of records) {
      const f = r?.fields || {};
      const oid = String(f.order_id || "").trim();
      if (!oid) continue;

      // ç”¨ Airtable record createdTime æœ€ç©©ï¼ˆä¸ä¾è³´ä½  created_at æ¬„ä½å‹æ…‹ï¼‰
      const createdMs = Date.parse(r.createdTime || "") || Date.parse(String(f.created_at || "")) || 0;
      if (!createdMs || createdMs > cutoffMs) continue;

      const ps = String(f.pay_status || "").toLowerCase();
      const st = String(f.status || "").toLowerCase();
      if (ps === "paid_ok" || st === "shipped" || st === "completed") continue; // ä¿éšª

      const isTail =
        oid.startsWith("TL") ||
        String(f.order_type || "").toLowerCase() === "tail" ||
        !!f.is_tail;

      // â‘  é‡‹æ”¾è³¼ç‰©é‡‘ holdï¼ˆå°¾æ¬¾ TL ç·šä¸Šä»˜æ¬¾ pending æ™‚ä½ æœ‰åš holdï¼›ä¸€èˆ¬å–®è‹¥æ²’ hold ä¹Ÿä¸æœƒå‹•ï¼‰
      try {
        await releaseCreditHoldIfNeeded(env, oid, "auto_abandoned");
      } catch (e) {
        console.log("abandoned cleanup: releaseCreditHoldIfNeeded error", oid, e?.message || e);
      }

      // â‘¡ éå°¾æ¬¾ï¼šè£œå›åº«å­˜ + è§£é– CartTokenï¼ˆè®“å®¢äººå¯ä»¥é‡æ–°çµå–®ï¼‰
      if (!isTail) {
        // è£œå›åº«å­˜ï¼ˆåªè¦ items_json èƒ½ parse æˆé™£åˆ—å°±è£œï¼‰
        try {
          const items = (typeof safeJsonParse === "function")
            ? safeJsonParse(f.items_json, [])
            : (() => { try { return JSON.parse(f.items_json || "[]"); } catch { return []; } })();

          if (Array.isArray(items) && items.length) {
            await adjustStockByItems(env, items, +1);
          }
        } catch (e) {
          console.log("abandoned cleanup: restock error", oid, e?.message || e);
        }

        // è§£é–è³¼ç‰©è»Šï¼ˆæ¸…æ‰ checked_out / ç¶å–®ï¼Œé¿å…å¡æ­»ï¼‰
        try {
          const cartToken = String(f.cart_token || "").trim();
          if (cartToken) {
            const cartRec = await atFindByField(env, CT, "CartToken", cartToken);
            if (cartRec?.id) {
              await at(env, "PATCH", CT, "", {
                records: [{
                  id: cartRec.id,
                  fields: {
                    checked_out: false,
                    checked_out_order_id: "",
                    status: "open",
                    closed_at: "",
                    checkout_lock_id: "",
                    checkout_lock_at: ""
                  }
                }]
              });
            }
          }
        } catch (e) {
          console.log("abandoned cleanup: unlock cart error", oid, e?.message || e);
        }
      }

      // â‘¢ ä½œå»¢è¨‚å–®ï¼ˆè®Šæˆ cancelled/failedï¼Œä¹‹å¾Œä¸æœƒå†è¢«ç•¶æˆ activeï¼‰
      try {
        const note = (
          (String(f.internal_note || "") + " ").trim() +
          `[AUTO_VOID_ABANDONED ${nowISO()}]`
        ).trim();

        await at(env, "PATCH", T, "", {
          records: [{
            id: r.id,
            fields: {
              status: "cancelled",
              pay_status: "failed",
              pay_notify_status: `ABANDONED_AUTO_VOID:${Math.max(1, Number(minutes) || 30)}m`,
              internal_note: note
            }
          }]
        });

        cleaned++;
      } catch (e) {
        console.log("abandoned cleanup: patch order failed", oid, e?.message || e);
      }
    }

    offset = res?.offset || "";
    if (!offset) break;
  }

  console.log("runAbandonedOnlineCleanup done", { minutes, cleaned });
}

function firstNonEmpty(...vals) {
  for (const v of vals) {
    const s = String(v ?? "").trim();
    if (s) return s;
  }
  return "";
}

function shipTypeLabelFromSI(si = {}, fallback = "") {
  const ship = si.ship || {};
  const t = String(ship.type || fallback || "").toLowerCase();
  if (t === "711") return "7-11 è¶…å•†å–è²¨";
  if (t === "post") return "éƒµå¯„";
  if (t === "meetup") return "é¢äº¤";
  return fallback || "";
}

function pickZipAddrFromSI(si = {}) {
  const ship = si.ship || {};
  const store = ship.store || {};
  const post  = ship.post  || {};

  const type = String(ship.type || "").toLowerCase();

  if (type === "post") {
    return {
      zip:  String(post.zip || "").trim(),
      addr: String(post.addr || "").trim(),
      storeName: ""
    };
  }

  if (type === "711") {
    // 711 é€šå¸¸æ²’æœ‰ zipï¼›åœ°å€å¯ç”¨é–€å¸‚åœ°å€ï¼ˆå¦‚æœä½ æœ‰å­˜ï¼‰
    return {
      zip: "",
      addr: String(store.addr || "").trim(),      // æ²’æœ‰å°±ç©ºç™½ï¼Œä¸è¦äº‚å¡
      storeName: String(store.name || "").trim()
    };
  }

  if (type === "meetup") {
    const place = String(ship.meetup_place || ship.meet_place || "").trim();
    const time  = String(ship.meetup_time  || ship.meet_time  || "").trim();
    return {
      zip: "",
      addr: [place, time].filter(Boolean).join(" "),
      storeName: ""
    };
  }

  return { zip: "", addr: "", storeName: "" };
}

function pickLineNameFromSI(si = {}) {
  const lp =
    si.line_profile ||
    si.lineProfile ||
    si.line ||
    {};
  return firstNonEmpty(lp.displayName, lp.display_name, lp.name);
}

// ===== helpers for tail->parent sync =====
function safeJsonParse(s, fallback = {}) {
  try {
    if (!s) return fallback;
    if (typeof s === "object") return s; // already parsed
    return JSON.parse(String(s));
  } catch (e) {
    return fallback;
  }
}

function safeJsonStringify(obj, fallback = "{}") {
  try {
    return JSON.stringify(obj ?? {});
  } catch (e) {
    return fallback;
  }
}

// ç‰©æµç‹€æ…‹åˆ¤æ–·ï¼ˆä½ æœ‰å…¶ä»–æ›´å®Œæ•´çš„ä¹Ÿå¯ä»¥æ›æ‰ï¼‰
function shippedLike(v) {
  const s = String(v || "").toLowerCase();
  return (
    s === "shipped" ||
    s === "arrived" ||
    s === "picked_up" ||
    s === "returned"
  );
}

// å¾ã€Œå°¾æ¬¾å–® Airtable fieldsã€æŠ“è²¨å–®è™Ÿï¼šä½ å¯ä¾ä½ å¯¦éš›æ¬„ä½å†åŠ 
function extractTrackingNoFromFields(fields) {
  const f = fields || {};
  // 1) fields ç›´æ¥æ¬„ä½
  let t = String(
    f.tracking_no ||
    f.ship_tracking ||
    f.trackingNo ||
    f.tracking_number ||
    f.waybill ||
    ""
  ).trim();
  if (t) return t;

  // 2) shipping_info å…§
  const si = safeJsonParse(f.shipping_info, {});
  const ship = si.ship || {};
  t = String(
    ship.tracking_no ||
    ship.ship_no ||
    si.tracking_no ||
    si.ship_no ||
    ""
  ).trim();
  return t;
}

function requireAdminKey(req, env) {
  const u = new URL(req.url);
  const k = (u.searchParams.get("admin_key") || "").trim();
  return k && String(k) === String(env.ADMIN_KEY || "88");
}
// âœ… å…±ç”¨ï¼šå°¾æ¬¾ TL ä»˜æ¸…å¾Œï¼ŒæŠŠ parent OD æ¨™æˆå·²ä»˜æ¸…ï¼ˆpaid_ok / paidï¼‰
// - ä¸æ–°å¢ Airtable æ¬„ä½ï¼šç”¨ internal_note æ‰“æ¨™é¿å… 422
// - å¯é‡å…¥ï¼šå·² paid_ok å°±ä¸é‡åš
async function markParentPaidByTail(env, tailRecOrFields, payChannelHint = "") {
  const T = env.AT_ORDERS || "Orders";
  const f = (tailRecOrFields && tailRecOrFields.fields) ? tailRecOrFields.fields : (tailRecOrFields || {});

  const isTail = !!f.is_tail || String(f.order_type || "") === "tail";
  if (!isTail) return;

  const parentId = String(f.parent_order_id || "").trim();
  const tailId   = String(f.order_id || "").trim();
  if (!parentId) return;

  // æ‰¾ parent OD
  const parentRec = await atFindByField(env, T, "order_id", parentId);
  if (!parentRec) return;

  const pf = parentRec.fields || {};
  const curPs = String(pf.pay_status || "").toLowerCase();
  const curSt = String(pf.status || "").toLowerCase();

  // å·²ç¶“çµæ¸…å°±ä¸åš
  if (curPs === "paid_ok" || curSt === "paid" || curSt === "shipped" || curSt === "completed") return;

  // internal_note æ‰“æ¨™å»é‡
  const TAG = `[TAIL_PAID:${tailId || "TL"}]`;
  const note0 = String(pf.internal_note || "");
  if (note0.includes(TAG)) return;

  const now = nowISO();
  const note1 = (note0 ? note0 + " " : "") + TAG + " " + now;

  const patch = {
    status: "paid",
    pay_status: "paid_ok",
    internal_note: note1,
  };

  // âœ… è‹¥ä½  Orders æœ‰ pay_channel æ¬„ä½ï¼ˆä½ ç›®å‰çœ‹èµ·ä¾†æœ‰ï¼‰ï¼Œå°±è£œä¸Šï¼ˆæ²’æœ‰ä¹Ÿä¸å½±éŸ¿ä¸»æµç¨‹ï¼‰
  const ch = String(payChannelHint || f.pay_channel || "").trim();
  if (ch) patch.pay_channel = ch;

  await at(env, "PATCH", T, "", { records: [{ id: parentRec.id, fields: patch }] });
}
function escFormula(s){
  // Airtable formula å­—ä¸²å…§ï¼Œå–®å¼•è™Ÿè¦ç”¨å…©å€‹å–®å¼•è™Ÿè½‰ç¾©
  return String(s ?? "").replace(/'/g, "''");
}

async function syncTailPaidToParent(env, tailRec, payChannelHint = "") {
  const T = env.AT_ORDERS || "Orders";
  const tf = tailRec?.fields || {};

  const tailId = String(tf.order_id || "").trim();
  const isTail =
    !!tf.is_tail ||
    String(tf.order_type || "").toLowerCase() === "tail" ||
    tailId.toUpperCase().startsWith("TL");

  if (!isTail) return;

  const parentId = String(tf.parent_order_id || "").trim();
  if (!parentId || !tailId) return;

  const parentRec = await atFindByField(env, T, "order_id", parentId);
  if (!parentRec) return;

  const pf = parentRec.fields || {};
  const now = nowISO();

  // ---- å»é‡ï¼ˆä»˜æ¬¾åŒæ­¥ç”¨ï¼‰----
  const TAG_PAY = `[TAIL_PAID:${tailId}]`;
  const note0 = String(pf.internal_note || "");
  const alreadyPaySynced = note0.includes(TAG_PAY);

  // ---- TL shipping_info å¿«ç…§ï¼ˆå¯é¸ï¼‰----
  const shipInfo = safeJsonParse(tf.shipping_info, {}) || {};

  // ---- TL ç™¼ç¥¨æ¬„ä½ï¼ˆä½ ç¾æœ‰é–‹ç¥¨æœƒå¯«åœ¨ TL çš„é€™äº›æ¬„ä½ï¼‰----
  const tlInvoiceNo      = String(tf.invoice_no || "").trim();
  const tlInvoiceDate    = tf.invoice_date || "";
  const tlInvoiceRandom  = String(tf.invoice_random || "").trim();
  const tlInvoiceCode    = String(tf.invoice_rtn_code || "").trim();
  const tlInvoiceMsg     = String(tf.invoice_rtn_msg || "").trim();
  const tlInvoiceIssued  = !!tf.invoice_issued;

  // ---- ä½ è¦çš„ã€Œä½µå…¥ ODã€æ ¸å¿ƒæ¬„ä½ ----
  const snapshot = {
    tail_order_id: tailId,
    parent_order_id: parentId,
    tail_payment_method: String(tf.payment_method || ""),
    tail_total_amount: Number(tf.total_amount || 0) || 0,
    tail_credit_used: Number(tf.credit_used || 0) || 0,
    tail_net_amount: Number(tf.net_amount || 0) || 0,
    tail_pay_channel: String(payChannelHint || tf.pay_channel || ""),
    tail_paid_at: now,
    tail_invoice_no: tlInvoiceNo,
    tail_invoice_date: tlInvoiceDate,
    tail_invoice_random: tlInvoiceRandom,
    tail_invoice_rtn_code: tlInvoiceCode,
    tail_invoice_rtn_msg: tlInvoiceMsg,
    tail_invoice_issued: tlInvoiceIssued,
    shipping_info: shipInfo
  };

  // âœ… åª patch ä½ æ–°å¢çš„ tail_* æ¬„ä½ + ä»˜æ¬¾ç‹€æ…‹ï¼ˆä¸ç¢°å‡ºè²¨æ¬„ä½/æ”¶ä»¶æ¬„ä½/å•†å“æ¬„ä½ï¼‰
  const patch = {
    // ä»˜æ¬¾é¢ï¼šTL ä»˜æ¸… â†’ OD è¦–ç‚ºå·²ä»˜æ¸…ï¼ˆä½†å‡ºè²¨ä»ç”±ä½ å¾Œå°æŒ‰éˆ•æ§åˆ¶ï¼‰
    status: "paid",
    pay_status: "paid_ok",

    // å°¾æ¬¾ä½µå…¥ä¸»å–®æ¬„ä½
    tail_order_id: tailId,
    tail_payment_method: String(tf.payment_method || ""),
    tail_total_amount: Number(tf.total_amount || 0) || 0,
    tail_credit_used: Number(tf.credit_used || 0) || 0,
    tail_net_amount: Number(tf.net_amount || 0) || 0,
    tail_pay_channel: String(payChannelHint || tf.pay_channel || ""),
    tail_paid_at: now,

    // å°¾æ¬¾ç™¼ç¥¨ä½µå…¥ä¸»å–®æ¬„ä½
    tail_invoice_no: tlInvoiceNo || "",
    tail_invoice_date: tlInvoiceDate || "",
    tail_invoice_random: tlInvoiceRandom || "",
    tail_invoice_rtn_code: tlInvoiceCode || "",
    tail_invoice_rtn_msg: tlInvoiceMsg || "",
    tail_invoice_issued: tlInvoiceIssued,

    // å¯é¸ï¼šå®Œæ•´å¿«ç…§ï¼ˆæ–¹ä¾¿ä½ æœªä¾†æŸ¥å¸³ï¼‰
    tail_paid_snapshot: JSON.stringify(snapshot),

    // å»é‡æ¨™è¨˜ï¼ˆä»˜æ¬¾åŒæ­¥ï¼‰
    internal_note: alreadyPaySynced ? note0 : ((note0 ? note0 + " " : "") + TAG_PAY + " " + now)
  };

  // è‹¥å·²åŒæ­¥éä»˜æ¬¾ï¼Œä½†ä½ ä¹‹å¾Œè£œé–‹ç¥¨ã€å¸Œæœ›èƒ½è£œå› OD çš„ tail_invoice_*ï¼š
  // åªè¦ OD é‚„æ²’æœ‰ tail_invoice_noã€ä½† TL å·²ç¶“æœ‰ invoice_noï¼Œå°±å…è¨±å† patch ä¸€æ¬¡ç™¼ç¥¨æ¬„ä½
  if (alreadyPaySynced) {
    const odHasInv = !!String(pf.tail_invoice_no || "").trim();
    const tlHasInv = !!tlInvoiceNo;
    if (!odHasInv && tlHasInv) {
      patch.internal_note = (note0 ? note0 + " " : "") + `[TAIL_INV:${tailId}] ` + now;
      // å…¶ä»–æ¬„ä½ç…§æ¨£ patchï¼ˆä½†å…¶å¯¦é‡é»æ˜¯ç™¼ç¥¨é‚£å¹¾å€‹ï¼‰
    } else {
      return;
    }
  }

  await at(env, "PATCH", T, "", { records: [{ id: parentRec.id, fields: patch }] });
}


async function atListAllParams(env, table, paramsObj) {
  let out = [];
  let offset = null;
  do {
    const params = { ...(paramsObj || {}), pageSize: "100" };
    if (offset) params.offset = offset;
    const r = await at(env, "GET", table, "", null, params);
    out = out.concat(r.records || []);
    offset = r.offset;
  } while (offset);
  return out;
}
async function deleteRecordsBatch(env, table, ids) {
  for (let i=0; i<ids.length; i+=10) {
    const chunk = ids.slice(i, i+10);
    const qs = chunk.map(id => "records[]=" + encodeURIComponent(id)).join("&");
    await at(env, "DELETE", table, "?" + qs);
  }
}
// âœ… å…±ç”¨ï¼šæŠŠè¨‚å–®ä½œå»¢ï¼ˆè£œå›åº«å­˜ + é€€è³¼ç‰©é‡‘ + ç‹€æ…‹çµ±ä¸€ cancelledï¼‰
// ç”¨é€”ï¼šè£•å¯Œå¯©æ ¸å¤±æ•— / ä»»ä½•ç·šä¸Šä»˜æ¬¾å¤±æ•—æƒ³è¦é¡¯ç¤ºæˆã€Œå¤±æ•—ä½œå»¢/è£œå›åº«å­˜ã€éƒ½å¯ç”¨
async function cancelOrderAsFailed(env, rec, failCode = "failed", failMsg = "") {
  if (!rec || !rec.id) return;
  const T = env.AT_ORDERS || "Orders";
  const f = rec.fields || {};
const orderId = String(f.order_id || "").trim();

// âœ… å»é‡ï¼šç”¨ internal_note æ‰“æ¨™ï¼Œé¿å…ä»»ä½•åŸå› é€ æˆçš„é‡è¤‡è£œåº«å­˜/é€€æ¬¾
const RESTOCK_TAG = "[AUTO_CANCEL_ORDER_AS_FAILED]";
const note0 = String(f.internal_note || "");
const alreadyHandled = note0.includes(RESTOCK_TAG);

// å·²ç¶“ cancelled æˆ–å·²è™•ç†éï¼Œå°±ä¸è¦é‡åš
if (String(f.status || "").toLowerCase() === "cancelled" || alreadyHandled) return;

  // 1) å–å•†å“æ˜ç´°ï¼ˆitems_json æ²’æœ‰å°±ç”¨ cart_token å› CartItems åæ¨ï¼‰
  let items = [];
  try {
    if (f.items_json) items = JSON.parse(f.items_json);
  } catch (e) {
    items = [];
  }

  if (!Array.isArray(items) || !items.length) {
    const cartToken = String(f.cart_token || "").trim();
    if (cartToken) {
      try {
        const ci = await listCartItemsAnyToken(env, cartToken);
        items = (ci || [])
          .map(r => {
            const ff = r.fields || {};
            return {
              sku: String(ff.SKU ?? ff.sku ?? "").trim(),
              qty: Number(ff.Qty ?? ff.qty ?? 0) || 0
            };
          })
          .filter(x => x.sku && x.qty > 0);
      } catch (e) {
        items = [];
      }
    }
  }

  // âœ… å…ˆæ‰“æ¨™ï¼ˆåªæ”¹ internal_noteï¼Œæ¯”è¼ƒä¸æœƒå› ç‚º select æ¬„ä½å¤±æ•—è€Œæ•´åŒ…å¤±æ•—ï¼‰
// é€™æ¨£å°±ç®—å¾Œé¢ status/pay_status å¯«å…¥å¤±æ•—ï¼Œä¸‹ä¸€æ¬¡ä¹Ÿä¸æœƒå†è£œä¸€æ¬¡åº«å­˜
try {
  const stamp = new Date().toISOString();
  const note = failMsg ? `[${failCode}] ${failMsg}` : `[${failCode}]`;
  const tagLine = `${RESTOCK_TAG} ${stamp} ${note}`.trim();
  const oldNote = String(f.internal_note || "").trim();
  const newNote = oldNote ? (oldNote + "\n" + tagLine) : tagLine;

  await at(env, "PATCH", T, "", {
    records: [{ id: rec.id, fields: { internal_note: newNote } }]
  });

  // è®“å¾Œé¢ PATCH status æ™‚ä¹Ÿç”¨åŒä¸€ä»½ newNote
  rec.fields = { ...(rec.fields || {}), internal_note: newNote };
} catch (e) {
  console.log("cancelOrderAsFailed patch internal_note tag error", orderId, e);
}

  // 2) è£œå›åº«å­˜
  try {
    await adjustStockByItems(env, items || [], +1);
  } catch (e) {
    console.log("cancelOrderAsFailed adjustStock(+1) error", orderId, e);
  }

  // 3) é€€å›è³¼ç‰©é‡‘ï¼ˆä½ å·²ç¶“æœ‰ refundCreditIfNeededï¼‰
  try {
    await refundCreditIfNeeded(env, rec, failCode);
  } catch (e) {
    console.log("cancelOrderAsFailed refundCredit error", orderId, e);
  }

  // 4) ç‹€æ…‹çµ±ä¸€ï¼šcancelled + failed
try {
  await at(env, "PATCH", T, "", {
    records: [{
      id: rec.id,
      fields: {
        status: "cancelled",
        pay_status: "failed"
      }
    }]
  });
} catch (e) {
  console.log("cancelOrderAsFailed patch status/pay_status error", orderId, e);
}
}

// ======================= IMG_/AI_ helpers (safe prefix) =======================

// Cloudflare Images API base
function IMG_cfBase(env) {
  const accountId = String(env.CF_ACCOUNT_ID || "").trim();
  if (!accountId) throw new Error("CF_ACCOUNT_ID_MISSING");
  return `https://api.cloudflare.com/client/v4/accounts/${accountId}`;
}
function IMG_cfAuth(env) {
  const token = String(env.CF_IMAGES_TOKEN || "").trim();
  if (!token) throw new Error("CF_IMAGES_TOKEN_MISSING");
  return { "Authorization": `Bearer ${token}` };
}

// Compute delivery URL (stable)
function IMG_deliveryUrl(env, imageId, variant) {
  const hash = String(env.CF_IMAGES_ACCOUNT_HASH || "").trim(); // âœ… æ”¹é€™è£¡
  const v = String(variant || env.CF_IMAGES_VARIANT || "public").trim() || "public";
  if (!hash || !imageId) return "";
  return `https://imagedelivery.net/${hash}/${encodeURIComponent(imageId)}/${encodeURIComponent(v)}`;
}

// Create Direct Upload URL (Cloudflare will return {id, uploadURL})
async function IMG_createDirectUpload(env, { sku = "", expirySeconds = 1800, requireSignedURLs = false } = {}) {
  const accountId = String(env.CF_ACCOUNT_ID || "").trim();
  if (!accountId) throw new Error("CF_ACCOUNT_ID_MISSING");

  // âœ… æ­£ç¢º endpoint
  const url = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v2/direct_upload`;

  // âœ… Cloudflare é€™æ”¯ API éœ€è¦ multipart/form-dataï¼ˆä¸èƒ½ JSONï¼‰
  const form = new FormData();
  form.append("requireSignedURLs", requireSignedURLs ? "true" : "false");

  const metaSku = String(sku || "").trim();
  if (metaSku) form.append("metadata", JSON.stringify({ sku: metaSku }));

  // expiryï¼šæ–‡ä»¶ç¤ºä¾‹ä¸»è¦ç”¨ formï¼›é€™å€‹æ¬„ä½è‹¥ä½ å¸³è™Ÿä¸åƒä¹Ÿæ²’é—œä¿‚ï¼ˆä¸å½±éŸ¿æ ¸å¿ƒï¼‰
  if (expirySeconds && Number(expirySeconds) > 0) {
    const exp = new Date(Date.now() + Number(expirySeconds) * 1000).toISOString();
    form.append("expiry", exp);
  }

  const r = await fetch(url, {
    method: "POST",
    headers: {
      ...IMG_cfAuth(env),
      "Accept": "application/json"
      // âš ï¸ ä¸è¦æ‰‹å‹•è¨­ Content-Typeï¼Œè®“ fetch è‡ªå·±å¸¶ boundary
    },
    body: form
  });

  const data = await r.json().catch(() => null);
  if (!r.ok || !data?.success) {
    throw new Error(`CF_DIRECT_UPLOAD_FAILED ${r.status} ${JSON.stringify(data || {})}`);
  }
  return data.result; // { id, uploadURL }
}


// Minimal JSON extraction (é˜²æ¨¡å‹å¤šè¬›è©±)
function AI_extractJson(text) {
  const s = String(text || "").trim();
  // try direct parse first
  try { return JSON.parse(s); } catch (e) {}

  // try find first {...}
  const m = s.match(/\{[\s\S]*\}/);
  if (m) {
    try { return JSON.parse(m[0]); } catch (e) {}
  }
  return null;
}

function AI_promptTemplate() {
  // ä½ æŒ‡å®šï¼šAã€Œç²¾å“å®˜ç¶²æ–‡æ¡ˆã€é«˜ç´šé»‘é‡‘ã€æ´—éŠã€å›ºå®š JSON
  return [
    "ä½ æ˜¯ç²¾å“é›»å•†çš„è³‡æ·±æ–‡æ¡ˆç¸½ç›£ï¼Œå“ç‰Œèª¿æ€§ï¼šé«˜ç´šã€é»‘é‡‘ã€æ¥µç°¡ã€æ´—éŠã€‚",
    "è«‹æ ¹æ“šå•†å“åœ–ç‰‡ï¼Œç”¢å‡ºã€Œç¹é«”ä¸­æ–‡ã€ç²¾å“å®˜ç¶²æ–‡æ¡ˆã€‚",
    "åš´æ ¼åªè¼¸å‡º JSONï¼Œä¸è¦è¼¸å‡ºä»»ä½•å¤šé¤˜æ–‡å­—ã€‚",
    "JSON æ ¼å¼å›ºå®šå¦‚ä¸‹ï¼š",
    "{",
    '  "title": "ï¼ˆ20å­—å…§ï¼Œç²¾å“æ„Ÿå‘½åï¼‰",',
    '  "description": "ï¼ˆ1æ®µç²¾ç·»ä¸»æ–‡ï¼Œé©åˆå®˜ç¶²ï¼‰",',
    '  "bullets": ["ï¼ˆ3-6é»è³£é»ï¼Œæ¯é»20å­—å…§ï¼‰"],',
    '  "keywords": ["ï¼ˆ5-10å€‹é—œéµè©ï¼Œç¹ä¸­ï¼‰"],',
    '  "category_guess": "ï¼ˆä¾‹å¦‚ï¼šæ‰‹æåŒ…/è‚©èƒŒåŒ…/æ–œèƒŒåŒ…/é…ä»¶/è¡Œæç­‰ï¼‰"',
    "}"
  ].join("\n");
}

async function AI_callOpenAI_vision(env, { imageUrl, sku = "" }) {
  const key = String(env.OPENAI_API_KEY || "").trim();
  if (!key) throw new Error("OPENAI_API_KEY_MISSING");

  const model = String(env.OPENAI_MODEL || "gpt-4o-mini").trim();

  const system = AI_promptTemplate();
  const userText = `SKU=${sku}\nè«‹ä¾åœ–ç‰‡ç”Ÿæˆç²¾å“å®˜ç¶²æ–‡æ¡ˆï¼ˆé»‘é‡‘ã€æ´—éŠã€å°‘æµ®èª‡ï¼‰ã€‚`;

  const payload = {
    model,
    messages: [
      { role: "system", content: system },
      {
        role: "user",
        content: [
          { type: "text", text: userText },
          { type: "image_url", image_url: { url: imageUrl } }
        ]
      }
    ],
    temperature: 0.7
  };

  const r = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${key}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(payload)
  });

  const data = await r.json().catch(() => null);
  if (!r.ok) {
    throw new Error(`OPENAI_FAILED ${r.status} ${JSON.stringify(data || {})}`);
  }

  const text = data?.choices?.[0]?.message?.content || "";
  const json = AI_extractJson(text);
  if (!json) throw new Error("OPENAI_JSON_PARSE_FAILED");
  return json;
}

// -------------------- Router --------------------
export default {
  async fetch(req, env, ctx){
    const url = new URL(req.url);
    const origin = req.headers.get("Origin") || "";
    const path = url.pathname;   // â˜… å…ˆæ‹¿åˆ° pathï¼Œå¾Œé¢ CORS è¦ç”¨
    if (req.method === "GET" && path === "/member/credit-balance") {
      const url = new URL(req.url);
      const lineUserId = (url.searchParams.get("line_user_id") || "").trim();
    
      // æœªç™»å…¥ / æ²’å¸¶ line_user_idï¼šç›´æ¥ç•¶ 0 + æœªç¶å®š
      if (!lineUserId) {
        return j(env, origin, { ok: true, line_user_id: "", is_bound: false, balance: 0 });
      }
    
      const is_bound = await isBoundMember(env, lineUserId);
      if (!is_bound) {
        return j(env, origin, { ok: true, line_user_id: lineUserId, is_bound: false, balance: 0 });
      }
    
      const balance = await getCreditBalance(env, lineUserId);
      return j(env, origin, { ok: true, line_user_id: lineUserId, is_bound: true, balance });
    }
// ===== 7-11 å®˜æ–¹ e-mapï¼šæ•´é è·³è½‰ç‰ˆï¼ˆmobile å‹å–„ï¼‰ =====

// 1) æ•´é è·³å» 7-11 åœ°åœ–ï¼šGET /cvs/map?src=cod|paid|dep_old|dep_new_p|dep_new_f|zc&cart_token=...&customer=...&mode=...
if (req.method === 'GET' && url.pathname === '/cvs/map') {
  const paramsIn = url.searchParams;

  // è¦å¸¶å› callback çš„è‡ªè¨‚åƒæ•¸
  const cbParams = new URLSearchParams();
  // âœ… æ­£è¦åŒ– + ç™½åå–®ï¼ˆé¿å…äº‚å€¼/å¤§å°å¯«ï¼‰
const ALLOW_SRC = new Set(['cod','paid','yufu','dep_old','dep_new_p','dep_new_f','zc']);

const srcIn = String(paramsIn.get('src') || '').toLowerCase().trim();
const src   = ALLOW_SRC.has(srcIn) ? srcIn : 'cod';

const cartToken = paramsIn.get('cart_token') || '';
const customer  = paramsIn.get('customer') || '';
const mode      = paramsIn.get('mode') || '';

cbParams.set('src', src);
if (cartToken) cbParams.set('cart_token', cartToken);
if (customer)  cbParams.set('customer', customer);
if (mode)      cbParams.set('mode', mode);


  const apiBase = new URL(req.url).origin; // ä¾‹å¦‚ https://api.murain.tw
  const cb = `${apiBase}/cvs/callback?${cbParams.toString()}`;

  const action = 'https://emap.presco.com.tw/c2cemap.ashx';
  const htmlDoc = `<!doctype html><meta charset="utf-8">
<title>7-11 é–€å¸‚åœ°åœ–</title>
<form id="f" method="POST" action="${action}">
  <input type="hidden" name="eshopid" value="870">
  <input type="hidden" name="servicetype" value="1">
  <input type="hidden" name="url" value="${cb}">
</form>
<script>document.getElementById('f').submit();</script>`;
  return html(htmlDoc);
}

// 2) 7-11 åœ°åœ–å›å‚³ï¼š/cvs/callbackï¼ˆæˆ– /cvs_callbackï¼‰â†’ ç›´æ¥ 302 å›å‰å° checkout.html
if ((req.method === 'POST' || req.method === 'GET') &&
    (url.pathname === '/cvs/callback' || url.pathname === '/cvs_callback')) {

  // æ”¶ 7-11 å›å‚³è³‡æ–™ï¼ˆPOST form æˆ– GET éƒ½æ”¯æ´ï¼‰
  let data = {};
  if (req.method === 'POST') {
    const form = await req.formData();
    form.forEach((v, k) => (data[k] = v));
  } else {
    url.searchParams.forEach((v, k) => (data[k] = v));
  }

  const pick = (...keys) => keys.map(k => data[k]).find(v => v && String(v).trim());

  const id   = pick('STOREID','StoreID','stCode','storeid','storeidno','CVSStoreID') || '';
  const name = pick('STORENAME','StoreName','stName','storename','CVSStoreName') || '';
  const addr = pick('STOREADDRESS','StoreAddress','stAddr','storeaddress','CVSAddress') || '';

  // é€™äº›æ˜¯åœ¨ /cvs/map â†’ callback æ™‚æˆ‘å€‘è‡ªå·±æ›åœ¨ query ä¸Šçš„
  const ALLOW_SRC = new Set(['cod','paid','yufu','dep_old','dep_new_p','dep_new_f','zc']);
const srcIn = String(url.searchParams.get('src') || '').toLowerCase().trim();
const src   = ALLOW_SRC.has(srcIn) ? srcIn : 'cod';
  const cartToken = url.searchParams.get('cart_token') || '';
  const customer  = url.searchParams.get('customer') || 'old';

  let mode = (url.searchParams.get('mode') || '').toUpperCase();
  if (!mode) {
    switch (src) {
      case 'cod':       mode = 'COD';       break;
      case 'paid':      mode = 'PAID';      break;
      case 'zc':        mode = 'ZEROCARD';  break;
      case 'yufu': mode = 'YUFU'; break;
      case 'dep_old':
      case 'dep_new_p':
      case 'dep_new_f': mode = 'DEPOSIT';   break;
      default:          mode = 'COD';
    }
  }

  const front = (env.FRONT_ORIGIN || 'https://murain.tw').replace(/\/$/, '');
  const q = new URLSearchParams();

  // ä¸€å®šè¦æŠŠ cart_token å¸¶å›å»ï¼Œè³¼ç‰©è»Šæ‰ä¸æœƒæ¶ˆå¤±
  if (cartToken) q.set('cart_token', cartToken);
  if (customer)  q.set('customer', customer);
  if (mode)      q.set('mode', mode);
  if (src)       q.set('store_src', src);
  if (id)        q.set('store_id', id);
  if (name)      q.set('store_name', name);
  if (addr)      q.set('store_addr', addr);

  const redirectUrl = `${front}/liff-checkout.html?${q.toString()}`;

  return new Response(
    `<!doctype html><meta charset="utf-8"><meta http-equiv="refresh" content="0;url=${redirectUrl}">`,
    {
      status: 302,
      headers: {
        'Location': redirectUrl,
        'Content-Type': 'text/html; charset=utf-8'
      }
    }
  );
}



    // ===== CORS & preflight =====
    if (req.method === "OPTIONS") {
      return new Response("", { status: 200, headers: buildCors(env, origin) });
    }
    // â˜… é€™è¡Œä¿ç•™ä½ ç¾åœ¨çš„æ¢ä»¶ï¼šåªæœ‰ /payuni/return ä¾‹å¤–å¯ä»¥ä¸æª¢æŸ¥ origin
if (origin && !allowedOrigins(env).has(origin) &&
path !== "/payuni/return") {
return j(env, origin, { ok:false, error:"origin_not_allowed" }, 401);
}

const body = async () => { try { return await req.json(); } catch { return {}; } };

    try {
      // --- Ping ---
      if (req.method === "GET" && path === "/ping") {
        return j(env, origin, { ok:true });
      }

      // ======================= (NEW) Cloudflare Images: Direct Upload =======================
// POST /images/direct-upload
// body: { op_key, sku, expiry_seconds?, require_signed_urls?, variant? }
if (req.method === "POST" && path === "/images/direct-upload") {
  try {
    const b = await body();
    const op_key = b?.op_key;
    if (!op_key || String(op_key) !== String(env.OP_KEY)) {
      return j(env, origin, { ok: false, error: "forbidden" }, 403);
    }

    const sku = String(b?.sku || "").trim();
    if (!sku) return j(env, origin, { ok:false, error:"missing_sku" }, 400);

    const expirySeconds = Number(b?.expiry_seconds || 1800) || 1800;
    const requireSigned = !!b?.require_signed_urls;
    const variant = String(b?.variant || env.CF_IMAGES_VARIANT || "public").trim();

    const result = await IMG_createDirectUpload(env, {
      sku,
      expirySeconds,
      requireSignedURLs: requireSigned
    });

    // result: { id, uploadURL }
    const delivery_url = IMG_deliveryUrl(env, result?.id, variant);

    return j(env, origin, {
      ok: true,
      sku,
      id: result?.id || "",
      uploadURL: result?.uploadURL || "",
      delivery_url
    }, 200);
  } catch (e) {
    console.log("/images/direct-upload error", e?.message || e);
    return j(env, origin, { ok:false, error:"internal_error", detail:String(e?.message || e) }, 500);
  }
}


// ======================= (NEW) Products: AI from Image =======================
// POST /products/ai-from-image
// body: { op_key, sku, image_id?, image_url?, variant?, write_airtable?=true, overwrite_image?=false }
if (req.method === "POST" && path === "/products/ai-from-image") {
  try {
    const b = await body();
    const op_key = b?.op_key;
    if (!op_key || String(op_key) !== String(env.OP_KEY)) {
      return j(env, origin, { ok: false, error: "forbidden" }, 403);
    }

    const sku = String(b?.sku || "").trim();
    if (!sku) return j(env, origin, { ok:false, error:"missing_sku" }, 400);

    const variant = String(b?.variant || env.CF_IMAGES_VARIANT || "public").trim();
    const image_id = String(b?.image_id || "").trim();
    const image_url_in = String(b?.image_url || "").trim();

    const imageUrl =
      image_url_in ||
      (image_id ? IMG_deliveryUrl(env, image_id, variant) : "");

    if (!imageUrl) {
      return j(env, origin, { ok:false, error:"missing_image_url_or_image_id" }, 400);
    }

    // 1) AI ç”Ÿæˆæ–‡æ¡ˆ
    const ai = await AI_callOpenAI_vision(env, { imageUrl, sku });

    const title = String(ai?.title || "").trim();
    const desc  = String(ai?.description || "").trim();
    const bullets = Array.isArray(ai?.bullets) ? ai.bullets : [];
    const keywords = Array.isArray(ai?.keywords) ? ai.keywords : [];
    const category_guess = String(ai?.category_guess || "").trim();

    if (!title || !desc) {
      return j(env, origin, { ok:false, error:"ai_output_invalid", ai }, 502);
    }

    // 2) å›å¯« Airtableï¼ˆåªå‹•ä½ ç¾æœ‰çš„ Title / Description / ImageURLï¼Œä¸ç¢°åˆ¥çš„ï¼‰
    const writeAirtable = (b?.write_airtable ?? true) !== false;
    const overwriteImage = !!b?.overwrite_image;

    let patched = false;
    if (writeAirtable) {
      const T = env.AT_PRODUCTS || "Products";
      const rec = await atFindByField(env, T, "SKU", sku) || await atFindByField(env, T, "sku", sku);
      if (!rec) {
        return j(env, origin, { ok:false, error:"product_not_found", sku }, 404);
      }

      const f = rec.fields || {};

// --- 1) çµ„åˆ Descriptionï¼ˆä¿ç•™ä½ åŸæœ¬æ ¼å¼ï¼‰---
const descFull = [
  desc,
  bullets.length
    ? ("\n\n" + bullets.map(x => `â€¢ ${String(x || "").trim()}`).filter(Boolean).join("\n"))
    : ""
].join("").trim();

// --- 2) tags å…ˆç”¨ã€Œå­—ä¸²ã€å¯«å…¥ï¼ˆæœ€ç©©ï¼šä¸ç®¡ä½  ai_tags æ˜¯æ–‡å­—æ¬„æˆ–å¤šé¸éƒ½ä¸å®¹æ˜“çˆ†ï¼‰---
const tagsArr  = Array.isArray(keywords) ? keywords.map(x => String(x || "").trim()).filter(Boolean) : [];
const tagsText = tagsArr.join(", ");

// --- 3) å½±åƒæ¬„ä½ï¼ˆthumb æ²’åš variant å°±ç”¨ public ç•¶ fallbackï¼‰---
const thumbUrl = IMG_deliveryUrl(env, image_id, "thumb") || imageUrl;
const now      = (typeof nowISO === "function") ? nowISO() : new Date().toISOString();

// --- 4) patchï¼šä¿ç•™ä½ åŸæœ¬ 3 æ¬„ + åŒæ™‚å¯«å…¥ image_* / ai_* ---
const patch = {
  // âœ… ä½ åŸæœ¬å°±æœƒå¯«çš„ä¸‰å€‹ï¼ˆä¿ç•™ï¼‰
  Title: title,
  Description: descFull,

  // âœ… ä½ æ–°å¢çš„å½±åƒæ¬„ä½
  [env.AT_IMAGE_ID_FIELD || "image_id"]: image_id,
  [env.AT_IMAGE_URL_FIELD || "image_url"]: imageUrl,
  [env.AT_THUMB_URL_FIELD || "thumb_url"]: thumbUrl,

  // âœ… ä½ æ–°å¢çš„ AI æ¬„ä½
  [env.AT_AI_TITLE_FIELD || "ai_title"]: title,
  [env.AT_AI_DESC_FIELD || "ai_desc"]: desc,
  [env.AT_AI_TAGS_FIELD || "ai_tags"]: tagsText,
  [env.AT_AI_STATUS_FIELD || "ai_status"]: "ok",
  [env.AT_AI_UPDATED_AT_FIELD || "ai_updated_at"]: now
};

// --- 5) ImageURL æ¬„ä½ï¼šç¶­æŒä½ åŸæœ¬ã€Œæœ‰åœ–å°±ä¸è¦†è“‹ã€çš„è¦å‰‡ ---
const curImg = String(f.ImageURL || "").trim();
if (!curImg || overwriteImage) {
  patch.ImageURL = imageUrl;
}

// å¦‚æœä½ ä¹Ÿæƒ³ image_url / thumb_url åŒæ¨£éµå®ˆã€Œä¸è¦†è“‹ã€ï¼šå°±åŠ é€™æ®µï¼ˆå»ºè­°åŠ ï¼‰
const curImageUrl = String(f[env.AT_IMAGE_URL_FIELD || "image_url"] || "").trim();
if (curImageUrl && !overwriteImage) {
  delete patch[env.AT_IMAGE_URL_FIELD || "image_url"];
  delete patch[env.AT_THUMB_URL_FIELD || "thumb_url"];
  delete patch[env.AT_IMAGE_ID_FIELD || "image_id"];
}

await at(env, "PATCH", T, "", { records: [{ id: rec.id, fields: patch }] });
patched = true;
    }

    return j(env, origin, {
      ok: true,
      sku,
      image_url: imageUrl,
      airtable_updated: patched,
      ai: { title, description: desc, bullets, keywords, category_guess }
    }, 200);
  } catch (e) {
    console.log("/products/ai-from-image error", e?.message || e);
    return j(env, origin, { ok:false, error:"internal_error", detail:String(e?.message || e) }, 500);
  }
}

// ===== Public: Products + Categories tree =====
// GET /public/products
if (req.method === "GET" && path === "/public/products") {
  try {
    const T_PRODUCTS = env.AT_PRODUCTS || "Products";
    const T_CATS     = env.AT_CATEGORIES || "Categories";
    const T_SUBS     = env.AT_SUBCATEGORIES || "Subcategories";
    const T_IMAGES   = env.AT_PRODUCT_IMAGES || "ProductImages";

    const asNum = (v, d = 0) => {
      const n = Number(v);
      return Number.isFinite(n) ? n : d;
    };
    const norm = (v) => String(v || "").trim();

    // --- Categories ---
    const catRecs = await atListAll(env, T_CATS, {
      filterByFormula: "{Active}",
      "sort[0][field]": "Sort",
      "sort[0][direction]": "asc",
    });

    // --- Subcategories ---
    const subRecs = await atListAll(env, T_SUBS, {
      filterByFormula: "{Active}",
      "sort[0][field]": "Sort",
      "sort[0][direction]": "asc",
    });

    // å»ºç´¢å¼•ï¼šcategoryRecId -> node
    const catById = new Map();
    const categories = catRecs.map(r => {
      const f = r.fields || {};
      const code = norm(f.code || f.Code || f.CODE);
      const node = {
        code,
        name: norm(f.name || f.Name || f.NAME) || code,
        sort: asNum(f.Sort, 0),
        subcategories: []
      };
      catById.set(r.id, node);
      return node;
    });

    // subRec: éœ€è¦ fields.category æ˜¯ link -> Categories
    const subById = new Map();
    subRecs.forEach(r => {
      const f = r.fields || {};
      const catLink = (f.category || f.Category || []);
      const catId = Array.isArray(catLink) && catLink.length ? catLink[0] : "";

      const code = norm(f.code || f.Code || f.CODE);
      const subObj = {
        code,
        name: norm(f.name || f.Name || f.NAME) || code,
        sort: asNum(f.Sort, 0),
        category_id: catId
      };
      subById.set(r.id, subObj);

      const parent = catById.get(catId);
      if (parent) parent.subcategories.push({ code: subObj.code, name: subObj.name, sort: subObj.sort });
    });

    // --- Products (Active=1) ---
    const prodRecs = await atListAll(env, T_PRODUCTS, {
      filterByFormula: "({Active}=1)",
    });

    // --- Images: å…¨éƒ¨è®€å®Œï¼ˆä¸è¦åªè®€ 100ï¼‰---
    const CF_HASH    = String(env.CF_IMAGES_ACCOUNT_HASH || "").trim();
    const CF_VARIANT = String(env.CF_IMAGES_VARIANT || "public").trim();

    function cfDeliveryUrl(imageId, variant = CF_VARIANT){
      const id = String(imageId || "").trim();
      if (!id || !CF_HASH) return "";
      return `https://imagedelivery.net/${CF_HASH}/${encodeURIComponent(id)}/${variant}`;
    }

    let imgRecs = [];
    try {
      imgRecs = await atListAll(env, T_IMAGES, {
        filterByFormula: "{product}",
        "sort[0][field]": "Sort",
        "sort[0][direction]": "asc",
      });
    } catch (e) {
      imgRecs = [];
    }

    // productRecId -> [{url, sort, isCover}]
    const imgsByProd = new Map();
    imgRecs.forEach(r => {
      const f = r.fields || {};

      const prodLink = (f.product || f.Product || []);
      const pid = Array.isArray(prodLink) && prodLink.length ? prodLink[0] : "";
      if (!pid) return;

      // âœ… å®¹éŒ¯ï¼šimage_id / ImageId / Image / ...
      const imageId = String(
        f.image_id || f.ImageId || f.imageId || f.cf_image_id || f.CF_IMAGE_ID || f.Image || ""
      ).trim();
      if (!imageId) return;

      const variant = String(f.variant || f.Variant || CF_VARIANT || "public").trim();
      const url = cfDeliveryUrl(imageId, variant);
      if (!url) return;

      const arr = imgsByProd.get(pid) || [];
      arr.push({
        url,
        sort: asNum(f.Sort, 0),
        isCover: !!(f.IsCover || f.isCover)
      });
      imgsByProd.set(pid, arr);
    });

    // --- helper: pick text ---
    function pickFirst(...vals){
      for (const v of vals){
        const s = String(v || "").trim();
        if (s) return s;
      }
      return "";
    }

// --- Build items[] ---
const items = prodRecs.map(r => {
  const f = r.fields || {};
  const sku = norm(f.SKU || f.sku);
  const title = pickFirst(
    f.Title, f.title,
    f.ai_title,
    f.Name, f.name,
    sku
  );

  const subLink = (f.sub_category || f.subcategory || f.Subcategory || []);
  const subId = Array.isArray(subLink) && subLink.length ? subLink[0] : "";
  const sub = subById.get(subId);
  const cat = sub ? catById.get(sub.category_id) : null;

  // âœ… å…ˆåƒ ProductImagesï¼ˆå¤šåœ–ï¼‰
  const imgs = (imgsByProd.get(r.id) || []).sort((a,b) =>
    (a.isCover === b.isCover) ? (a.sort - b.sort) : (a.isCover ? -1 : 1)
  );

  let images = imgs.map(x => x.url);
  let cover  = images[0] || "";

  // âœ… è‹¥ ProductImages æ²’æœ‰ï¼šé€€å› Products çš„å–®åœ–ï¼ˆimage_id æˆ– image_urlï¼‰
  if (!cover) {
    const pid = String(
      f.image_id || f.ImageId || f.imageId || ""
    ).trim();

    const directUrl = String(
      f.image_url || f.thumb_url || f.image || f.Image || ""
    ).trim();

    cover = directUrl || cfDeliveryUrl(pid, CF_VARIANT) || "";
    images = cover ? [cover] : [];
  }

  const description = pickFirst(
    f.Description, f.description,
    f.ai_desc,
    ""
  );

  return {
    sku,
    title,
    price: asNum(f.Price, 0),
    list_price: asNum(f.ListPrice || f.list_price, 0),
    web_price: asNum(f.WebPrice || f.web_price, 0),
    stock_qty: asNum(f.StockQty || f.stock_qty, 0),
    description,

    category_code: cat ? cat.code : "",
    category_name: cat ? cat.name : "",
    subcategory_code: sub ? sub.code : "",
    subcategory_name: sub ? sub.name : "",

    image: cover,
    images,

    sort: asNum(f.Sort, 0),
  };
});

    items.sort((a,b) => asNum(a.sort, 0) - asNum(b.sort, 0));
    return j(env, origin, { ok:true, categories, items });
  } catch (e) {
    console.log("public/products error", e);
    return j(env, origin, { ok:false, error: String(e?.message || e) }, 500);
  }
}
      // âœ… ä¸€éµé‡æ–°çµå¸³ï¼šç”¨èˆŠè¨‚å–® items_json é‡å»ºæ–°è³¼ç‰©è»Š â†’ 302 å°å› liff-checkout.html
// âœ… ä¸€éµé‡æ–°çµå¸³ï¼šç”¨èˆŠè¨‚å–® items_json é‡å»ºæ–°è³¼ç‰©è»Š â†’ 302 å°å› liff-checkout.html
if (req.method === "GET" && path === "/order/retry-checkout") {
  const u = new URL(req.url);
  const orderId = String(u.searchParams.get("order_id") || "").trim();
  if (!orderId) return j(env, origin, { ok:false, error:"missing_order_id" }, 400);

  // ---- å°å·¥å…·ï¼šUTF-8 base64urlï¼ˆé¿å… unescape åœ¨æŸäº›ç’°å¢ƒæ€ªæ€ªçš„ï¼‰----
  const base64urlEncodeUtf8 = (s) => {
    const bytes = new TextEncoder().encode(String(s || ""));
    let bin = "";
    for (const b of bytes) bin += String.fromCharCode(b);
    const b64 = btoa(bin);
    return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  };

  // 1) æ‰¾åˆ°é€™ç­†è¨‚å–®
  const TO = env.AT_ORDERS || "Orders";
  const r0 = await at(env, "GET", TO, "", null, {
    filterByFormula: `{order_id}='${esc(orderId)}'`,
    maxRecords: "1",
  });
  const orec = r0.records && r0.records[0];
  if (!orec) return j(env, origin, { ok:false, error:"order_not_found" }, 404);
  const f = orec.fields || {};

  // 2) å®‰å…¨é™åˆ¶ï¼šå…è¨± status æˆ– pay_status å±¬æ–¼å¤±æ•—/å–æ¶ˆæ‰é‡å»º
  const st = String(f.status || "").toLowerCase().trim();
  const ps = String(f.pay_status || "").toLowerCase().trim();
  const allow =
    st.includes("fail") || st.includes("cancel") || st === "rejected" || st === "payment_failed" ||
    ps.includes("fail") || ps.includes("cancel");
  if (!allow) {
    return j(env, origin, {
      ok:false,
      error:"retry_not_allowed",
      message:`æ­¤ç‹€æ…‹ä¸å…è¨±é‡å»ºï¼šstatus=${f.status || ""} pay_status=${f.pay_status || ""}`
    }, 400);
  }

  // 2.5) âœ… é˜²å‘†ï¼šåŒä¸€å¼µå¤±æ•—å–®åªå…è¨±ç¶å®šä¸€å° retry æ–°è»Š
  // - è‹¥å·²ç¶éï¼šå›åŒä¸€å°
  // - ä½†è‹¥é‚£å° retry è»Šä¹Ÿå·²é€å‡ºçµå–®ï¼šä¸è¦ä¸€ç›´å°å›å»å¡æ­» â†’ ç›´æ¥æç¤ºã€Œç”¨æœ€æ–°å¤±æ•—å¡ / è¯ç¹«å®¢æœã€
  const note0 = String(f.internal_note || "");
  const mRetry = /\[RETRY_CART=([^\]]+)\]/.exec(note0);
  const lastCart = mRetry ? String(mRetry[1] || "").trim() : "";

  if (lastCart) {
    const CT = env.AT_CARTS || "CartToken";
    let cartRec = null;
    try { cartRec = await atFindByField(env, CT, "CartToken", lastCart); } catch (e) { cartRec = null; }

    if (cartRec && cartRec.id) {
      const cf = cartRec.fields || {};
      const cst = String(cf.status || cf.Status || "").toLowerCase().trim();

      // ä½ ç³»çµ±çš„ã€Œå·²çµå–®ã€åˆ¤æ–·ï¼šchecked_out=true æˆ– status=submitted/checking_out
      const isBound = !!cf.checked_out || cst === "submitted" || cst === "checking_out";

      if (isBound) {
        return j(env, origin, {
          ok: false,
          error: "retry_cart_already_used",
          order_id: orderId,
          message:
            "æ­¤å¤±æ•—è¨‚å–®å·²é‡æ–°çµå¸³éï¼Œä¸”æ–°è³¼ç‰©è»Šå·²é€å‡ºçµå–®ã€‚\n" +
            "è«‹ä½¿ç”¨æœ€æ–°çš„ä»˜æ¬¾å¤±æ•—é€šçŸ¥å¡é‡æ–°çµå¸³ï¼Œæˆ–è¯ç¹« LINE å®˜æ–¹å®¢æœå”åŠ©è™•ç†" +
            (orderId ? `ï¼ˆè«‹æä¾›æˆ–æˆªåœ–è¨‚å–®ç·¨è™Ÿï¼š${orderId}ï¼‰` : "") +
            "ã€‚"
        }, 409);
      }
    }

    // å°šæœªçµå–®ï¼ˆæˆ–æ‰¾ä¸åˆ° cartRecï¼‰ï¼šå°å›åŒä¸€å° retry è»Š
    const frontBase = (env.FRONT_ORIGIN || "https://murain.tw").replace(/\/+$/, "");
    const q = new URLSearchParams();
    q.set("cart_token", lastCart);
    q.set("from", "retry");
    q.set("order_id", orderId);

    const lastPm = String(f.payment_method || "").trim();
    if (lastPm) q.set("pm", lastPm);

    const shipInfoRaw = String(f.shipping_info || "").trim();
    if (shipInfoRaw) q.set("ship_b64", base64urlEncodeUtf8(shipInfoRaw));

    const redirectTo = `${frontBase}/liff-checkout.html?${q.toString()}`;
    return Response.redirect(redirectTo, 302);
  }

  // 3) è§£æ items_json
  let items = [];
  try { items = JSON.parse(String(f.items_json || "[]")); } catch {}
  if (!Array.isArray(items) || items.length === 0) {
    return j(env, origin, { ok:false, error:"no_items_to_retry", message:"items_json ç©ºï¼Œç„¡æ³•é‡å»ºè³¼ç‰©è»Š" }, 400);
  }

// 4) å»ºç«‹æ–° cart_token
const newCartToken = `CT${Date.now()}${Math.random().toString(16).slice(2)}`;

// 5) âœ… å»ºç«‹æ–°è³¼ç‰©è»Šï¼ˆä¿éšªï¼šstreamer_name å¯èƒ½æ˜¯é™£åˆ—/ä¸ç›¸å®¹æ¬„ä½ï¼Œå…ˆé™ç´šå†è©¦ï¼‰
const streamerRaw = (f.streamer_name ?? f.streamer ?? "");
const streamerSafe = Array.isArray(streamerRaw) ? "" : String(streamerRaw || "").trim();
const ctype    = f.customer_type || "live";

// ç›¡é‡æŠŠ line_user_id / customer_name è£œé€²æ–°è»Šï¼ˆæ²’æœ‰ä¹Ÿä¸æœƒå£ï¼‰
let lineUserId = String(f.line_user_id || "").trim();
let customerName = String(f.customer_name || "").trim();

if ((!lineUserId || !customerName) && f.shipping_info) {
  try {
    const si = JSON.parse(String(f.shipping_info || "{}"));
    const line = si.line || si.line_profile || {};
    const ship = si.ship || {};
    if (!lineUserId) lineUserId = String(line.user_id || line.userId || line.LINE_USER_ID || "").trim();
    if (!customerName) customerName = String(line.display_name || line.displayName || ship.name || "").trim();
  } catch (e) {}
}

try {
  await ensureCart(env, newCartToken, streamerSafe, ctype, lineUserId, customerName);
} catch (e) {
  // ğŸš‘ å¦‚æœ Airtable å° streamer_name ä¸åƒï¼ˆå–®é¸/é€£çµä¸ç›¸å®¹ï¼‰ï¼Œå°±ä¸è¦å¯« streamer_nameï¼Œç¢ºä¿èƒ½é‡å»ºæˆåŠŸ
  console.log("retry-checkout ensureCart streamer_name rejected, retry without streamer_name", e);
  await ensureCart(env, newCartToken, "", ctype, lineUserId, customerName);
}
  // 6) âœ… å¡å› CartItemsï¼ˆä¿éšªç‰ˆï¼šæ˜ç¢ºå¯«å…¥ Airtableï¼Œä¸é  upsertCartItemï¼‰
const CART_ITEMS_TABLE = env.AT_CARTITEMS || env.AT_CART_ITEMS || "CartItems";
const recs = [];

for (const it of (items || [])) {
  const sku  = String(it.sku || it.SKU || it.Sku || "").trim();
  const qty  = Number(it.qty ?? it.quantity ?? it.Qty ?? 1) || 0;
  const price= Number(it.price ?? it.unit_price ?? it.UnitPrice ?? 0) || 0;
  const name = String(it.name || it.product_name || it.ProductName || "").trim();

  if (!sku || qty <= 0) continue;

  // âš ï¸ ä¸‹é¢ fields çš„ key è¦è·Ÿä½  CartItems è¡¨ã€Œæ¬„ä½åç¨±ã€ä¸€è‡´
  recs.push({ fields: {
    CartToken: newCartToken,      // âœ… åªèƒ½å¯«é€™å€‹ï¼ˆå¯å¯«å…¥æ¬„ä½ï¼‰
    SKU: it.sku,
    Name: it.name,
    Price: Number(it.price || 0),
    Qty: Number(it.qty || 0),
  }});
}

if (!recs.length) {
  return j(env, origin, { ok:false, error:"no_valid_items", message:"æ­¤è¨‚å–®æ²’æœ‰å¯å›å¡«çš„å“é …" }, 400);
}

// Airtable ä¸€æ¬¡æœ€å¤š 10 ç­†
for (let i = 0; i < recs.length; i += 10) {
  await at(env, "POST", CART_ITEMS_TABLE, "", { records: recs.slice(i, i + 10) });
}

 // 6.5) âœ… æ°¸ä¹…è¨˜éŒ„ï¼šåŒä¸€å¼µå¤±æ•—å–®åªç”¢ç”Ÿä¸€å° retry è»Šï¼ˆé¿å…å¤±æ•—å¡è¢«é€£é»ä¸€ç›´é–‹æ–°è»Šï¼‰
 try {
  const old = String(f.internal_note || "").trim();
  if (!/\[RETRY_CART=/.test(old)) {
    const add = `[RETRY_CART=${newCartToken}]`;
    const note1 = old ? (old + "\n" + add) : add;

    await at(env, "PATCH", TO, "", {
      records: [{ id: orec.id, fields: { internal_note: note1 } }]
    });

    // åŒæ­¥æ›´æ–°æœ¬åœ° fï¼Œé¿å…æœ¬æ¬¡æµç¨‹å¾Œé¢å†è®€åˆ°èˆŠ note
    f.internal_note = note1;
  }
} catch (e) {
  console.log("retry-checkout: write RETRY_CART failed", e);
}

  // 7) çµ„å›å‰ç«¯çµå¸³ç¶²å€ï¼ˆæ–°è»Šï¼‰
  const frontBase = (env.FRONT_ORIGIN || "https://murain.tw").replace(/\/+$/, "");
  const q = new URLSearchParams();
  q.set("cart_token", newCartToken);
  q.set("from", "retry");
  q.set("order_id", orderId);
  // âœ… 2) å¸¶å›ä¸Šæ¬¡æ”¶ä»¶è³‡è¨Šï¼ˆshipping_infoï¼‰çµ¦å‰ç«¯å›å¡«
  const shipInfoRaw = String(f.shipping_info || "").trim();
  if (shipInfoRaw) {
    q.set("ship_b64", base64urlEncodeUtf8(shipInfoRaw));
  }

  const redirectTo = `${frontBase}/liff-checkout.html?${q.toString()}`;
  return Response.redirect(redirectTo, 302);
}

      // --- OP auth ---
      if (req.method === "POST" && path === "/op/auth"){
        const { op_key } = await body();
        const ok = op_key && env.OP_KEY && String(op_key) === String(env.OP_KEY);
        return j(env, origin, { ok }, ok?200:403);
      }

      // --- Memberï¼šæŸ¥è©¢æœƒå“¡æ‰€æœ‰è¨‚å–®ï¼ˆlive + webï¼‰---
if (req.method === "GET" && path === "/member/orders") {
  try {
    const lineUserId = url.searchParams.get("line_user_id") || "";
    if (!lineUserId) {
      return j(env, origin, { ok:false, error:"missing_line_user_id" }, 400);
    }

    const T = env.AT_ORDERS || "Orders";

    function norm(v){ return String(v || "").trim().toLowerCase(); }
function pickBestTail(tails = []) {
  if (!tails.length) return null;

  const isPaid = (ps) => ["paid_ok","paid"].includes(norm(ps));
  const isBad  = (ps) => ["cancelled","canceled","failed","expired","void"].includes(norm(ps));

  // 1) å…ˆé¸å·²ä»˜æ¬¾ï¼ˆç”¨ paid_at / created_at / createdTime æ’ï¼‰
  const paidOnes = tails.filter(t => isPaid(t?.fields?.payment_status || t?.fields?.pay_status));
  if (paidOnes.length) {
    paidOnes.sort((a,b) => {
      const da = new Date(a?.fields?.paid_at || a?.fields?.created_at || a?.createdTime || 0).getTime();
      const db = new Date(b?.fields?.paid_at || b?.fields?.created_at || b?.createdTime || 0).getTime();
      return db - da;
    });
    return paidOnes[0];
  }

  // 2) æ’é™¤å¤±æ•—/å–æ¶ˆå¾Œé¸æœ€æ–°
  const goodOnes = tails.filter(t => !isBad(t?.fields?.payment_status || t?.fields?.pay_status));
  const list = goodOnes.length ? goodOnes : tails;

  list.sort((a,b) => {
    const da = new Date(a?.fields?.created_at || a?.createdTime || 0).getTime();
    const db = new Date(b?.fields?.created_at || b?.createdTime || 0).getTime();
    return db - da;
  });
  return list[0];
}

// â‘  å…ˆæ’ˆä¸»å–®ï¼ˆline_user_id = æœƒå“¡ï¼‰
const paramsMain = {
  filterByFormula: `AND(
    {line_user_id}='${escFormula(lineUserId)}',
    LEFT({order_id}, 2)='OD'
  )`,
  "sort[0][field]": "created_at",
  "sort[0][direction]": "desc",
  pageSize: "100"
};
const resMain = await at(env, "GET", T, "", null, paramsMain);
const mainRecords = (resMain.records || []);

// â‘¡ å†æ’ˆå°¾æ¬¾å–®ï¼šparent_order_id IN (ä¸»å–® order_id...)
const parentIds = mainRecords
  .map(r => String(r?.fields?.order_id || "").trim())
  .filter(Boolean);

// Airtable OR() å¤ªé•·æœƒçˆ†ï¼Œæ‰€ä»¥æœ€å¤šå…ˆæŠ“ 50 ç­†ä¸»å–®å»æ‰¾å°¾æ¬¾ï¼ˆé€šå¸¸å¤ ç”¨ï¼‰
const takeIds = parentIds.slice(0, 50);

let tailRecords = [];
if (takeIds.length) {
  const orParts = takeIds.map(oid => `{parent_order_id}='${escFormula(oid)}'`).join(",");
  const paramsTail = {
    filterByFormula: `OR(${orParts})`,
    "sort[0][field]": "created_at",
    "sort[0][direction]": "desc",
    pageSize: "100"
  };
  const resTail = await at(env, "GET", T, "", null, paramsTail);
  tailRecords = (resTail.records || []);

  // âœ… åªä¿ç•™æ¯å€‹ parent çš„ã€Œæœ€ä½³å°¾æ¬¾å–®ã€ï¼ˆå·²ä»˜æ¬¾å„ªå…ˆï¼Œå¦å‰‡æœ€æ–°ï¼‰
  const byParent = new Map();
  for (const tr of tailRecords) {
    const pid = String(tr?.fields?.parent_order_id || "").trim();
    if (!pid) continue;
    if (!byParent.has(pid)) byParent.set(pid, []);
    byParent.get(pid).push(tr);
  }
  tailRecords = Array.from(byParent.values())
    .map(list => pickBestTail(list))
    .filter(Boolean);
}

// â‘¢ åˆä½µå»é‡
const seen = new Set();
const records = [];
for (const r of [...mainRecords, ...tailRecords]) {
  if (!r?.id) continue;
  if (seen.has(r.id)) continue;
  seen.add(r.id);
  records.push(r);
}

const orders = records.map(rec => {
  const f = rec.fields || {};

  // è§£æ shipping_info
  let shipInfo = {};
  try {
    shipInfo = f.shipping_info ? JSON.parse(f.shipping_info) : {};
  } catch (e) {
    shipInfo = {};
  }

  const ship = shipInfo.ship || {};
  const store = ship.store || shipInfo.store || {};
  const post  = ship.post  || shipInfo.post  || {};

  const name  = ship.name  || shipInfo.name  || "";
  const phone = ship.phone || shipInfo.phone || "";

  const pm  = String(f.payment_method || "").toLowerCase();
  const type =
    (ship.type || "").toLowerCase() ||
    String(shipInfo.ship_type || shipInfo.ship_method || "").toLowerCase();

  // å¯„é€æ–¹å¼æ–‡å­—ï¼ˆæŠŠè²¨åˆ°ä»˜æ¬¾ä¹Ÿå¯«æ¸…æ¥šï¼‰
  let shipLabel = "";
  if (type === "711") {
    shipLabel = pm.startsWith("cod_") ? "7-11 å–è²¨ä»˜æ¬¾" : "7-11 è¶…å•†å–è²¨";
  } else if (type === "post") {
    shipLabel = pm.startsWith("cod_") ? "å®…é…è²¨åˆ°ä»˜æ¬¾" : "éƒµå¯„ / å®…é…";
  } else {
    if (pm === "cod_711")       shipLabel = "7-11 å–è²¨ä»˜æ¬¾";
    else if (pm === "cod_post") shipLabel = "å®…é…è²¨åˆ°ä»˜æ¬¾";
    else if (pm.startsWith("cod_")) shipLabel = "è²¨åˆ°ä»˜æ¬¾";
  }

  // è²¨é‹å–®è™Ÿï¼ˆå¾Œå°å¡«çš„é‚£ä¸€å€‹ï¼‰
  const trackingNo =
    ship.tracking_no ||
    shipInfo.tracking_no ||
    shipInfo.ship_no ||
    f.tracking_no ||
    f.ship_tracking ||
    "";

  // é–€å¸‚ / åœ°å€
  const storeName = store.name || "";
  const storeAddr = store.addr || "";
  const zip       = post.zip   || "";
  const addr      = post.addr  || "";

  // âœ… å·²ä»˜/è¨‚é‡‘é‡‘é¡ï¼šå„ªå…ˆæŠ“ Airtable æ¬„ä½ï¼Œæ²’æœ‰å°±å¾ shipping_info æŠ“
  const paidAmount = Number(
    f.paid_amount ??
    f.paidAmount ??
    f.deposit_paid ??
    f.depositPaid ??
    f.deposit_amount ??
    f.depositAmount ??
    shipInfo.paid_amount ??
    shipInfo.paidAmount ??
    shipInfo.deposit_paid ??
    shipInfo.depositPaid ??
    shipInfo.deposit_amount ??
    shipInfo.depositAmount ??
    0
  ) || 0;

  const depositAmount = Number(
    f.deposit_amount ??
    f.depositAmount ??
    f.deposit_paid ??
    f.depositPaid ??
    shipInfo.deposit_amount ??
    shipInfo.depositAmount ??
    shipInfo.deposit_paid ??
    shipInfo.depositPaid ??
    0
  ) || 0;

   // âœ… å®šé‡‘ä¿ç•™åˆ°æœŸæ—¥ï¼ˆAirtable æ¬„ä½ / shipping_info å®¹éŒ¯ï¼‰
   const depositExpireAt =
   f.deposit_expire_at ??
   shipInfo.deposit_expire_at ??
   shipInfo.depositExpireAt ??
   shipInfo?.deposit?.expire_at ??
   shipInfo?.deposit?.expireAt ??
   "";

 const holdUntil =
   f.hold_until ??
   shipInfo.hold_until ??
   shipInfo.holdUntil ??
   shipInfo?.deposit?.hold_until ??
   shipInfo?.deposit?.holdUntil ??
   "";

  return {
    id: rec.id,
    order_id: f.order_id || "",
    status: f.status || "",
    pay_status: (f.payment_status ?? f.pay_status ?? f.payStatus ?? ""),
    
    parent_order_id: String(f.parent_order_id || "").trim(),
  order_type: String(f.type || f.order_type || "").trim().toLowerCase(),

    // âœ… æ–°å¢ï¼šçµ¦å‰ç«¯è¨ˆç®—ã€Œå·²ä»˜è¨‚é‡‘/å·²ä»˜æ¬¾ã€èˆ‡ã€Œå‰©é¤˜å°¾æ¬¾ã€
    paid_amount: paidAmount,
    deposit_amount: depositAmount,
     // âœ… æ–°å¢ï¼šçµ¦å‰ç«¯é¡¯ç¤ºã€Œä¿ç•™åˆ°æœŸæ—¥ã€
     deposit_expire_at: depositExpireAt,
     hold_until: holdUntil,

    // â˜… å„ªå…ˆç”¨ net_amountï¼ŒèˆŠè¨‚å–®æ²’æœ‰å°±é€€å› total_amount
    total_amount:
      (f.net_amount !== undefined && f.net_amount !== null && f.net_amount !== "")
        ? Number(f.net_amount || 0)
        : Number(f.total_amount || f.total || 0),

    payment_method: f.payment_method || "",
    customer_type: f.customer_type || "",
    streamer_name: f.streamer_name || "",
    created_at: f.created_at || "",
    shipped_at: f.shipped_at || "",
    credit_used: Number(f.credit_used || 0),
    items_text: (f.items_text || f.Items_text || f["items_text"] || ""),

    ship: {
      name,
      phone,
      method: shipLabel,
      tracking_no: trackingNo,
      store_name: storeName,
      store_addr: storeAddr,
      zip,
      addr,
      deposit_expire_at: depositExpireAt,
      hold_until: holdUntil,
    },
  };
});
    

    return j(env, origin, { ok:true, orders }, 200);
  } catch (e) {
    console.log("member/orders error", e);
    return j(env, origin, { ok:false, error:"member_orders_error", detail:String(e) }, 500);
  }
}
// --- Memberï¼šæŸ¥è©¢è³¼ç‰©é‡‘ / ç´…åˆ©é»æ•¸æ˜ç´°ï¼ˆå«è‡ªå‹•è¨ˆç®—é¤˜é¡ï¼‰ ---
if (req.method === "GET" && path === "/member/credits") {
  try {
    const lineUserId = url.searchParams.get("line_user_id") || "";
    if (!lineUserId) {
      return j(env, origin, { ok:false, error:"missing_line_user_id" }, 400);
    }

    const T = env.AT_CREDITS_LEDGER || "CreditsLedger";

    // æ’ˆæœ€è¿‘ 50 ç­†æ˜ç´°ï¼ˆç”±æ–°åˆ°èˆŠï¼‰
const params = {
  filterByFormula: `{LineUserId}='${escFormula(lineUserId)}'`,
  "sort[0][field]": "CreatedAt",
  "sort[0][direction]": "desc",
  pageSize: "50"
};

    const resAt   = await at(env, "GET", T, "", null, params);
    const records = (resAt && resAt.records) || [];

    const items = records.map((rec) => {
      const f = rec.fields || {};
      return {
        id: rec.id,
        type: f.Type || "",                         // add / use / adjust
        amount: Number(f.Amount || 0),             // æ­£æ•¸ï¼ç™¼æ”¾ã€è² æ•¸ï¼ä½¿ç”¨
        reason: f.Reason || "",
        order_id: f.OrderId || "",
        // âœ… é¡¯ç¤ºç”¨åç¨±ï¼ˆè®“å‰ç«¯ä¸è¦å†çœ‹åˆ° use:OD...ï¼‰
        DisplayName: f.DisplayName || f.display_name || f.displayName || "",
        display_name: f.DisplayName || f.display_name || f.displayName || "",
        status: f.Status || f.status || "",
        created_at:
          f.CreatedAt ||
          f["Created time"] ||
          rec.createdTime ||
          
      };
    });

    // 2) çœŸæ­£çš„é¤˜é¡æ”¹ç”¨ CreditsLedger è‡ªå‹•åŠ ç¸½
    const balance = await getCreditBalance(env, lineUserId);

    return j(env, origin, { ok:true, balance, items });
  } catch (e) {
    console.log("member/credits error", e);
    return j(
      env,
      origin,
      { ok:false, error:"member_credits_error", detail:String(e) },
      500
    );
  }
}

// âœ… ä¿éšªï¼šæŠŠ line_user_id / customer_name å¯«å› CartTokenï¼ˆåªè£œç©ºçš„ï¼Œä¸è¦†è“‹å·²æœ‰å€¼ï¼‰
async function ensureCartIdentity(env, cartToken, lineUserId, customerName) {
  const CT = env.AT_CARTS || "CartToken";
  const token = String(cartToken || "").trim();
  const uid   = String(lineUserId || "").trim();
  const name  = String(customerName || "").trim();
  if (!token) return;

  // æ²’ä»»ä½•å¯å¯«å°±è·³é
  if (!uid && !name) return;

  // ç”¨ CartToken æ¬„ä½æ‰¾å› record
  const rec = await atFindByField(env, CT, "CartToken", token);
  if (!rec || !rec.id) return;

  const f = rec.fields || {};
  const patch = {};

  // åªè£œç©ºçš„ï¼ˆé¿å…ä½ å¾Œé¢å·²ç¶“æ‰‹å‹•ä¿®éçš„è¢«è¦†è“‹ï¼‰
  if (uid && !String(f.line_user_id || "").trim()) patch.line_user_id = uid;
  if (name && !String(f.customer_name || "").trim()) patch.customer_name = name;

  if (Object.keys(patch).length === 0) return;

  await at(env, "PATCH", CT, "", { records: [{ id: rec.id, fields: patch }] });
}

async function countCartItemsByToken(env, cartToken) {
  const T = env.AT_CART_ITEMS || "CartItems";
  const k = escFormula(String(cartToken || "").trim());
  if (!k) return 0;

  // âœ… ä½  CartItems æœ‰ã€Œå…¬å¼æ¬„ä½ã€cart_tokenï¼ˆä½ æˆªåœ–å³é‚Š fx cart_tokenï¼‰
  const rows = await atListAllParams(env, T, {
    filterByFormula: `{cart_token}='${k}'`
  });

  let sum = 0;
  for (const r of (rows || [])) {
    const f = r.fields || {};
    sum += Number(f.Qty ?? f.qty ?? 0) || 0;  // ä½ çš„æ¬„ä½å« Qty
  }
  return sum;
}

// --- Adminï¼šåˆ—å‡ºæœªçµå–®è³¼ç‰©è»Šï¼ˆstatus=open ä¸” Orders æ‰¾ä¸åˆ°åŒ cart_tokenï¼‰ ---
if (req.method === "GET" && path === "/admin/cart/open") {
  if (!requireAdminKey(req, env)) return j(env, origin, { ok:false, error:"forbidden" }, 403);

  const limit = Math.max(1, Math.min(100, parseInt(url.searchParams.get("limit") || "50", 10) || 50));
  const cartsT  = env.AT_CARTS || "CartToken";
  const ordersT = env.AT_ORDERS || "Orders";

  // å…ˆæŠ“ open carts
  const carts = await atListAllParams(env, cartsT, {
    filterByFormula: `AND(OR({status}='open', {status}='submitted'))`,
    maxRecords: String(limit),                 // âœ… ä¿éšªï¼šç¢ºä¿æ˜¯å­—ä¸²/æ•¸å­—éƒ½å¯
    "sort[0][field]": "updated_at",            // âœ… ä½ è‹¥æ²’ updated_at å°±æ”¹ created_at
    "sort[0][direction]": "desc"
  });

  // éæ¿¾æ‰ï¼šå·²ç¶“çµå–®ï¼ˆOrders æœ‰åŒ cart_tokenï¼‰
  const out = [];
  for (const r of (carts || [])) {
    const f = r.fields || {};
    const cartToken = String(f.CartToken || f.cart_token || "").trim();
    if (!cartToken) continue;

    const od = await atFindByField(env, ordersT, "cart_token", cartToken);
    if (od && od.id) continue;

    const itemCount = await countCartItemsByToken(env, cartToken);

out.push({
  cart_token: cartToken,
  status: f.status || "open",
  streamer_name: f.streamer_name || "",
  customer_type: f.customer_type || "",
  line_user_id: f.line_user_id || "",
  customer_name: f.customer_name || "",
  updated_at: f.updated_at || f.updated || f.created_at || "",
  created_at: f.created_at || "",
  closed_at: f.closed_at || "",
  item_count: itemCount
});
  }

  return j(env, origin, { ok:true, carts: out }, 200);
}
                  // --- Adminï¼šè¨‚å–®åˆ—è¡¨ï¼ˆå¾Œå°ç”¨ï¼‰ ---
      if (req.method === "GET" && path === "/admin/orders") {
        const op_key = url.searchParams.get("op_key") || "";
        if (!op_key || String(op_key) !== String(env.OP_KEY)) {
          return j(env, origin, { ok:false, error:"forbidden" }, 403);
        }

        const filter   = url.searchParams.get("filter")    || "";
        const dateFrom = url.searchParams.get("date_from") || "";
        const dateTo   = url.searchParams.get("date_to")   || "";
        const statusQ  = url.searchParams.get("status")    || "";

        const T = env.AT_ORDERS || "Orders";

        // æŠŠ Orders å…¨éƒ¨æŠ“å‡ºä¾†ï¼ˆä¿ç•™ Airtable åŸæœ¬çš„ {id, fields} çµæ§‹ï¼‰
        let all = [];
        let offset;
        const baseParams = {
          pageSize: "100",
          "sort[0][field]": "created_at",
          "sort[0][direction]": "desc"
        };

        do {
          /** @type {any} */
          const params = { ...baseParams };
          if (offset) params.offset = offset;
          const res = await at(env, "GET", T, "", null, params);
          all = all.concat(res.records || []);
          offset = res.offset;
        } while (offset);

        const parseDate = (s) => {
          if (!s) return null;
          const d = new Date(s);
          if (isNaN(d.getTime())) return null;
          return d;
        };

        const fromDate = dateFrom ? new Date(dateFrom + "T00:00:00") : null;
        const toDate   = dateTo   ? new Date(dateTo   + "T23:59:59") : null;

        // ç”¨ fields ä¾†åšç¯©é¸ï¼Œä½†ã€Œå›å‚³æ•´å€‹ recordã€çµ¦å‰ç«¯ï¼Œ
        // é€™æ¨£ admin.html çš„ parseShippingInfo(f) æ‰æ‹¿å¾—åˆ° shipping_info / items_text
        let orders = all.filter(rec => {
          const f = rec.fields || {};

          // æ—¥æœŸç¯„åœ
          if (fromDate || toDate) {
            const d = parseDate(f.created_at);
            if (!d) return false;
            if (fromDate && d < fromDate) return false;
            if (toDate && d > toDate) return false;
          }

          // æ˜ç¢ºæŒ‡å®š statusï¼ˆsubmitted / paid / shipped / cancelledï¼‰
          if (statusQ && f.status !== statusQ) return false;

          // å¿«é€Ÿåˆ†é¡ filter
          if (!filter || filter === "all") return true;

          const pm   = String(f.payment_method || "");
          const ps   = String(f.pay_status || "");
          const ship = String(f.ship_status || f.status || "");

          // ç·šä¸Šä»˜æ¬¾å¾…ç¢ºèª
          if (filter === "pending_online") {
            const isOnline =
  pm.startsWith("paid_") ||
  pm.startsWith("zero_card_") ||
  pm.startsWith("yufu_inst_");
            const isPaidOk = (ps === "paid_ok");
            return isOnline && !isPaidOk;
          }

          // å¾…å‡ºè²¨ï¼ˆå·²ä»˜æ¬¾ä½†é‚„æ²’ shippedï¼‰
          if (filter === "ready_to_ship") {
            const isPaid    = (f.status === "paid") || (ps === "paid_ok");
            const isShipped = (ship === "shipped");
            return isPaid && !isShipped;
          }

          // ATM / è¨‚é‡‘
          if (filter === "deposit") {
            const hasDep =
              !!f.deposit_amount ||
              pm.includes("deposit") ||
              pm.includes("atm") ||
              pm.includes("bank_transfer");
            return hasDep;
          }

          return true;
        });

        // ä¾ created_at æ–°åˆ°èˆŠæ’åº
        orders.sort((a, b) => {
          const fa = a.fields || {};
          const fb = b.fields || {};
          const da = parseDate(fa.created_at);
          const db = parseDate(fb.created_at);
          if (da && db) return db.getTime() - da.getTime();
          if (db) return 1;
          if (da) return -1;
          return 0;
        });

        // å›å‚³ 
        return j(env, origin, { ok:true, orders });
      }

            // --- Adminï¼šæ›´æ–°è¨‚å–®å‡ºè²¨ / ä»˜æ¬¾è³‡è¨Š ---
if (req.method === "POST" && path === "/admin/order/update") {
  const qOp = url.searchParams.get("op_key") || "";
  const b   = await body().catch(()=> ({}));

  const opKey   = b.op_key || qOp;
  const recId   = b.record_id || b.id || null;
  const orderId = b.order_id || null;
  const fields  = b.fields || {};

  // é©—è­‰ OP_KEY
  if (!opKey || String(opKey) !== String(env.OP_KEY)) {
    return j(env, origin, { ok:false, error:"forbidden" }, 403);
  }
  if (!recId && !orderId) {
    return j(env, origin, { ok:false, error:"missing_record_id_or_order_id" }, 400);
  }

  const T = env.AT_ORDERS || "Orders";

  // å…ˆç”¨ record_id æ‰¾ï¼Œæ²’æœ‰å†ç”¨ order_id æ‰¾
  let rec = null;
  if (recId) {
    try {
      rec = await at(env, "GET", T, "/" + recId);
    } catch (e) {
      rec = null;
    }
  }
  if (!rec && orderId) {
    rec = await atFindByField(env, T, "order_id", orderId);
  }
  if (!rec) {
    return j(env, origin, { ok:false, error:"not_found" }, 404);
  }


  // ---- æ­£è¦åŒ–å‰ç«¯æ¬„ä½åç¨± ----
  const incoming = { ...(fields || {}) };

  // âœ… status / ship_status äº’ç›¸ç›¸å®¹ï¼šå‰ç«¯é€å“ªå€‹éƒ½èƒ½å­˜ï¼Œè€Œä¸”å…©å€‹ä¸€èµ·åŒæ­¥
if ("status" in incoming && !("ship_status" in incoming)) {
  incoming.ship_status = incoming.status;
}
if ("ship_status" in incoming && !("status" in incoming)) {
  incoming.status = incoming.ship_status;
}

  // ship_fee â†’ shipping_fee
  if ("ship_fee" in incoming && !("shipping_fee" in incoming)) {
    const v = incoming.ship_fee;
    delete incoming.ship_fee;
    if (v !== undefined && v !== null && v !== "") {
      incoming.shipping_fee = Number(v);
    }
  }

  // ship_tracking / tracking_no â†’ çµ±ä¸€å¯« tracking_no
  if ("ship_tracking" in incoming && !("tracking_no" in incoming)) {
    incoming.tracking_no = incoming.ship_tracking;
  }
  delete incoming.ship_tracking; // ä¸è¦ PATCH ship_tracking é€™å€‹æ¬„ä½

  // ship_atï¼ˆå¾Œå°è¼¸å…¥çš„å‡ºè²¨æ™‚é–“ï¼‰â†’ å¯«é€² shipped_at
  if ("ship_at" in incoming && !("shipped_at" in incoming)) {
    incoming.shipped_at = incoming.ship_at;
  }
  delete incoming.ship_at; // ä¸è¦ PATCH ship_at é€™å€‹æ¬„ä½

  // åªå…è¨±æ›´æ–°é€™å¹¾å€‹æ¬„ä½
const allowed = [
  "status",
  "pay_status","ship_status",
  "tracking_no","shipping_fee","pay_channel",
  "deposit_amount","deposit_last5","deposit_expire_at",
  "hold_until","deposit_received","pay_notice_sent",
  "internal_note","shipped_at",
  "è³£è²¨ä¾¿åç¨±",

  // âœ… è£•å¯Œï¼ˆæ‰‹å‹•ç”³è«‹ç”¨ï¼‰â€” å…è¨±å¾Œå°å¯«å›
  "yufu_name",
  "yufu_idno",
  "yufu_phone",
  "yufu_email",
  "yufu_period",
  "yufu_status",
  "yufu_case_no",
  "yufu_note"
];
  const updateFields = {};
  for (const k of allowed) {
    if (k in incoming) updateFields[k] = incoming[k];
  }

  // å¯«å› Airtable
await at(env, "PATCH", T, "", {
  records: [{ id: rec.id, fields: updateFields }]
});

// â˜… å¾Œå°ã€Œç¢ºèªæ”¶æ¬¾ã€å¾Œï¼šè‹¥è®Šæˆå·²ä»˜æ¬¾ â†’ è‡ªå‹•è£œ pay_channelï¼ˆå«è£•å¯Œï¼‰ï¼‹è£œé–‹ç¶ ç•Œç™¼ç¥¨
try {
  const base = rec.fields || {};
  const oid = String(orderId || base.order_id || "").trim();   // âœ… å¯é çš„ order_id
  const pmLower = String(base.payment_method || "").toLowerCase().trim();

  const payStatusAfter = String(
    (updateFields.pay_status !== undefined ? updateFields.pay_status : base.pay_status) || ""
  ).toLowerCase().trim();

  let payChannelAfter = String(
    (updateFields.pay_channel !== undefined ? updateFields.pay_channel : base.pay_channel) || ""
  ).toLowerCase().trim();

  // âœ… åªå…è¨±é€™ä¸‰é¡è‡ªå‹•é–‹ç¥¨
  const isInvoicePm =
    pmLower.startsWith("paid_") ||
    pmLower.startsWith("zero_card_") ||
    pmLower.startsWith("yufu_inst_");

  // âœ… è‹¥å·²ä»˜æ¬¾ä½† pay_channel ç©ºç™½ï¼šç”¨ payment_method è‡ªå‹•è£œä¸Šï¼ˆåƒ…ä½œç‚ºå ±è¡¨/è¾¨è­˜ç”¨ï¼‰
  if (payStatusAfter === "paid_ok" && !payChannelAfter) {
    if (pmLower.startsWith("paid_"))          payChannelAfter = "payuni";
    else if (pmLower.startsWith("zero_card_")) payChannelAfter = "zero_card";
    else if (pmLower.startsWith("yufu_inst_")) payChannelAfter = "yufu";

    if (payChannelAfter) {
      await at(env, "PATCH", T, "", {
        records: [{ id: rec.id, fields: { pay_channel: payChannelAfter } }]
      });
    }
  }

   // =========================
  // âœ… è£•å¯Œå¯©æ ¸çµæœè‡ªå‹•è½åœ°
  // ä½ å¾Œå°åªè¦æ›´æ–° yufu_statusï¼Œå°±æœƒè‡ªå‹•ï¼š
  // - approved -> paid_ok + æ‰£è³¼ç‰©é‡‘ + é–‹ç¥¨ + ä»˜æ¬¾æˆåŠŸå¡
  // - rejected -> ä½œå»¢è£œå›åº«å­˜ + é€€è³¼ç‰©é‡‘ + ä»˜æ¬¾å¤±æ•—å¡
  // =========================
  const yufuStatusAfter = String(
    (updateFields.yufu_status !== undefined ? updateFields.yufu_status : base.yufu_status) || ""
  ).toLowerCase().trim();

  // åªè™•ç†è£•å¯Œå–®
  const isYufuPm = pmLower.startsWith("yufu_inst_");
  if (isYufuPm && oid && yufuStatusAfter) {
    // é‡æ–°æŠ“æœ€æ–° recï¼ˆé¿å…ä½ ä¸‹é¢ sendPayResultFlex / cancelOrderAsFailed ç”¨åˆ°èˆŠ fieldsï¼‰
    let latest = null;
    try { latest = await atFindByField(env, T, "order_id", oid); } catch (e) {}

    const okSet = new Set(["approved","approve","pass","success","ok"]);
    const failSet = new Set(["rejected","reject","fail","failed","denied","cancel","cancelled"]);

    if (okSet.has(yufuStatusAfter)) {
      // å¦‚æœä½ å¾Œå°æ²’æ‰‹å‹•æ”¹ pay_statusï¼Œä¹Ÿå¹«ä½ è£œæˆ paid_ok
      if (payStatusAfter !== "paid_ok") {
        await at(env, "PATCH", T, "", {
          records: [{
            id: (latest?.id || rec.id),
            fields: { pay_status: "paid_ok", status: "paid", pay_channel: "yufu" }
          }]
        });
      }

      // âœ… paid_okï¼šæ‰£è³¼ç‰©é‡‘ï¼ˆè‹¥æœ‰ï¼‰+ é–‹ç¥¨ + æˆåŠŸå¡
      await spendCreditIfNeeded(env, latest || rec);
      await issueEcpayInvoiceByOrderId(env, oid);
      await sendPayResultFlex(env, latest || rec, { success: true });

    } else if (failSet.has(yufuStatusAfter)) {
      const note = String(updateFields.yufu_note || base.yufu_note || "").trim();

      // âœ… ä½œå»¢ï¼šè£œåº«å­˜ + é€€è³¼ç‰©é‡‘ + cancelled
      await cancelOrderAsFailed(env, latest || rec, "yufu_reject", note);

      // âœ… ç™¼å¤±æ•—å¡ï¼ˆä½ æœƒå¸¶ retryUrl å›åŒä¸€ç­† cart_tokenï¼‰
      await sendPayResultFlex(env, latest || rec, {
        success: false,
        failReason: "è£•å¯Œå¯©æ ¸æœªé€šéï¼Œè¨‚å–®å·²ä½œå»¢ï¼›æ‚¨å¯å›åŸè¨‚å–®æ”¹ç”¨å…¶ä»–ä»˜æ¬¾æ–¹å¼ã€‚"
      });
    }
  }

  // âœ… å·²ä»˜æ¬¾å°±è£œé–‹ç™¼ç¥¨ï¼ˆåªçœ‹ payment_methodï¼Œä¸ä¾è³´ pay_channelï¼‰
  if (payStatusAfter === "paid_ok" && isInvoicePm) {
    let latest2 = null;
    try { if (oid) latest2 = await atFindByField(env, T, "order_id", oid); } catch (e) {}
    await spendCreditIfNeeded(env, latest2 || rec);
    if (oid) await issueEcpayInvoiceByOrderId(env, oid);
  }
} catch (e) {
  console.log("ECPay Invoice (admin confirm-pay) error", orderId, e);
}

return j(env, origin, { ok:true });
}



     // --- Adminï¼šå–æ¶ˆè¨‚å–®ï¼ˆè£œå›åº«å­˜ï¼‰ ---
if (req.method === "POST" && path === "/admin/order/cancel") {
  const qOp = url.searchParams.get("op_key") || "";
  const b   = await body().catch(() => ({}));

  const opKey   = b.op_key || qOp;
  const orderId = b.order_id || "";

  // é©—è­‰ OP_KEY
  if (!opKey || String(opKey) !== String(env.OP_KEY)) {
    return j(env, origin, { ok:false, error:"forbidden" }, 403);
  }
  if (!orderId) {
    return j(env, origin, { ok:false, error:"missing_order_id" }, 400);
  }

  const T = env.AT_ORDERS || "Orders";
  const rec = await atFindByField(env, T, "order_id", orderId);
  if (!rec) {
    return j(env, origin, { ok:false, error:"order_not_found" }, 404);
  }

  const f = rec.fields || {};

  // å·²ç¶“æ˜¯å–æ¶ˆç‹€æ…‹å°±ä¸è¦å†å‹•ï¼ˆé¿å…é‡è¤‡è£œåº«å­˜ï¼‰
  if (String(f.status || "").toLowerCase() === "cancelled") {
    return j(env, origin, { ok:true, already:"cancelled" });
  }

  // âœ… å¾ Orders.items_json é‚„åŸå•†å“æ˜ç´°ï¼›æ²’æœ‰å°±ç”¨ cart_token å› CartItems åæ¨
let items = [];

try {
  if (f.items_json) items = JSON.parse(f.items_json);
} catch (e) {
  items = [];
}

if (!Array.isArray(items) || !items.length) {
  const cartToken = String(f.cart_token || "").trim();
  if (cartToken) {
    try {
      const ci = await listCartItemsAnyToken(env, cartToken);
      items = (ci || []).map(r => {
        const ff = r.fields || {};
        return {
          sku: String(ff.SKU ?? ff.sku ?? "").trim(),
          qty: Number(ff.Qty ?? ff.qty ?? 0) || 0
        };
      }).filter(x => x.sku && x.qty > 0);
    } catch (e) {
      items = [];
    }
  }
}

  // è£œå›åº«å­˜ï¼ˆ+1ï¼‰
  try {
    await adjustStockByItems(env, items || [], +1);
  } catch (e) {
    console.log("adjustStockByItems(+1) error", e);
  }

  try {
    // é‡æ–°æŠ“ä¸€æ¬¡æœ€æ–°è¨‚å–®ï¼ˆä½ ä¸Šé¢ already æœ‰ recï¼‰
    await refundCreditIfNeeded(env, rec, "cancelled");
  } catch (e) {
    console.log("refund credit on cancel error", orderId, e);
  }

  // æŠŠè¨‚å–®æ¨™è¨˜ç‚ºå–æ¶ˆ
  await at(env, "PATCH", T, "", {
    records: [{
      id: rec.id,
      fields: {
        status:     "cancelled",
        pay_status: "cancelled"
      }
    }]
  });

  return j(env, origin, { ok:true });
}

// åŒ¯å‡ºå ±è¡¨æ™‚è¦è¼¸å‡ºçš„æ¬„ä½é †åº
// èªªæ˜ï¼š
// - orders / ship / zero / streamer å…ˆç”¨ []ï¼Œä»£è¡¨ã€Œç…§ Airtable view çš„å…¨éƒ¨æ¬„ä½é †åºã€
// - ä¹‹å¾Œå¦³è¦è‡ªå·±æ’æ¬„ä½æ™‚ï¼Œå†æŠŠ [] è£¡é¢æ”¹æˆæ¬„ä½åç¨±å°±å¯ä»¥
const EXPORT_FIELDS = {
  // ğŸ”¹ å‡ºè²¨æ˜ç´°
  // ç¾åœ¨å…ˆç©ºé™£åˆ— = ç”¨ Airtableã€Œå‡ºè²¨æ˜ç´°ã€view çš„å…¨éƒ¨æ¬„ä½
  orders: [
    "çµå–®å®Œæˆæ™‚é–“",
    "è¨‚å–®ç·¨è™Ÿ",
    "LINEåç¨±",
    "ä»˜æ¬¾æ–¹å¼",
    "æ‡‰ä»˜é‡‘é¡",
    "å•†å“ç·¨è™Ÿ",
    "å•†å“æ˜ç´°",
    "å®¢æˆ¶å‚™è¨»",
    "å‡ºè²¨æ–¹å¼",
    "å‚™è¨»",
    "éƒµéå€è™Ÿ",
    "æ”¶ä»¶åœ°å€",
    "æ”¶ä»¶äººå§“å",
    "æ”¶ä»¶äººé›»è©±",
    "è¶…å•†åº—å",
  ],

  // ğŸ”¹ æœƒè¨ˆå¸«åŒ¯å‡ºï¼ˆé€™å€‹æˆ‘å¹«å¦³å…ˆæ’å¥½ä¸€ç‰ˆï¼Œå¦³è¦å†èª¿æ•´å¯ä»¥æ”¹é€™è£¡ï¼‰
  accounting: [
    "ç™¼ç¥¨æ—¥æœŸï¼ˆç°¡ï¼‰",
    "ç™¼ç¥¨å¹´æœˆ",
    "ç™¼ç¥¨è™Ÿç¢¼",
    "ç™¼ç¥¨æ—¥æœŸ",
    "ç™¼ç¥¨_éš¨æ©Ÿç¢¼",
    "ç™¼ç¥¨_rtn_code",
    "ç™¼ç¥¨_rtn_msg",
    "ç™¼ç¥¨å“å",
    "ç™¼ç¥¨é‡‘é¡_å«ç¨…",
    "ç™¼ç¥¨é‡‘é¡_æœªç¨…",
    "ç™¼ç¥¨_ç‡Ÿæ¥­ç¨…é¡",
    "ç¨…åˆ¥",
    "æ”¶ä»¶äººå§“å",
    "ä»˜æ¬¾æ–¹å¼",
    "å‡ºè²¨æ–¹å¼",
    "æ”¶ä»¶äººå§“å",
    "æ”¶ä»¶äººé›»è©±",
    "æ”¶ä»¶äºº Email",
  ],

  // ğŸ”¹ å‡ºè²¨æ˜ç´°ï¼è³£è²¨ä¾¿ï¼ˆå°æ‡‰ Airtableã€Œè³£è²¨ä¾¿æ˜ç´°åŒ¯å‡ºã€viewï¼‰
  ship: [
    "order_id",
    "çµå–®å®Œæˆæ™‚é–“",
    "æ”¶ä»¶äººå§“å",
    "æ”¶ä»¶äººé›»è©±",
    "è¶…å•†åº—è™Ÿ",
    "è³£è²¨ä¾¿æ¬„ä½å°ˆç”¨",
    "è³£è²¨ä¾¿æ¬„ä½å°ˆç”¨2",
    "æ‡‰ä»˜é‡‘é¡",
    "è³£è²¨ä¾¿æ¬„ä½å°ˆç”¨3",
    "å›å¡«é‹è²»",
    "å–®è™Ÿé€šçŸ¥ç™»è¨˜",
  ],

  // ğŸ”¹ 0 å…ƒåŒ…è£¹æ˜ç´°ï¼ˆå°æ‡‰ Airtableã€Œ0å…ƒåŒ…è£¹æ˜ç´°åŒ¯å‡ºã€viewï¼‰
  zero: [
    "order_id",
    "çµå–®å®Œæˆæ™‚é–“",
    "æ”¶ä»¶äººå§“å",
    "æ”¶ä»¶äººé›»è©±",
    "Email",
    "è¶…å•†åº—è™Ÿ",
    "0å…ƒåŒ…è£¹é‹è²»",
    "0å…ƒåŒ…è£¹å–®è™Ÿ",
  ],

  // ğŸ”¹ ç›´æ’­ä¸»çµç®—å–®ï¼ˆå°æ‡‰ Airtableã€Œç›´æ’­ä¸»çµç®—å–®ã€viewï¼‰
  streamer: [
    "å‡ºè²¨æ™‚é–“_å°ç£",
    "ç›´æ’­ä¸»",
    "æ‡‰ä»˜é‡‘é¡",
  ],
  // â† æ–°å¢ï¼šæ·¨åˆ©çµç®—ï¼Œæ¬„ä½é †åºç…§ view
  net: [
    "è¨‚å–®ç·¨è™Ÿ",
    "ç›´æ’­ä¸»",
    "æ‡‰ä»˜é‡‘é¡",
    "æœ¬å–®_å•†å“ç¸½æˆæœ¬",
    "ä»˜æ¬¾æ–¹å¼",
    "ä»˜æ¬¾æ‰‹çºŒè²»ç‡",
    "ä»˜æ¬¾æ‰‹çºŒè²»é¡",
    "å‡ºè²¨æ–¹å¼",
    "ç‰©æµæˆæœ¬",
    "ç™¼ç¥¨è™Ÿç¢¼",
    "ç™¼ç¥¨_ç‡Ÿæ¥­ç¨…é¡",
    "ç¸½æ·¨åˆ©(å«ç™¼ç¥¨ç¨…)",
    "å‡ºè²¨å®Œæˆ",
  ],

  //  å–æ¶ˆè¨‚å–®æ·¨åˆ©è¡¨ï¼ˆå°æ‡‰ Airtableã€Œå–æ¶ˆè¨‚å–®æ·¨åˆ©è¡¨ã€viewï¼‰
  cancel_net: [          // â† ä½ å‰é¢åšçš„å…¬å¼æ¬„ä½
    "è¨‚å–®ç·¨è™Ÿ",
    "ç›´æ’­ä¸»",
    "æ‡‰ä»˜é‡‘é¡",
    "æœ¬å–®_å•†å“ç¸½æˆæœ¬",
    "ä»˜æ¬¾æ–¹å¼",
    "ä»˜æ¬¾æ‰‹çºŒè²»ç‡",
    "ä»˜æ¬¾æ‰‹çºŒè²»é¡",
    "å‡ºè²¨æ–¹å¼",
    "ç‰©æµæˆæœ¬",
    "ç™¼ç¥¨è™Ÿç¢¼",
    "ç™¼ç¥¨_ç‡Ÿæ¥­ç¨…é¡",
    "ç¸½æ·¨åˆ©(å«ç™¼ç¥¨ç¨…)",
    "å–æ¶ˆå®Œæˆ",
    "å‡ºè²¨å®Œæˆ",   // â˜… æ–°å¢
    "å–æ¶ˆæ·¨åˆ©",   // â˜… æ–°å¢ï¼ˆä½ å‰›å‰›é‚£å€‹å…¬å¼æ¬„ï¼‰
  ],
};


// â˜… åŒ¯å‡º / é è¦½ Airtable viewï¼ˆç¸½è¨‚å–® / æœƒè¨ˆå¸« / å‡ºè²¨æ˜ç´° / 0å…ƒåŒ…è£¹ï¼‰
// æ”¯æ´ï¼š?kind=orders|accounting|ship|zero &date_from=YYYY-MM-DD &date_to=YYYY-MM-DD &format=json|csv
if (req.method === "GET" && path === "/admin/export-view") {
  const key = (url.searchParams.get("key") || url.searchParams.get("op_key") || "").trim();
if (!key || key !== String(env.OP_KEY || "").trim()) {
  return new Response("Unauthorized", { status: 401 });
}

  const kind   = url.searchParams.get("kind")   || "";
  const format = url.searchParams.get("format") || "csv"; // csv | json

  // æ—¥æœŸç¯©é¸ï¼ˆå…¨éƒ¨éƒ½ç”¨ created_at é€™å€‹æ¬„ä½ä¾†åˆ¤æ–·ï¼‰
  const dateFrom = url.searchParams.get("date_from") || "";
  const dateTo   = url.searchParams.get("date_to")   || "";

  let table, viewName, filename;

  switch (kind) {
    case "orders":
      table    = env.AT_ORDERS || "Orders";
      viewName = env.EXPORT_VIEW_ORDERS || "å‡ºè²¨æ˜ç´°";
      filename = "orders-all";
      break;

    case "accounting":
      table    = env.AT_ORDERS || "Orders";
      viewName = env.EXPORT_VIEW_ACCOUNTING || "æœƒè¨ˆå¸«åŒ¯å‡º";
      filename = "orders-accounting";
      break;

    case "ship":
      table    = env.AT_ORDERS || "Orders";
      viewName = env.EXPORT_VIEW_SHIP || "è³£è²¨ä¾¿æ˜ç´°åŒ¯å‡º";
      filename = "order-items-ship";
      break;

    case "zero":
      table    = env.AT_ORDERS || "Orders";
      viewName = env.EXPORT_VIEW_ZERO || "0å…ƒåŒ…è£¹æ˜ç´°åŒ¯å‡º";
      filename = "order-items-zero";
      break;

    case "streamer":
      table    = env.AT_ORDERS || "Orders";
      viewName = env.EXPORT_VIEW_STREAMER || "ç›´æ’­ä¸»çµç®—å–®";
      filename = "orders-streamer";
      break;

    case "net":
      table    = env.AT_ORDERS || "Orders";
      viewName = "æ·¨åˆ©çµç®—";          // ç¾åœ¨ç”¨çš„ view
      filename = "orders-net";
      break;

    case "cancel_net":
      table    = env.AT_ORDERS || "Orders";
      viewName = "å–æ¶ˆè¨‚å–®æ·¨åˆ©è¡¨";    // â˜… Airtable view åç¨±
      filename = "orders-cancel-net";
      break;

    default:
      return new Response("bad_kind", { status: 400 });
  }
  

    // âœ… å–æŒ‡å®š view çš„å…¨éƒ¨è³‡æ–™ï¼ˆè‡ªå‹•ç¿»é ï¼Œé¿å…åªæ‹¿åˆ°å‰ 100 ç­†ï¼‰
const allRecords = await atListAllParams(env, table, {
  view: viewName,
  pageSize: "100"
});

        // æ—¥æœŸç¯„åœéæ¿¾ï¼šä¾åŒ¯å‡ºç¨®é¡ kind ä½¿ç”¨ä¸åŒæ™‚é–“æ¬„ä½
  const parseDate = (s) => {
    if (!s) return null;
    const d = new Date(s);
    return isNaN(d.getTime()) ? null : d;
  };

  const fromDate = dateFrom ? new Date(dateFrom + "T00:00:00") : null;
  const toDate   = dateTo   ? new Date(dateTo   + "T23:59:59") : null;

  // ä¾ kind é¸æ“‡è¦çœ‹çš„ã€Œæ™‚é–“æ¬„ä½ã€
  let dateField = "";

  switch (kind) {
    // å‡ºè²¨æ˜ç´° / è³£è²¨ä¾¿ / 0å…ƒåŒ…è£¹ â†’ ç”¨çµå–®å®Œæˆæ™‚é–“
    case "orders":
    case "ship":
    case "zero":
      dateField = "çµå–®å®Œæˆæ™‚é–“";
      break;

    // ç›´æ’­ä¸»çµç®—å–® / æ·¨åˆ©çµç®— â†’ å‡ºè²¨æ™‚é–“_å°ç£
    case "streamer":
    case "net":
      dateField = "å‡ºè²¨æ™‚é–“_å°ç£";
      break;

      case "cancel_net":
      dateField = "å–æ¶ˆæ™‚é–“";   // â˜… ç”¨å–æ¶ˆæ™‚é–“
      break;

    // æœƒè¨ˆå¸«åŒ¯å‡º â†’ ç™¼ç¥¨æ—¥æœŸï¼ˆç°¡ï¼‰
    case "accounting":
      dateField = "ç™¼ç¥¨æ—¥æœŸï¼ˆç°¡ï¼‰";
      break;

    default:
      dateField = "çµå–®å®Œæˆæ™‚é–“";
      break;
  }

  const inDateRange = (rec) => {
    if (!fromDate && !toDate) return true;

    const f = rec.fields || {};

    // å…ˆç”¨æŒ‡å®šæ¬„ä½ï¼›æ²’æœ‰å€¼å°±é€€å›åŸæœ¬çš„ created_at / CreatedAt / invoice_date
    const raw =
      (dateField && f[dateField]) ||
      f.created_at ||
      f.CreatedAt ||
      f.invoice_date;

    const d = parseDate(raw);
    if (!d) return false;
    if (fromDate && d < fromDate) return false;
    if (toDate   && d > toDate)   return false;
    return true;
  };

  const records = allRecords.filter(inDateRange);
  // ===== [PATCH] ordersï¼šè£œé½Šåˆ—å°å‡ºè²¨å–®éœ€è¦çš„æ¬„ä½ï¼ˆLINEåç¨±/åœ°å€/çµå–®æ™‚é–“/å•†å“ç·¨è™Ÿ...ï¼‰ =====
const safeJsonParseLocal = (s, fallback = {}) => {
  try {
    if (!s) return fallback;
    if (typeof s === "object") return s;
    return JSON.parse(String(s));
  } catch (e) { return fallback; }
};
const firstNonEmptyLocal = (...vals) => {
  for (const v of vals) {
    const t = String(v ?? "").trim();
    if (t) return t;
  }
  return "";
};

const enrichOrderFields = (f = {}) => {
  // å– shipping_infoï¼ˆä½  Orders è‹¥æœ‰æ”¾ JSONï¼Œé€™è£¡å°±èƒ½è£œåœ°å€/LINE åç¨±/é–€å¸‚ï¼‰
  const si = safeJsonParseLocal(
    f.shipping_info || f.shippingInfo || f.ShippingInfo || f["æ”¶ä»¶è³‡è¨Š"] || f["æ”¶ä»¶è³‡æ–™"] || "",
    {}
  );

  const ship  = si.ship  || {};
  const store = ship.store || {};
  const post  = ship.post  || {};

  // LINE åç¨±ï¼šå…ˆåƒæ¬„ä½ï¼Œä¸è¡Œæ‰åƒ shipping_info
  const lp = si.line_profile || si.lineProfile || si.line || {};
  const lineName = firstNonEmptyLocal(
    f["LINEåç¨±"],
    f["LINE åç¨±"],
    f["line_name"],
    lp.displayName,
    lp.display_name,
    lp.name
  );

  // åœ°å€/éƒµéå€è™Ÿï¼šå…ˆåƒæ¬„ä½ï¼Œæ²’æœ‰æ‰åƒ shipping_info
  let zip  = firstNonEmptyLocal(f["éƒµéå€è™Ÿ"], post.zip);
  let addr = firstNonEmptyLocal(f["æ”¶ä»¶åœ°å€"], post.addr);

  // 711ï¼šæ²’æœ‰ zip å¾ˆæ­£å¸¸ï¼›åœ°å€ç”¨é–€å¸‚åœ°å€ï¼ˆè‹¥ä½ æœ‰å­˜ï¼‰
  const shipTypeRaw = firstNonEmptyLocal(f["å‡ºè²¨æ–¹å¼"], ship.type);
  const shipType = (() => {
    const t = String(shipTypeRaw || "").toLowerCase();
    if (t === "711") return "7-11 è¶…å•†å–è²¨";
    if (t === "post") return "éƒµå¯„";
    if (t === "meetup") return "é¢äº¤";
    return String(f["å‡ºè²¨æ–¹å¼"] || "");
  })();

  const storeName = firstNonEmptyLocal(f["è¶…å•†åº—å"], store.name);

  // items_json å¯èƒ½æ˜¯ array / object / string
let itemsObj = null;
try {
  const rawItems = f["items_json"] || f["itemsJson"] || f["ItemsJSON"] || "";
  if (rawItems) {
    itemsObj = (typeof rawItems === "object") ? rawItems : JSON.parse(String(rawItems));
  }
} catch (e) {
  itemsObj = null;
}

const skuFromItems = (() => {
  const pick = (it) => String(it?.sku || it?.SKU || it?.Sku || "").trim();
  if (!itemsObj) return "";

  if (Array.isArray(itemsObj)) {
    const skus = itemsObj.map(pick).filter(Boolean);
    return skus.length ? skus.join(",") : "";
  }

  if (typeof itemsObj === "object") {
    if (Array.isArray(itemsObj.items)) {
      const skus = itemsObj.items.map(pick).filter(Boolean);
      return skus.length ? skus.join(",") : "";
    }
    return pick(itemsObj);
  }

  return "";
})();

const sku = firstNonEmptyLocal(
  f["å•†å“ç·¨è™Ÿ"],
  f["SKU"],
  f["sku"],
  f["å•†å“SKU"],
  skuFromItems
);

  // çµå–®å®Œæˆæ™‚é–“ï¼šä½ ç¾åœ¨çš„ view å¯èƒ½æ²’åå‡ºä¾†ï¼Œä½† Orders è£¡é€šå¸¸æœ‰
  const doneAt = firstNonEmptyLocal(
    f["çµå–®å®Œæˆæ™‚é–“"],
    f.done_at,
    f.paid_at,
    f.created_at,
    f.CreatedAt
  );

  // å›å¡«ï¼ˆåªåœ¨ç¼ºçš„æ™‚å€™è£œï¼Œé¿å…è¦†è“‹ä½ åŸæœ¬ Airtable æ¬„ä½ï¼‰
  if (!f["LINEåç¨±"] && lineName) f["LINEåç¨±"] = lineName;
  if (!f["çµå–®å®Œæˆæ™‚é–“"] && doneAt) f["çµå–®å®Œæˆæ™‚é–“"] = doneAt;
  if (!f["éƒµéå€è™Ÿ"] && zip) f["éƒµéå€è™Ÿ"] = zip;
  if (!f["æ”¶ä»¶åœ°å€"] && addr) f["æ”¶ä»¶åœ°å€"] = addr;
  if (!f["è¶…å•†åº—å"] && storeName) f["è¶…å•†åº—å"] = storeName;
  if (!f["å‡ºè²¨æ–¹å¼"] && shipType) f["å‡ºè²¨æ–¹å¼"] = shipType;
  if (!f["å•†å“ç·¨è™Ÿ"] && sku) f["å•†å“ç·¨è™Ÿ"] = sku;

  return f;
};

// åªå° kind=orders åšè£œæ¬„ä½ï¼ˆä¸å½±éŸ¿ accounting / net / streamerï¼‰
if (kind === "orders") {
  for (const rec of records) {
    rec.fields = enrichOrderFields(rec.fields || {});
  }
}
// ===== [PATCH END] =====


  if (!records.length) {
    if (format === "json") {
      return j(env, origin, { ok: true, kind, total: 0, records: [] });
    }
    return new Response("no_data", { status: 404 });
  }

  // ä¾ kind æ±ºå®šæ¬„ä½é †åº
  let fieldNames;
  const cfg = EXPORT_FIELDS[kind];

  if (Array.isArray(cfg) && cfg.length > 0) {
    fieldNames = cfg.slice(); // ä¾‹å¦‚ accounting å°±ç”¨ä½ è¨­å®šçš„æ¬„ä½é †åº
  } else {
    const firstFields = records[0].fields || {};
    fieldNames = Object.keys(firstFields); // å…¶ä»– kind = å…¨éƒ¨æ¬„ä½
  }

  // ===== [PATCH] ordersï¼šå³ä½¿ EXPORT_FIELDS æ²’åˆ—ï¼Œä¹Ÿå¼·åˆ¶æŠŠåˆ—å°éœ€è¦çš„æ¬„ä½åŠ å…¥è¼¸å‡º =====
if (kind === "orders") {
  const must = [
    "è¨‚å–®ç·¨è™Ÿ",
    "çµå–®å®Œæˆæ™‚é–“",
    "LINEåç¨±",
    "å‡ºè²¨æ–¹å¼",
    "ä»˜æ¬¾æ–¹å¼",
    "æ‡‰ä»˜é‡‘é¡",
    "å•†å“ç·¨è™Ÿ",
    "å•†å“æ˜ç´°",
    "å®¢æˆ¶å‚™è¨»",
    "å‚™è¨»",
    "æ”¶ä»¶äººå§“å",
    "æ”¶ä»¶äººé›»è©±",
    "éƒµéå€è™Ÿ",
    "æ”¶ä»¶åœ°å€",
    "è¶…å•†åº—å"
  ];

  // è®“ must ä¾ç…§é€™å€‹é †åºåœ¨æœ€å‰é¢ï¼Œå…¶ä»–æ¬„ä½æ¥åœ¨å¾Œé¢ï¼ˆä¸ä¸Ÿæ¬„ä½ï¼‰
  const rest = fieldNames.filter(n => !must.includes(n));
  fieldNames = [...must, ...rest];
}
// ===== [PATCH END] =====

  // format=jsonï¼šçµ¦ admin_exports é è¦½ç”¨ï¼Œä¹Ÿä¾æ¬„ä½é †åºé‡çµ„ä¸€æ¬¡
  if (format === "json") {
    const orderedRecords = records.map((rec) => {
      const f = rec.fields || {};
      const newFields = {};
      fieldNames.forEach((name) => {
        if (Object.prototype.hasOwnProperty.call(f, name)) {
          newFields[name] = f[name];
        }
      });
      return { ...rec, fields: newFields };
    });

    return j(env, origin, {
      ok: true,
      kind,
      total: orderedRecords.length,
      records: orderedRecords,
    });
  }

  // ä¸‹é¢æ˜¯ CSV
  const toCell = (v) => {
    if (v === null || v === undefined) return '""';
    return '"' + String(v).replace(/"/g, '""') + '"';
  };

  const lines = [];

  // æ¨™é¡Œåˆ—ï¼šç›®å‰å…ˆç”¨æ¬„ä½ key ç•¶æ¬„å
  lines.push(fieldNames.map((name) => toCell(name)).join(","));

  // æ¯ä¸€åˆ—
  for (const rec of records) {
    const f = rec.fields || {};
    const row = fieldNames.map((name) => toCell(f[name])).join(",");
    lines.push(row);
  }

  const csv = lines.join("\r\n");

  const now = new Date();
  const ts  = now.toISOString().replace(/[:T]/g, "-").slice(0, 16);
  const fname = `${filename || ("export-" + kind)}_${ts}.csv`;

  return new Response("\ufeff" + csv, {
    status: 200,
    headers: {
      "Content-Type": "text/csv; charset=utf-8",
      "Content-Disposition": `attachment; filename="${fname}"`,
    },
  });
}


// --- Adminï¼šæŸ¥è©¢ã€Œä»Šæ—¥å°¾æ¬¾æé†’ï¼ˆä¿ç•™åˆ°æœŸï¼‰ã€æ¸…å–® ---
if (req.method === "GET" && path === "/admin/deposit/remind-today") {
  const opKey = url.searchParams.get("op_key") || "";
  if (!opKey || String(opKey) !== String(env.OP_KEY)) {
    return j(env, origin, { ok:false, error:"forbidden" }, 403);
  }

  const T = env.AT_ORDERS || "Orders";
  const records = await atListAll(env, T);

  const today = new Date();
  const yyyy = today.getFullYear();
  const mm   = String(today.getMonth()+1).padStart(2,'0');
  const dd   = String(today.getDate()).padStart(2,'0');
  const todayStr = `${yyyy}-${mm}-${dd}`;

  const list = [];

  for (const rec of records) {
    const f = rec.fields || {};

    const hasDeposit  = Number(f.deposit_amount || 0) > 0; // æœ‰è¨‚é‡‘
    const depReceived = !!f.deposit_received;              // è¨‚é‡‘å·²æ”¶åˆ°
    const status      = String(f.status || "");
    const payStatus   = String(f.pay_status || "");
    const holdUntil   = (f.hold_until || "").slice(0,10);

    // æ¢ä»¶ï¼šä»Šå¤©ä¿ç•™åˆ°æœŸï¼‹è¨‚é‡‘å·²æ”¶ï¼‹å°¾æ¬¾æœªçµæ¸…
    if (!hasDeposit) continue;
    if (!depReceived) continue;
    if (status === "cancelled") continue;
    if (holdUntil !== todayStr) continue;
    if (payStatus === "paid_ok") continue;

    // â˜… é€™è£¡ä¹Ÿæ”¹æˆç”¨ net_total = total_amount - credit_used
    const grossTotal = Number(f.total_amount || 0) || 0;
    const creditUsed = Number(f.credit_used || 0) || 0;
    const netTotal   = grossTotal - creditUsed;
    const dep        = Number(f.deposit_amount || 0) || 0;

    let tailAmount = 0;
    if (netTotal > dep) {
      tailAmount = netTotal - dep;
    }

    list.push({
      id: rec.id,
      order_id: f.order_id || "",
      name: f.ship_name || "",
      phone: f.ship_phone || "",
      amount: tailAmount,      // å°¾æ¬¾é‡‘é¡ï¼ˆå·²æ‰£è³¼ç‰©é‡‘ï¼‰
      deposit_amount: dep,
      total_amount: netTotal,  // å»ºè­°é€™è£¡æ”¾å¯¦éš›æ‡‰æ”¶ï¼Œæ¯”è¼ƒå¥½çœ‹
      hold_until: holdUntil
    });
  }

  return j(env, origin, { ok:true, date:todayStr, records:list });
}

      


      // --- Create cart ---
      if (req.method === "POST" && path === "/cart/create"){
        const { streamer_name="", line_user_id="",        // âœ… æ–°å¢ï¼ˆå¯é¸ï¼‰
        customer_name="", customer_type="live" } = await body();
        const cart_token = (crypto.randomUUID ? crypto.randomUUID() : rid("ct_")).replace(/-/g,"");
        await ensureCart(env, cart_token, streamer_name, customer_type, line_user_id, customer_name);
        return j(env, origin, { ok:true, cart_token });
      }

      // --- Product lookup ---
      const mProd = path.match(/^\/product\/([^/]+)$/);
      if (req.method === "GET" && mProd){
        const sku = decodeURIComponent(mProd[1]);
        const p = await getProductBySKU(env, sku);
        if (!p) return j(env, origin, { found:false }, 404);
        return j(env, origin, { found:true, product:p });
      }

      // --- Get cart ---
      const mCart = path.match(/^\/cart\/([A-Za-z0-9_]+)$/);
      if (req.method === "GET" && mCart){
        const cart_token = mCart[1];
        const list = await cartItems(env, cart_token);
        const sum = sumCart(list);
        return j(env, origin, { cart_token, items: sum.items, total_amount: sum.total });
      }

      // --- Get cart by order_id (OP only) ---
// GET /op/cart/by-order?order_id=OD...
if (req.method === "GET" && path === "/op/cart/by-order") {
  const qs = new URL(req.url).searchParams;
  const order_id = String(qs.get("order_id") || "").trim();
  const op_key   = String(qs.get("op_key") || "").trim();

  if (!order_id) return j(env, origin, { ok:false, error:"missing order_id" }, 400);

  // âœ… åªå…è¨± OP
  const okOp = op_key && env.OP_KEY && op_key === String(env.OP_KEY);
  if (!okOp) return j(env, origin, { ok:false, error:"forbidden" }, 403);

  // å¾ Orders ç”¨ order_id æ‰¾åˆ° cart_token
  const T = env.AT_ORDERS || "Orders";
  const rec = await atFindByField(env, T, "order_id", order_id);
  const f = rec?.fields || {};
  const cart_token = String(f.cart_token || "").trim();

  if (!cart_token) {
    return j(env, origin, { ok:false, error:"cart_token_not_found", order_id }, 404);
  }

  // å›å‚³å¿…è¦è³‡è¨Šï¼ˆé–‹å–®é å¯ç”¨ï¼‰
  return j(env, origin, {
    ok: true,
    order_id,
    cart_token,
    line_user_id: f.line_user_id || "",
    status: f.status || "",
    pay_status: f.pay_status || f.payment_status || ""
  });
}

      // --- Add item ---
      if (req.method === "POST" && path === "/cart/add"){
        const { cart_token, sku, qty=1, price=null, op_key=null, line_user_id="", customer_name="" } = await body();
        if (!cart_token || !sku) return j(env, origin, { ok:false, error:"missing cart_token/sku" }, 400);
        await ensureCart(env, cart_token, "", "live", line_user_id, customer_name);
        const p = await getProductBySKU(env, sku);
        if (!p) return j(env, origin, { ok:false, error:"product_not_found" }, 404);
        const canOverride = op_key && env.OP_KEY && String(op_key)===String(env.OP_KEY);
        const usePrice = canOverride && (price!=null) ? Number(price) : Number(p.price||0);
        await upsertCartItem(env, cart_token, p.sku, p.name, usePrice, Number(qty||1));
        const list = await cartItems(env, cart_token);
        const sum = sumCart(list);
        return j(env, origin, { ok:true, cart_token, items: sum.items, total_amount: sum.total });
      }
      // ===== Member: å–å¾—å°¾æ¬¾ LIFF é€£çµï¼ˆèµ°å¾Œç«¯ buildTailCheckoutUrlï¼‰=====
// GET /order/tail/url?order_id=OD...&line_user_id=U...
if (req.method === "GET" && path === "/order/tail/url") {
  const u = new URL(req.url);
  const order_id = (u.searchParams.get("order_id") || "").trim();
  const line_user_id = (u.searchParams.get("line_user_id") || "").trim();

  if (!order_id) {
    return j(env, origin, { ok: false, error: "order_id_required" }, 400);
  }
  if (!line_user_id) {
    return j(env, origin, { ok: false, error: "line_user_id_required" }, 400);
  }

  // 1) æ‰¾è¨‚å–®
  const T = env.AT_ORDERS || "Orders";
  const rows = await atListByField(env, T, "order_id", order_id);
  const rec = rows && rows[0];
  if (!rec) {
    return j(env, origin, { ok: false, error: "order_not_found" }, 404);
  }

  const f = rec.fields || {};

  // âœ… 2) ç”¨ä½ ç¾å ´æ¬„ä½ï¼šline_user_id é©—è­‰è¨‚å–®æ­¸å±¬
  const owner = String(f.line_user_id || "").trim();

  // æ²’å­˜ owner å°±æ‹’çµ•ï¼ˆé¿å…è¢«çŒœå–®è™Ÿæ‹¿èµ°é€£çµï¼‰
  if (!owner) {
    return j(env, origin, { ok: false, error: "order_owner_missing" }, 403);
  }
  if (owner !== line_user_id) {
    return j(env, origin, { ok: false, error: "forbidden" }, 403);
  }

  // 3) ç”¨ä½ æ—¢æœ‰çš„è¤‡é›œè¦å‰‡ç”¢ç”Ÿå°¾æ¬¾ LIFF URL
  const url = buildTailCheckoutUrl(env, order_id);
  if (!url) {
    return j(env, origin, { ok: false, error: "tail_url_build_failed" }, 500);
  }

  return j(env, origin, { ok: true, order_id, url }, 200);
}

            // --- OPï¼šç™¼é€ã€Œå°¾æ¬¾çµå¸³é€£çµã€Flex å¡ç‰‡ ---
if (req.method === "POST" && path === "/op/tail/send-link") {
  try {
    const { op_key, order_id, line_user_id, tail_amount } = await body();

    // 1. é©—è­‰é‡‘é‘°
    if (!op_key || String(op_key) !== String(env.OP_KEY)) {
      return j(env, origin, { ok: false, error: "forbidden" }, 403);
    }

    // 2. æª¢æŸ¥å¿…è¦åƒæ•¸
    if (!order_id) return j(env, origin, { ok: false, error: "missing_order_id" }, 400);
    if (!line_user_id) return j(env, origin, { ok: false, error: "missing_line_user_id" }, 400);

    // 3. çµ„åˆå°¾æ¬¾çµå¸³é€£çµï¼ˆè·Ÿ Cron å®Œå…¨ä¸€è‡´ï¼šèµ°ç¶²é  tail-checkout.htmlï¼‰
    const url = buildTailCheckoutUrl(env, order_id);
if (!url) {
  return j(env, origin, { ok:false, error:"invalid_order_id_for_link" }, 400);
}

    // 4. å®šç¾© XUYUAN é»‘é‡‘é¢¨æ ¼ Flex Message
    const flexMessage = {
      type: "flex",
      altText: "XUYUAN å°¾æ¬¾çµå¸³é€šçŸ¥",
      contents: {
        type: "bubble",
        size: "middle",
        body: {
          type: "box",
          layout: "vertical",
          backgroundColor: "#050505", // æ¥µç°¡é»‘èƒŒæ™¯
          paddingAll: "20px",
          contents: [
            // Brand Logo
            {
              type: "text",
              text: "XUYUAN",
              color: "#D4AF37", // å“ç‰Œé‡‘
              weight: "bold",
              size: "xs",
              align: "center"
            },
            // Title
            {
              type: "text",
              text: "Final Payment",
              color: "#ffffff",
              size: "xl",
              weight: "bold",
              align: "center",
              margin: "md",
              wrap: true
            },
            {
              type: "text",
              text: "å°¾æ¬¾çµå¸³é€šçŸ¥",
              color: "#888888",
              size: "xs",
              align: "center",
              margin: "sm"
            },
            // Divider
            {
              type: "separator",
              margin: "xl",
              color: "#333333"
            },
            // Info Rows
            {
              type: "box",
              layout: "vertical",
              margin: "xl",
              spacing: "sm",
              contents: [
                {
                  type: "box",
                  layout: "baseline",
                  contents: [
                    { type: "text", text: "è¨‚å–®ç·¨è™Ÿ", color: "#888888", size: "sm", flex: 0 },
                    { type: "text", text: order_id, color: "#ffffff", size: "sm", align: "end" }
                  ]
                },
                {
                  type: "box",
                  layout: "baseline",
                  contents: [
                    { type: "text", text: "æ‡‰ä»˜å°¾æ¬¾", color: "#888888", size: "sm", flex: 0 },
                    { 
                      type: "text", 
                      text: `NT$ ${Number(tail_amount || 0).toLocaleString()}`, 
                      color: "#D4AF37", // é‡‘è‰²å¼·èª¿é‡‘é¡
                      size: "md", 
                      align: "end",
                      weight: "bold" 
                    }
                  ]
                }
              ]
            }
          ]
        },
        footer: {
          type: "box",
          layout: "vertical",
          backgroundColor: "#050505",
          paddingAll: "20px",
          paddingTop: "0px",
          contents: [
            {
              type: "button",
              style: "primary",
              color: "#D4AF37", // é‡‘è‰²æŒ‰éˆ•
              height: "sm",
              action: {
                type: "uri",
                label: "å‰å¾€çµå¸³",
                uri: url
              }
            },
            {
              type: "text",
              text: "Secure Payment",
              color: "#444444",
              size: "xxs",
              align: "center",
              margin: "md"
            }
          ]
        },
        styles: {
          footer: {
            separator: false
          }
        }
      }
    };

    // 5. ç›´æ¥ç™¼é€ (å–ä»£åŸæœ¬çš„ sendFlexMessage å‡½å¼å‘¼å«)
    const lineRes = await fetch("https://api.line.me/v2/bot/message/push", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${env.LINE_CHANNEL_ACCESS_TOKEN}`
      },
      body: JSON.stringify({
        to: line_user_id,
        messages: [flexMessage]
      })
    });

    if (!lineRes.ok) {
      const errText = await lineRes.text();
      console.error("LINE API Error:", errText);
      return j(env, origin, { ok: false, error: "line_push_failed", details: errText }, 500);
    }

    return j(env, origin, { ok: true });

  } catch (e) {
    console.log("OP /op/tail/send-link error", e);
    return j(env, origin, { ok: false, error: "internal_error" }, 500);
  }
}
            // --- OPï¼šç”¨ LINE åç¨± / æœ¬å æŸ¥è©¢ LineMembers ---
if (req.method === "POST" && path === "/op/line-member/search") {
  const bodyJson = await body();
  const op_key   = bodyJson && bodyJson.op_key;
  const keyword  = (bodyJson && bodyJson.keyword || "").trim();

  // é©—è­‰ OP_KEY
  if (!op_key || String(op_key) !== String(env.OP_KEY)) {
    return j(env, origin, { ok: false, error: "forbidden" }, 403);
  }
  if (!keyword) {
    return j(env, origin, { ok: false, error: "missing_keyword" }, 400);
  }

  const T = env.AT_LINE_MEMBERS || "LineMembers";

  // å…ˆç”¨ DisplayName ç²¾æº–æ¯”å°
  let list = await atListByField(env, T, "DisplayName", keyword);

  // å¦‚æœæ‰¾ä¸åˆ°ï¼Œå†ç”¨ Name è©¦ä¸€æ¬¡
  if (!list || !list.length) {
    list = await atListByField(env, T, "Name", keyword);
  }

  if (!list || !list.length) {
    return j(env, origin, { ok: false, error: "not_found" }, 404);
  }

  const rec = list[0];
  const f   = (rec && rec.fields) || {};

  const member = {
    lineUserId:   f.LineUserId   || "",
    displayName:  f.DisplayName  || "",
    name:         f.Name         || "",
    phone:        f.Phone        || "",
    email:        f.Email        || ""
  };

  return j(env, origin, { ok: true, member });
}

      

      // --- Save note ---
      if (req.method === "POST" && path === "/cart/note"){
        const { cart_token, note="" } = await body();
        const T = env.AT_CARTS || "CartToken";
        const rec = await atFindByField(env, T, "CartToken", cart_token);
        if (rec){
          await at(env, "PATCH", T, "", { records:[{ id:rec.id, fields: { Note: String(note||"") } }]});
        }
        return j(env, origin, { ok:true });
      }

      // --- Clear / Remove (OP only) ---
      if (req.method === "POST" && (path === "/cart/clear" || path === "/cart/remove")){
        const b = await body();
        if (!b.op_key || String(b.op_key) !== String(env.OP_KEY)) return j(env, origin, { ok:false, error:"forbidden" }, 403);
        if (path === "/cart/clear") await clearCart(env, b.cart_token);
        else await removeItem(env, b.cart_token, b.sku);
        const list = await cartItems(env, b.cart_token);
        const sum = sumCart(list);
        return j(env, origin, { ok:true, items: sum.items, total_amount: sum.total });
      }

            

     // --- PayUNI startï¼šæ ¹æ“šè¨‚å–®çµ„å‡º PayUNI æ¬„ä½ ---
if (req.method === "POST" && path === "/payuni/start") {
  const b = await body();
const order_id    = b?.order_id;
const mode        = b?.mode;        // âœ… æœƒæ”¶åˆ°ï¼šcard_once / card_inst / linepay / aftee_direct
const inst_months = b?.inst_months; // âœ… 3/6/9...
  if (!order_id) {
    return j(env, origin, { ok: false, error: "order_id_required" }, 400);
  }

  const T = env.AT_ORDERS || "Orders";
  const rows = await atListByField(env, T, "order_id", order_id);
  const rec = rows && rows[0];
  if (!rec) {
    return j(env, origin, { ok: false, error: "order_not_found" }, 404);
  }

  const f = rec.fields || {};
  const net = Number(f.net_amount || 0) || 0;
if (net <= 0) {
  return j(env, origin, { ok:false, error:"zero_amount_not_allowed" }, 400);
}
  const pm = String(f.payment_method || "");
  console.log("payuni/start pm=", pm, "order_id=", order_id);


  // åªæœ‰ paid_* é¡ï¼ˆä¿¡ç”¨å¡ / åˆ†æœŸ / LINE Pay / AF / ATMï¼‰èµ° PayUNI
  if (!(pm.startsWith("paid_") || pm === "aftee_direct")) {
    return j(env, origin, { ok: false, error: "not_payuni_payment_method" }, 400);
  }

  try {
    // âœ… 1) å…ˆç¢ºä¿æ¯å¼µè¨‚å–®éƒ½æœ‰å›ºå®šçš„ payuni_trade_noï¼ˆ<=20 è‹±æ•¸ï¼‰
    let tradeNo = String(f.payuni_trade_no || "").trim();
    if (!tradeNo) {
      tradeNo = toPayuniTradeNo(f.order_id || order_id);
  
      // å¯«å› Airtableï¼Œä¹‹å¾Œ notify/return æ‰æ‰¾å¾—åˆ°åŒä¸€å¼µå–®
      await at(env, "PATCH", T, "", {
        records: [{ id: rec.id, fields: { payuni_trade_no: tradeNo } }]
      });
    }
  
    const modeStr = String(mode || "").trim(); // 'upp' / 'linepay' / 'aftee_direct'
const modeL = modeStr.toLowerCase();
const instN = (inst_months === null || inst_months === undefined) ? null : Number(inst_months);

// âœ… å…œåº•ï¼šç”¨ mode/inst_months æ¨å°é€™æ¬¡çœŸæ­£è¦èµ°çš„ payment_method
let pmFinal = String(f.payment_method || "").trim();

if (modeL === "aftee_direct" || modeL === "aftee") {
  pmFinal = "paid_aftee_direct";
} else if (modeL === "linepay") {
  pmFinal = "paid_linepay";
} else if (modeL === "upp" || modeL === "card_once" || modeL === "card_inst") {
  // ä½ çš„å‰ç«¯ä¿¡ç”¨å¡/åˆ†æœŸæ˜¯ mode="upp"
  if (Number.isFinite(instN) && instN > 0) pmFinal = `paid_card_inst_${Math.floor(instN)}`;
  else pmFinal = "paid_card_once";
}

// âœ… è‹¥ payment_method è·Ÿè³‡æ–™åº«ä¸ä¸€è‡´ï¼šPATCH å› Airtableï¼ˆä¿è­‰è·³å°é ï¼‰
if (pmFinal && pmFinal !== String(f.payment_method || "").trim()) {
  try {
    await at(env, "PATCH", T, "", {
      records: [{ id: rec.id, fields: { payment_method: pmFinal } }]
    });
  } catch (e) {
    console.log("payuni/start patch payment_method failed", order_id, pmFinal, e?.message || e);
  }
}

const f2 = {
  ...f,
  payment_method: pmFinal,
  payuni_trade_no: tradeNo,
  payuni_mode: modeStr || undefined,
  payuni_inst_months: Number.isFinite(instN) ? instN : undefined
};

const reqData = await buildPayuniRequest(env, f2, url.origin);
return j(env, origin, { ok: true, ...reqData });
  } catch (err) {
    return j(env, origin, {
      ok: false,
      error: "payuni_failed",
      message: String(err && err.message || err)
    }, 502);
  }
}
// --- PayUNI Returnï¼šæ¥æ”¶ç€è¦½å™¨ POST å›ä¾†ï¼Œè§£å¯†å¾Œè½‰å€å›å‰ç«¯ ---
if (req.method === "POST" && path === "/payuni/return") {
  const form = await req.formData();
  const data = {};
  form.forEach((v, k) => (data[k] = v));

  // é è¨­å°å›é¦–é ï¼Œé¿å…è§£å¯†å¤±æ•—æ²’åœ°æ–¹å»
  const front = (env.FRONT_ORIGIN || "https://murain.tw").replace(/\/$/, "");
  let redirectUrl = front + "/";

  try {
    const merKey = env.PAYUNI_KEY;
    const merIV  = env.PAYUNI_IV;

    if (data.EncryptInfo && merKey && merIV) {
      const dec = await payuniDecrypt(data.EncryptInfo, merKey, merIV);
      // è§£å‡ºä¾†æœƒæœ‰ï¼šStatus, MerTradeNo (è¨‚å–®ç·¨è™Ÿ), TradeAmt...

      const orderId = dec.MerTradeNo || "";
      const total   = dec.TradeAmt   || "";
      const status  = dec.Status     || "";
      const tradeStatus = dec.TradeStatus || dec.tradeStatus || ""; // âœ…è£œé€™è¡Œï¼ˆè§£æ‰ä½ ç¾åœ¨çš„éŒ¯èª¤ï¼‰

      if (orderId) {
        const tradeNo = String(orderId).trim();
      
        // âœ… ç”¨ tradeNo æ‰¾å› Airtable è¨‚å–®ï¼Œæ‹¿åˆ°ã€ŒçœŸæ­£ order_id + cart_tokenã€
        const O = env.AT_ORDERS || "Orders";

let rec = null;
try {
  rec = await atFindByField(env, O, "payuni_trade_no", tradeNo);
  if (!rec) rec = await atFindByField(env, O, "order_id", tradeNo);
} catch (e) {}
      
        const realOrderId = String(rec?.fields?.order_id || tradeNo).trim();
        const cartToken   = String(rec?.fields?.cart_token || "").trim();

        // âœ… æ‰¾ä¸åˆ°è¨‚å–®å°±ä¸è¦å¾€ä¸‹è·‘ï¼ˆé¿å… rec.id ç›´æ¥ç‚¸ï¼‰
if (!rec?.id) {
  redirectUrl = `${front}/order-result.html?order_id=${encodeURIComponent(tradeNo)}&status=ORDER_NOT_FOUND`;
  return new Response(null, { status: 302, headers: { Location: redirectUrl } });
}

      
        const statusU = String(status || "").trim().toUpperCase();
const tradeU  = String(tradeStatus || "").trim().toUpperCase();

const okPay   = (statusU === "SUCCESS" || statusU === "1" || tradeU === "SUCCESS" || tradeU === "1");
const softOk  = (statusU === "OK" || tradeU === "OK"); // âœ… OK = è™•ç†ä¸­ï¼Œä¸æ˜¯å¤±æ•—

// âœ… é‡‘é¡æ¯”å°ï¼šPayUNI å›ä¾†çš„ TradeAmt å¿…é ˆç­‰æ–¼è¨‚å–® net_amountï¼ˆæ‡‰æ”¶ï¼‰
// åªè¦ä¸ç­‰ï¼Œä¸€å¾‹ç•¶å¤±æ•—ï¼ˆä¸è½åœ° paid_okã€ä¸æ‰£è³¼ç‰©é‡‘ã€ä¸é–‹ç¥¨ï¼‰
const paidAmt = Math.round(Number(total || dec?.TradeAmt || 0) || 0);

// è¨‚å–®æ‡‰æ”¶ï¼šä»¥ net_amount ç‚ºä¸»ï¼ˆä½ å·²ç¢ºèªé€™å°±æ˜¯é‡‘æµé‡‘é¡ï¼‰
const expectedAmt = Math.round(Number(rec?.fields?.net_amount || 0) || 0);

// è‹¥ net_amount æ²’å¯«ï¼ˆæ¥µå°‘æ•¸èˆŠå–®ï¼‰ï¼Œæ‰é€€å›ç”¨ total_amount-credit_used ç®—ä¸€æ¬¡
let expectedFallback = expectedAmt;
if (!expectedFallback) {
  const baseTotal = Number(rec?.fields?.total_amount || rec?.fields?.total || 0) || 0;
  const creditUsed = Number(rec?.fields?.credit_used || 0) || 0;
  expectedFallback = Math.round(baseTotal - creditUsed);
}

// åªåœ¨ã€Œå®£ç¨±æˆåŠŸã€æ™‚æª¢æŸ¥é‡‘é¡ï¼ˆOK=è™•ç†ä¸­å…ˆä¸çµç®—ï¼‰
if (okPay) {
  const exp = expectedAmt || expectedFallback;

  if (!exp || paidAmt !== exp) {
    console.log("PayUNI return amount mismatch", {
      tradeNo,
      paidAmt,
      expectedAmt,
      expectedFallback,
      net_amount: rec?.fields?.net_amount,
      total_amount: rec?.fields?.total_amount,
      credit_used: rec?.fields?.credit_used,
    });

    // å¯«å› Airtableï¼šè¨˜éŒ„å¤±æ•—åŸå› ï¼Œé¿å…èª¤å‡ºè²¨
    await at(env, "PATCH", O, "", {
      records: [{
        id: rec.id,
        fields: {
          pay_notify_status: `AMOUNT_MISMATCH:${paidAmt}/${exp}`,
          pay_status: "failed"
        }
      }]
    });

    // âœ… é‡‘é¡ä¸ç¬¦ï¼šæŠŠè³¼ç‰©é‡‘ä¿ç•™é‡‹æ”¾æ‰ï¼Œé¿å…å®¢äººè¢«é–ä½
try { await releaseCreditHoldIfNeeded(env, realOrderId); } catch (e) {
  console.log("PayUNI return amount mismatch: releaseCreditHold error", tradeNo, e);
}

    // å°å›å‰ç«¯é¡¯ç¤ºéŒ¯èª¤ï¼ˆä½ ä¹Ÿå¯ä»¥å°åˆ° order-resultï¼‰
    redirectUrl = `${front}/order-result.html?order_id=${encodeURIComponent(realOrderId)}&status=AMOUNT_MISMATCH`;
    return new Response(null, { status: 302, headers: { Location: redirectUrl } });
  }
}
        // â˜… ä¿éšªï¼šå³ä½¿ notify æ²’ä¾†ï¼Œreturn ä¹ŸæŠŠç‹€æ…‹å¯«å› Airtable
if (rec?.id) {
  try {
    const statusU = String(status || "").trim().toUpperCase();
    const tradeU  = String(tradeStatus || "").trim().toUpperCase();

    const okPay =
      statusU === "SUCCESS" || statusU === "1" ||
      tradeU  === "SUCCESS" || tradeU  === "1";

    const softOk = (statusU === "OK" || tradeU === "OK"); // OK=è™•ç†ä¸­

    const currentPay = String(rec?.fields?.pay_status || "");
    const patchFields = {
      pay_notify_status: String(status || "").trim() || statusU || "-",
      pay_channel: "payuni",
    };

    // âœ… ä¸‰æ…‹ï¼šæˆåŠŸ / è™•ç†ä¸­ / å¤±æ•—ï¼ˆå¤±æ•—ä¸è¦†è“‹å·² paid_okï¼‰
    if (okPay) {
      // âœ… è‹¥ç•¶åˆæ²’å…ˆæ‰£åº«å­˜ï¼ˆstock_deduct_done=falseï¼‰ï¼Œä»˜æ¬¾æˆåŠŸæ™‚è£œæ‰£ä¸€æ¬¡
if (rec?.fields?.stock_deduct_done === false) {
  try {
    const oid0 = String(rec?.fields?.order_id || tradeNo || "");
    const isTail0 =
      oid0.startsWith("TL") ||
      !!String(rec?.fields?.parent_order_id || "").trim() ||
      rec?.fields?.is_tail === true;

    const items = safeJsonParse(rec?.fields?.items_json, []);
    if (!isTail0 && Array.isArray(items) && items.length > 0) {
      await adjustStockByItems(env, items, -1);
      patchFields.stock_deduct_done = true;
      console.log("[PayUNI return] paid_ok => stock deducted:", oid0);
    }
  } catch (e) {
    console.log("[PayUNI return] deduct stock failed:", e?.message || e);
  }
}
      patchFields.pay_status = "paid_ok";
      patchFields.status = "paid"; // ä½  status æ˜¯æ–‡å­— âœ… å¯ä»¥å¯«ï¼›è‹¥ä½ ä¸æƒ³å‹• statusï¼Œå¯åˆªæ‰é€™è¡Œ
    } else if (softOk) {
      patchFields.pay_status = (currentPay === "paid_ok") ? "paid_ok" : "submitted";
    } else {
      patchFields.pay_status = (currentPay === "paid_ok") ? "paid_ok" : "failed";
    }

    // è¿½å–®æ¬„ä½ï¼ˆåŸæœ¬ç©ºæ‰è£œï¼‰
    if (!rec?.fields?.payuni_trade_no) patchFields.payuni_trade_no = tradeNo;

    await at(env, "PATCH", (env.AT_ORDERS || "Orders"), "", {
      records: [{ id: rec.id, fields: patchFields }]
    });

    // è®“å¾Œé¢æµç¨‹çœ‹åˆ°æœ€æ–°æ¬„ä½
    try { rec.fields = { ...(rec.fields || {}), ...(patchFields || {}) }; } catch {}

    // âœ… åªæœ‰ã€ŒçœŸçš„æˆåŠŸ okPayã€æ‰çµç®—ï¼ˆæ‰£è³¼ç‰©é‡‘ + é–‹ç¥¨ï¼‰ï¼›softOk ä¸åš
    if (okPay) {
      // 1) æˆåŠŸå…ˆæ‰£è³¼ç‰©é‡‘
      try { await spendCreditIfNeeded(env, rec); } catch (e) {
        console.log("payuni return spendCreditIfNeeded error", tradeNo, e);
      }

      // 2) é‡æŠ“ä¸€æ¬¡ï¼ˆé¿å… net_amount/credit_used æ˜¯èˆŠå€¼ï¼‰
      let rec2 = rec;
      try {
        const oid2 = String(rec?.fields?.order_id || "").trim() || String(tradeNo || "").trim();
        const rows2 = await atListByField(env, (env.AT_ORDERS || "Orders"), "order_id", oid2);
        if (rows2 && rows2[0]) rec2 = rows2[0];
      } catch {}

      // 3) é–‹ç¥¨ï¼šç…§ä½ åŸæœ¬è¦å‰‡ã€Œç·šä¸Šæ”¯ä»˜æ‰é–‹ã€
      //    TL æœƒç”¨ net_amountï¼ˆæˆ– total-creditï¼‰ç®—ï¼›total<=0 æœƒè‡ªå‹• skipped
      try { await issueEcpayInvoiceForOrder(env, rec2); } catch (e) {
        console.log("payuni return issue invoice error", tradeNo, e);
      }
      // âœ… TL ä»˜æ¸…å¾Œå›å¯« parent ODï¼ˆé¿å…æœƒå“¡ä¸­å¿ƒ OD é‚„å¡æ ¸å°ä¸­ï¼‰
try { await syncTailPaidToParent(env, rec2, "payuni"); } catch (e) {
  console.log("payuni return: sync tail->parent error", tradeNo, e);
}
    }

    console.log("PayUNI return: Airtable patched", tradeNo, patchFields);
  } catch (e) {
    console.log("PayUNI return: patch status error", tradeNo, e);
  }
}
      
if (okPay || softOk) {
  redirectUrl = `${front}/order-result.html?order_id=${encodeURIComponent(realOrderId)}&total=${encodeURIComponent(total)}&status=${encodeURIComponent(status)}`;
} else {
          // âŒ å¤±æ•—ï¼šå…ˆæŠŠå¤±æ•—ç‹€æ…‹å¯«å›è¨‚å–® + é€€å›è³¼ç‰©é‡‘ï¼Œå†å°å›è³¼ç‰©è»Šï¼ˆå¸¶é½Šåƒæ•¸ï¼‰
          try {
            if (rec) {
              // 1) è¨˜éŒ„å¤±æ•—ç‹€æ…‹ï¼ˆè®“ä½  Airtable çœ‹å¾—åˆ°ï¼‰
              await at(env, "PATCH", (env.AT_ORDERS || "Orders"), "", {
                records: [{
                  id: rec.id,
                  fields: {
                    pay_status: (String(rec?.fields?.pay_status || "") === "paid_ok") ? "paid_ok" : "failed",
                    pay_notify_status: String(status || ""),
                  }
                }]
              });
        
              // 2) é€€å›è³¼ç‰©é‡‘ï¼ˆä½ ç¾åœ¨ç¼ºçš„å°±æ˜¯é€™æ­¥ï¼‰
              await releaseCreditHoldIfNeeded(env, realOrderId);
            }
          } catch (e) {
            console.log("payuni return fail: patch/refund error", e);
          }
        
          // 3) å›è³¼ç‰©è»Šï¼šæŠŠ user_id + credit_used ä¸€èµ·å¸¶å›å»ï¼Œå‰ç«¯æ‰èƒ½é¡¯ç¤ºæœƒå“¡è³‡æ–™èˆ‡æŠ˜æŠµå¾Œé‡‘é¡
          if (cartToken) {
            const q = new URLSearchParams();
            q.set("cart_token", cartToken);
            q.set("order_id", realOrderId);
            q.set("from", "payreturn");
            q.set("status", status || "");
            const cu = Number(rec?.fields?.credit_used || 0) || 0;
const uid = String(rec?.fields?.line_user_id || "").trim();

q.set("credit_used", String(cu));
if (uid) q.set("user_id", uid);
q.set("lock_credit", "1");
        
            redirectUrl = `${front}/liff-checkout.html?${q.toString()}`;
          } else {
            redirectUrl = `${front}/order-result.html?order_id=${encodeURIComponent(realOrderId)}&total=${encodeURIComponent(total)}&status=${encodeURIComponent(status)}`;
          }
        }
      }
    }
  } catch (e) {
    console.log("PayUNI return decrypt error:", e);
    redirectUrl = `${front}/order-result.html?error=decrypt_failed`;
  }

  // 302 è·³è½‰åˆ°å‰ç«¯é é¢
  return new Response(null, {
    status: 302,
    headers: {
      "Location": redirectUrl
    }
  });
}

// --- PayUNI ä»˜æ¬¾çµæœé€šçŸ¥ï¼šè‡ªå‹•æŠŠè¨‚å–®æ¨™è¨˜ç‚ºå·²ä»˜æ¬¾ ---
if (req.method === "POST" && path === "/payuni/notify") {
  const form = await req.formData();
  const data = {};
  form.forEach((v, k) => (data[k] = v));

  console.log("PayUNI notify raw:", data);

  const statusTop = data.Status || data.status || "";

  // è§£å¯† EncryptInfoï¼Œæ‹¿åˆ° MerTradeNo / TradeStatus ç­‰æ¬„ä½
  let dec = {};
  try {
    const merKey = env.PAYUNI_KEY;
    const merIV  = env.PAYUNI_IV;
    if (data.EncryptInfo && merKey && merIV) {
      dec = await payuniDecrypt(data.EncryptInfo, merKey, merIV);
      console.log("PayUNI notify decrypted:", dec);
    }
  } catch (e) {
    console.log("PayUNI decrypt error:", e && e.message || e);
  }

  const status      = dec.Status      || statusTop;
  const tradeStatus = dec.TradeStatus || dec.tradeStatus || "";
  const tradeNo     = String(dec.MerTradeNo || data.MerTradeNo || data.merTradeNo || "").trim(); // â˜… é€™å°±æ˜¯ PayUNI çš„äº¤æ˜“åºè™Ÿ

  // â˜… æŠŠé‡æ´»ä¸Ÿåˆ° waitUntilï¼Œè®“ PayUNI ç«‹åˆ»æ‹¿åˆ° 200ï¼Œé¿å…è¶…æ™‚é‡é€
  const job = (async () => {
    try {
      const O = env.AT_ORDERS || "Orders";

      // âœ… æˆåŠŸæ¢ä»¶ï¼šStatus=SUCCESS æˆ– TradeStatus=1
      const statusU = String(status || "").trim().toUpperCase();
const tradeU  = String(tradeStatus || "").trim().toUpperCase();

// âœ… æˆåŠŸï¼šSUCCESS æˆ– TradeStatus=1
const isSuccess = (statusU === "SUCCESS" || tradeU === "1");

// âœ… è™•ç†ä¸­ï¼šOKï¼ˆä¸è¦ç•¶å¤±æ•—å–æ¶ˆï¼‰
const isPending = (statusU === "OK" || tradeU === "OK");

      if (!tradeNo) {
        console.log("PayUNI notify: missing MerTradeNo, skip");
        return;
      }

      // âœ… å…ˆç”¨ payuni_trade_no æ‰¾ï¼ˆæœ€æº–ï¼‰ï¼Œæ‰¾ä¸åˆ°å†é€€å›ç”¨ order_idï¼ˆç›¸å®¹èˆŠå–®ï¼‰
      let rec = await atFindByField(env, O, "payuni_trade_no", tradeNo);
      if (!rec) rec = await atFindByField(env, O, "order_id", tradeNo);

      if (!rec) {
        console.log("PayUNI notify: order not found in Airtable", tradeNo);
        return;
      }

      console.log("PayUNI notify: Airtable record found", rec.id, {
        isSuccess, status, tradeStatus, tradeNo
      });

      // âœ… pendingï¼šåªè¨˜éŒ„ç‹€æ…‹ï¼Œä¸å–æ¶ˆã€ä¸é€€è³¼ç‰©é‡‘ã€ä¸è£œåº«å­˜ã€ä¸ç™¼å¤±æ•—å¡
if (isPending) {
  try {
    await at(env, "PATCH", O, "", {
      records: [{
        id: rec.id,
        fields: { pay_notify_status: String(statusU || tradeU || "") }
      }]
    });
  } catch (e) {
    console.log("PayUNI notify: patch pending error", tradeNo, e);
  }
  return;
}

      // âœ… é‡‘é¡æ¯”å°ï¼šåªæœ‰åœ¨ã€ŒæˆåŠŸã€æ™‚æ‰æª¢æŸ¥
// TradeAmt å¿…é ˆç­‰æ–¼è¨‚å–® net_amountï¼ˆæ‡‰æ”¶ï¼‰ï¼Œå¦å‰‡ç›´æ¥æ“‹ä¸‹ï¼Œä¸è½åœ° paid_ok / ä¸æ‰£è³¼ç‰©é‡‘ / ä¸é–‹ç¥¨
if (isSuccess) {
  const paidAmt = Math.round(Number(dec?.TradeAmt || 0) || 0);

  let expectedAmt = Math.round(Number(rec?.fields?.net_amount || 0) || 0);

  // èˆŠå–®ä¿éšªï¼šnet_amount æ²’å¯«æ‰ç”¨ total_amount - credit_used
  if (!expectedAmt) {
    const baseTotal  = Number(rec?.fields?.total_amount || rec?.fields?.total || 0) || 0;
    const creditUsed = Number(rec?.fields?.credit_used || 0) || 0;
    expectedAmt = Math.round(baseTotal - creditUsed);
  }

  if (!paidAmt || !expectedAmt || paidAmt !== expectedAmt) {
    console.log("PayUNI notify amount mismatch", { tradeNo, paidAmt, expectedAmt });

    try {
      await at(env, "PATCH", O, "", {
        records: [{
          id: rec.id,
          fields: {
            pay_notify_status: `AMOUNT_MISMATCH:${paidAmt}/${expectedAmt}`,
            pay_status: "failed"
          }
        }]
      });
    } catch (e) {
      console.log("PayUNI notify: patch amount mismatch error", tradeNo, e);
    }
    // âœ… TLï¼šé‡‘é¡ä¸ç¬¦ä¹Ÿè¦é‡‹æ”¾ holdï¼Œé¿å…è³¼ç‰©é‡‘å¡ä½
try {
  const f0 = rec?.fields || {};
  const oid0 = String(f0.order_id || "").trim();
  const isTail0 = !!f0.is_tail || String(f0.order_type || "") === "tail" || oid0.startsWith("TL");
  if (isTail0) {
    const uid0 = String(f0.line_user_id || "").trim() || (() => {
      try {
        const si = f0.shipping_info ? JSON.parse(f0.shipping_info) : {};
        const line = si.line || si.line_profile || {};
        return String(line.user_id || line.userId || si.line_user_id || "").trim();
      } catch { return ""; }
    })();
    const cu0 = Math.round(Number(f0.credit_used || 0) || 0);
    if (uid0 && cu0 > 0 && !f0.credit_spend_done) {
      await releaseCreditHold(env, {
        lineUserId: uid0,
        orderRecId: rec.id,
        amount: cu0,
        reason: `AMOUNT_MISMATCH:${paidAmt}/${expectedAmt}`
      });
    }
  }
} catch (e) {
  console.log("PayUNI notify: release hold on amount mismatch error", tradeNo, e);
}

    return; // âœ… ç›´æ¥çµæŸ jobï¼Œé¿å…èª¤æ‰£/èª¤é–‹ç¥¨
  }
}

      if (isSuccess) {
        // â˜… è‹¥å·²ç¶“ paid_okï¼Œå°±ä¸å¿…é‡è¤‡å¯«ç‹€æ…‹ï¼ˆä»å¯æ›´æ–° notify ç‹€æ…‹ï¼‰
        const alreadyPaidOk = String(rec?.fields?.pay_status || "") === "paid_ok";

        let didDeductStock = false;

// âœ… è‹¥ç•¶åˆæ²’å…ˆæ‰£åº«å­˜ï¼ˆstock_deduct_done=falseï¼‰ï¼Œä»˜æ¬¾æˆåŠŸæ™‚è£œæ‰£ä¸€æ¬¡
if (rec?.fields?.stock_deduct_done === false) {
  try {
    const oid0 = String(rec?.fields?.order_id || tradeNo || "");
    const isTail0 =
      oid0.startsWith("TL") ||
      !!String(rec?.fields?.parent_order_id || "").trim() ||
      rec?.fields?.is_tail === true;

    const items = safeJsonParse(rec?.fields?.items_json, []);
    if (!isTail0 && Array.isArray(items) && items.length > 0) {
      await adjustStockByItems(env, items, -1);
      didDeductStock = true;
      console.log("[PayUNI notify] paid_ok => stock deducted:", oid0);
    }
  } catch (e) {
    console.log("[PayUNI notify] deduct stock failed:", e?.message || e);
  }
}

        await at(env, "PATCH", O, "", {
          records: [{
            id: rec.id,
            fields: {
              ...(alreadyPaidOk ? {} : {
                status:      "paid",
                pay_status:  "paid_ok",
                pay_channel: "payuni",
              }),
              pay_notify_status: String(status || ""),
              // éœ€è¦çš„è©±ä½ å¯ä»¥å¤šå­˜ tradeStatusï¼Œä½†å‰ææ˜¯ Airtable æœ‰é€™å€‹æ¬„ä½
              // pay_notify_trade_status: String(tradeStatus || ""),
            }
          }]
        });

        // âœ…ã€åŠ åœ¨é€™è£¡ã€‘è®“å¾Œé¢ç”¨åˆ°çš„ rec çœ‹åˆ°æœ€æ–°æ¬„ä½ï¼ˆé¿å… rec é‚„æ˜¯èˆŠçš„ï¼‰
try {
  rec.fields = {
    ...(rec.fields || {}),
    ...(alreadyPaidOk ? {} : { status: "paid", pay_status: "paid_ok", pay_channel: "payuni" }),
    pay_notify_status: String(status || ""),
  };
} catch {}

        // âœ… å°¾æ¬¾ TLï¼šç·šä¸Šæ”¯ä»˜æˆåŠŸ â†’ æŠŠ hold è½‰æˆå¯¦æ‰£
try {
  const f0 = rec?.fields || {};
  const oid0 = String(f0.order_id || "").trim();
  const isTail0 =
    !!f0.is_tail || String(f0.order_type || "") === "tail" || oid0.startsWith("TL");

  if (isTail0) {
    const uid0 = String(f0.line_user_id || "").trim() || (() => {
      try {
        const si = f0.shipping_info ? JSON.parse(f0.shipping_info) : {};
        const line = si.line || si.line_profile || {};
        return String(line.user_id || line.userId || si.line_user_id || "").trim();
      } catch { return ""; }
    })();

    const cu0 = Math.round(Number(f0.credit_used || 0) || 0);

    if (uid0 && cu0 > 0 && !f0.credit_spend_done) {
      await spendHeldCreditOnPaid(env, {
        lineUserId: uid0,
        orderRecId: rec.id,
        orderId: oid0,
        amount: cu0,
        reason: `tail:${String(f0.parent_order_id || "")}`
      });
    }
  } else {
    // éå°¾æ¬¾å–®ï¼šç¶­æŒä½ åŸæœ¬çš„æˆåŠŸæ‰£æ³•ï¼ˆå¦‚æœä½  OD ä¹Ÿæƒ³æ”¹æˆ hold å†ä¸€èµ·æ”¹ï¼‰
    await spendCreditIfNeeded(env, rec);
  }
} catch (e) {
  console.log("credit spend on success error", tradeNo, e);
}

        // â˜… ç·šä¸Šæ”¯ä»˜æˆåŠŸ â†’ è‡ªå‹•é–‹ç«‹ç™¼ç¥¨
// - å·²é–‹éå°±è·³éï¼ˆinvoice_no / invoice_issuedï¼‰
// - TLï¼šnet_amount > 0 æ‰é–‹ï¼ˆå…¨è³¼ç‰©é‡‘æŠ˜åˆ° 0 ä¸é–‹ï¼‰
// - ODï¼šç¶­æŒæˆåŠŸå°±é–‹
// âœ… æ‰£å®Œè³¼ç‰©é‡‘å¾Œé‡æŠ“ä¸€æ¬¡ï¼ˆè®“ä¸‹é¢ä¹Ÿèƒ½ç”¨ rec2ï¼‰
let rec2 = rec;

try {
  try {
    const oid2 = String(rec?.fields?.order_id || "").trim() || tradeNo;
    const r2 = await atFindByField(env, (env.AT_ORDERS || "Orders"), "order_id", oid2);
    if (r2) rec2 = r2;
  } catch (e) {}

  const f = rec2?.fields || {};
  const oid = String(f.order_id || "").trim() || tradeNo;

  const isTail =
    !!f.is_tail ||
    String(f.order_type || "") === "tail" ||
    oid.startsWith("TL");

  const hasInvoiceNo  = !!String(f.invoice_no || "").trim();
  const invoiceIssued = !!f.invoice_issued;

  if (!hasInvoiceNo && !invoiceIssued) {
    if (isTail) {
      const net = Math.round(Number(f.net_amount || 0) || 0);
      if (net > 0) {
        await issueEcpayInvoiceByOrderId(env, oid);
      } else {
        console.log("PayUNI notify: TL invoice skip (net <= 0)", oid, net);
      }
    } else {
      await issueEcpayInvoiceByOrderId(env, oid);
    }
  } else {
    console.log("PayUNI notify: skip invoice (already issued)", rec2?.id || rec?.id);
  }
} catch (e) {
  console.log("ECPay Invoice (payuni notify) error", tradeNo, e);
}

        // â˜… æˆåŠŸ Flex
        try {
          await sendPayResultFlex(env, rec2, { success: true });
        } catch (e) {
          console.log("PayUNI notify: sendPayResultFlex success error", tradeNo, e);
        }
        // âœ… TL ä»˜æ¸…å¾Œå›å¯« parent ODï¼ˆé¿å…æœƒå“¡ä¸­å¿ƒ OD é‚„å¡æ ¸å°ä¸­ï¼‰
try { await syncTailPaidToParent(env, rec2, "payuni"); } catch (e) {
  console.log("PayUNI notify: sync tail->parent error", tradeNo, e);
}

} else {
  // å¤±æ•—ï¼šæ¡ç”¨ã€Œå¾¹åº•å–æ¶ˆã€ç­–ç•¥ï¼ˆå–æ¶ˆè¨‚å–® + é€€è³¼ç‰©é‡‘ + è£œåº«å­˜ï¼‰
  const s = String(status || tradeStatus || statusTop || "FAIL").trim();
  // âœ… TLï¼ˆå°¾æ¬¾å–®ï¼‰å¤±æ•—ï¼šåªé‡‹æ”¾ holdï¼Œä¸è£œåº«å­˜ã€ä¸èµ° refundCreditIfNeeded
{
  const f0 = rec?.fields || {};
  const oid0 = String(f0.order_id || "").trim();
  const isTail0 = !!f0.is_tail || String(f0.order_type || "") === "tail" || oid0.startsWith("TL");

  if (isTail0) {
    try {
      // 1) è¨˜éŒ„å¤±æ•—
      await at(env, "PATCH", O, "", {
        records: [{ id: rec.id, fields: { status: "cancelled", pay_status: "failed", pay_notify_status: s } }]
      });

      // 2) é‡‹æ”¾ hold
      const uid0 = String(f0.line_user_id || "").trim() || (() => {
        try {
          const si = f0.shipping_info ? JSON.parse(f0.shipping_info) : {};
          const line = si.line || si.line_profile || {};
          return String(line.user_id || line.userId || si.line_user_id || "").trim();
        } catch { return ""; }
      })();
      const cu0 = Math.round(Number(f0.credit_used || 0) || 0);

      if (uid0 && cu0 > 0 && !f0.credit_spend_done) {
        await releaseCreditHold(env, {
          lineUserId: uid0,
          orderRecId: rec.id,
          amount: cu0,
          reason: `PAYUNI_FAIL:${s}`
        });
      }
    } catch (e) {
      console.log("PayUNI notify TL fail handler error", tradeNo, e);
    }

    // 3) ä»ç„¶ç™¼å¤±æ•—å¡ï¼ˆTL ç‰ˆï¼šå…ˆåœ¨æ­¤å€å¡Šè¨ˆç®— failReasonï¼Œé¿å…ç”¨åˆ°ä¸‹é¢æ‰å®£å‘Šçš„ constï¼‰
const failReasonTL =
dec.FailMessage ||
dec.FailMsg ||
dec.Message ||
dec.message ||
data.Message ||
data.message ||
"æ‚¨çš„ç·šä¸Šä»˜æ¬¾ç›®å‰æœªæˆåŠŸï¼Œè«‹æ”¹ç”¨å…¶ä»–ä»˜æ¬¾æ–¹å¼å®Œæˆä»˜æ¬¾ã€‚";

try {
await sendPayResultFlex(env, rec, { success:false, failReason: failReasonTL });
} catch (e2) {
console.log("PayUNI notify TL: send fail flex error", tradeNo, e2);
}
return;
  }
}

  // ä¿è­·ï¼šå·²ç¶“æ˜¯ paid_ok / å·²å®Œæˆçš„å–®ï¼Œä¸åšå–æ¶ˆèˆ‡è£œåº«å­˜ï¼Œåªè¨˜éŒ„ notify ç‹€æ…‹
  const curPs = String(rec?.fields?.pay_status || "").toLowerCase();
  const curSt = String(rec?.fields?.status || "").toLowerCase();
  const isTerminal =
  (curPs === "paid_ok" || curSt === "paid" || curSt === "shipped" || curSt === "completed") ||
  (curSt === "cancelled" || curSt === "canceled" || curPs === "failed");

  // è£œåº«å­˜å»é‡ï¼šç”¨ internal_note æ‰“æ¨™ï¼Œé¿å… PayUNI é‡é€ notify æ™‚é‡è¤‡ +1
  const note0 = String(rec?.fields?.internal_note || "");
  const RESTOCK_TAG = "[AUTO_RESTOCK_PAYUNI_FAIL]";
  const alreadyRestocked = note0.includes(RESTOCK_TAG);

  try {
    if (!isTerminal) {
      // å…ˆå¯«å…¥ cancelled + æ‰“æ¨™ï¼ˆè®“å¾ŒçºŒé‡é€å¯ä»¥è·³éè£œåº«å­˜ï¼‰
      const note1 = alreadyRestocked ? note0 : ((note0 ? note0 + " " : "") + RESTOCK_TAG + " " + nowISO());
      await at(env, "PATCH", O, "", {
        records: [{
          id: rec.id,
          fields: {
            status: "cancelled",
            pay_status: "failed",
            pay_notify_status: s,
            internal_note: note1
          }
        }]
      });

      // 1) è£œå›åº«å­˜ï¼ˆåªåšä¸€æ¬¡ï¼‰
      if (!alreadyRestocked) {
        let items = [];
        try { items = JSON.parse(rec?.fields?.items_json || "[]"); } catch (e) { items = []; }
        try { await adjustStockByItems(env, items, +1); } catch (e) {
          console.log("PayUNI notify fail: restock error", tradeNo, e);
        }
      }

      // 2) é€€å›è³¼ç‰©é‡‘ï¼ˆå…§å»ºå·²å…· idempotentï¼‰
      try { await refundCreditIfNeeded(env, rec, s); } catch (e) {
        console.log("PayUNI notify fail: refund credit error", tradeNo, e);
      }
    } else {
      await at(env, "PATCH", O, "", {
        records: [{ id: rec.id, fields: { pay_notify_status: s } }]
      });
    }
  } catch (e) {
    console.log("PayUNI notify: fail cancel/refund/restock error", tradeNo, e);
  }

  const failReason =
    dec.FailMessage ||
    dec.FailMsg ||
    dec.Message ||
    dec.message ||
    data.Message ||
    data.message ||
    "æ‚¨çš„ç·šä¸Šä»˜æ¬¾ç›®å‰æœªæˆåŠŸï¼Œè«‹æ”¹ç”¨å…¶ä»–ä»˜æ¬¾æ–¹å¼å®Œæˆä»˜æ¬¾ã€‚";

  try {
    await sendPayResultFlex(env, rec, { success:false, failReason });
  } catch (e2) {
    console.log("PayUNI notify: sendPayResultFlex fail error", tradeNo, e2);
  }
}


    } catch (e) {
      console.log("PayUNI notify job error", tradeNo, e);
    }
  })();

  // âœ… é€™è¡Œæ˜¯é—œéµï¼šæœ‰ ctx å°±ç”¨ waitUntilï¼Œç«‹åˆ»å› OKï¼Œé¿å… PayUNI timeout é‡é€
  if (typeof ctx !== "undefined" && ctx && typeof ctx.waitUntil === "function") {
    ctx.waitUntil(job);
    return new Response("OK", { status: 200 });
  }

  // å…¼å®¹ï¼šå¦‚æœä½ ä¸æ˜¯ module worker æ‹¿ä¸åˆ° ctxï¼Œå°±é€€å›åŒæ­¥è·‘
  await job;
  return new Response("OK", { status: 200 });
}




      // --- ZeroCard start (å¾Œç«¯å¹«ä½ æ‹¿ payment_url) ---
      if (req.method === "POST" && path === "/zero-card/start") {
        const { order_id } = await body();
        if (!order_id) {
          return j(env, origin, { ok:false, error:"order_id_required" }, 400);
        }
        const T = env.AT_ORDERS || "Orders";
        const rows = await atListByField(env, T, "order_id", order_id);
        const rec = rows && rows[0];
        if (!rec) {
          return j(env, origin, { ok:false, error:"order_not_found" }, 404);
        }
        const f = rec.fields || {};
        if (!String(f.payment_method || "").startsWith("zero_card_")) {
          return j(env, origin, { ok:false, error:"not_zero_card_order" }, 400);
        }

        try {
          const payment_url = await zeroCardReserve(env, url.origin, {
            order_id:       f.order_id || order_id,
            total_amount:   f.total_amount || f.total || 0,
            payment_method: f.payment_method || "",
            shipping_info:  f.shipping_info || "{}",
            credit_used:    f.credit_used || 0,   // â˜… åŠ é€™è¡Œ
          });
          return j(env, origin, { ok:true, payment_url });
        } catch (err) {
          return j(env, origin, {
            ok:false,
            error:"zero_card_failed",
            message: String((err && err.message) || err)
          }, 502);
        }
      }

                 // --- ZeroCard notify (ä¸­ç§ŸèƒŒæ™¯é€šçŸ¥ï¼Œç›¡é‡è‡ªå‹•æ¨™è¨˜ç‚ºå·²ä»˜æ¬¾) ---
      if ((req.method === "POST" || req.method === "GET") && path === "/zero-card/notify") {
        const txt = await req.text().catch(()=> "");
        console.log("ZeroCard notify raw:", txt);

        let params = {};

        // 1) å˜—è©¦å¾ body è§£æ
        try {
          if (txt && txt.trim().startsWith("{")) {
            // JSON
            params = JSON.parse(txt);
          } else if (txt) {
            // x-www-form-urlencoded
            const usp = new URLSearchParams(txt);
            for (const [k,v] of usp.entries()) params[k] = v;
          }
        } catch (e) {
          console.log("ZeroCard notify parse error", e);
        }

       // â˜… å…¼å®¹ä¸­ç§Ÿ JSON çµæ§‹ï¼šè¨‚å–®ç·¨è™Ÿè—åœ¨ info_order.order_id è£¡é¢
if (params && typeof params === "object") {
  /** @type {any} */
  const p = params;   // å‘Šè¨´ TSï¼šp æ˜¯ anyï¼Œä¸è¦ç®¡è£¡é¢çš„å±¬æ€§

  if (!p.order_id && p.info_order && p.info_order.order_id) {
    p.order_id = p.info_order.order_id;
  }
}

        // 2) æŠŠ URL ä¸Šçš„ query ä¹Ÿä½µé€²ä¾†ï¼ˆä»¥ body å„ªå…ˆï¼‰
        for (const [k,v] of url.searchParams.entries()) {
          if (!(k in params)) params[k] = v;
        }


        const T = env.AT_ORDERS || "Orders";

        // å¯èƒ½çš„è¨‚å–®ç·¨è™Ÿæ¬„ä½ï¼ˆä¾å¸¸è¦‹å‘½åç›¡é‡çŒœï¼‰
        const oid =
  params.order_id ||
  params.orderId ||
  params.order_no ||
  params.orderNo ||
  params.merchant_order_no ||
  params.merchantOrderNo ||
  params.merTradeNo ||
  params.MerTradeNo ||
  "";

  const resultCodeRaw =
  params.result || params.status || params.payment_status || "";
const resultCode = String(resultCodeRaw).trim().toUpperCase();

        // å¸¸è¦‹ã€ŒæˆåŠŸã€çš„å›å‚³å€¼ï¼ŒZeroCard ä¹Ÿå¸¸ç”¨ result = "000"
        const isSuccess =
  resultCode === "000" ||
  resultCode === "00"  ||
  resultCode === "0"   ||
  resultCode === "SUCCESS" ||
  resultCode === "S"   ||
  resultCode === "PAID"||
  resultCode === "Y";

  console.log("ZeroCard notify parsed:", {
    oid,
    resultCodeRaw,
    resultCode,
    paramsKeys: Object.keys(params)
  });

          if (oid && isSuccess) {
            try {
              const rows = await atListByField(env, T, "order_id", oid);
              const rec  = rows && rows[0];
              if (rec) {
                await at(env, "PATCH", T, "", {
                  records: [{
                    id: rec.id,
                    fields: {
                      status:      "paid",
                      pay_status:  "paid_ok",
                      pay_channel: "zero_card",
                      pay_notify_status: String(resultCode || ""),
                      // â˜… å…ˆä¸è¦å¯« paid_atï¼Œé¿å… Airtable 422 éŒ¯èª¤
  // paid_at:     nowISO(),
                    }
                  }]
                });
                console.log("ZeroCard notify: updated order", oid, resultCode);
                // â˜… è³¼ç‰©é‡‘ï¼šä¸­ç§ŸæˆåŠŸæ‰æ‰£ï¼ˆé˜²é‡ï¼šcredit_spend_doneï¼‰
try {
  await captureCreditHoldIfNeeded(env, oid);
} catch (e) {
  console.log("spendCreditIfNeeded (zero-card notify) error", oid, e);
}
      
                // â˜… é›¶å¡åˆ†æœŸæˆåŠŸ â†’ è‡ªå‹•é–‹ç«‹ç¶ ç•Œç™¼ç¥¨
                try {
                  await issueEcpayInvoiceByOrderId(env, oid);
                } catch (e) {
                  console.log("ECPay Invoice (zero-card notify) error", oid, e);
                }
                 // â˜…â˜…â˜… æ–°å¢ï¼šä¸­ç§ŸæˆåŠŸ â†’ ç™¼ã€Œä»˜æ¬¾æˆåŠŸ Flexã€ â˜…â˜…â˜…
        try {
          await sendPayResultFlex(env, rec, { success: true });
        } catch (e2) {
          console.log("ZeroCard notify: sendPayResultFlex success error", oid, e2);
        }

      } else {
        console.log("ZeroCard notify: order not found", oid);
      }

    } catch (e) {
      console.log("ZeroCard notify: Airtable update error", e);
    }
  } else if (oid) {
    // â˜…â˜…â˜… æ–°å¢ï¼šæœ‰è¨‚å–®ç·¨è™Ÿä½†ä¸æ˜¯æˆåŠŸ â†’ ç™¼ã€Œä»˜æ¬¾å¤±æ•— Flexã€ â˜…â˜…â˜…
    console.log("ZeroCard notify: payment not success", oid, resultCode);

    try {
      const rec2 = await atFindByField(env, T, "order_id", oid);
if (rec2) {
  const f2 = rec2.fields || {};
  const ps2 = String(f2.pay_status || "").toLowerCase();
  const st2 = String(f2.status || "").toLowerCase();
  const isDone2 = (ps2 === "paid_ok" || st2 === "paid" || st2 === "shipped" || st2 === "completed");

  const note0 = String(f2.internal_note || "");
  const RESTOCK_TAG = "[AUTO_RESTOCK_ZC_NOTIFY_FAIL]";
  const alreadyRestocked = note0.includes(RESTOCK_TAG);

  try {
    if (!isDone2) {
      const note1 = alreadyRestocked ? note0 : ((note0 ? note0 + " " : "") + RESTOCK_TAG + " " + nowISO());
      await at(env, "PATCH", T, "", {
        records: [{
          id: rec2.id,
          fields: {
            status: "cancelled",
            pay_status: "failed",
            pay_notify_status: String(resultCode || ""),
            internal_note: note1
          }
        }]
      });

      if (!alreadyRestocked) {
        let items = [];
        try { items = JSON.parse(f2.items_json || "[]"); } catch (e) { items = []; }
        try { await adjustStockByItems(env, items, +1); } catch (e) {
          console.log("ZeroCard notify fail: restock error", oid, e);
        }
      }

      try { await releaseCreditHoldIfNeeded(env, oid); } catch (e) {
        console.log("ZeroCard notify fail: refund credit error", oid, e);
      }
    }
  } catch (e) {
    console.log("ZeroCard notify fail: cancel/refund/restock error", oid, e);
  }

  const reason =
    "æ‚¨çš„ç”³è«‹ç›®å‰æœªé€šéå¯©æ ¸ï¼Œè¨‚å–®å·²å–æ¶ˆï¼Œåº«å­˜å·²é‡‹æ”¾ï¼Œè³¼ç‰©é‡‘å·²é€€å›ã€‚è«‹é‡æ–°çµå¸³ã€‚";
  await sendPayResultFlex(env, rec2, {
    success: false,
    failReason: reason,
  });
}
    } catch (e2) {
      console.log("ZeroCard notify: sendPayResultFlex fail error", oid, e2);
    }
  } else {
    console.log("ZeroCard notify: skip auto update, oid/result =", oid, resultCode);
  }

  return new Response("OK", { status: 200 });
}

            // --- Adminï¼šç¢ºèªæ”¶æ¬¾ / ä¸­ç§Ÿå¯©æ ¸ + ç™¼ LINE é€šçŸ¥ ---
            if (req.method === "POST" && path === "/admin/order/confirm-pay") {
              const {
                op_key,
                order_id,
                mode = "ok",             // ok / zc_fail
                deposit_amount = null,
                deposit_last5  = ""
              } = await body();
      
              // é©—è­‰ OP_KEY
              if (!op_key || String(op_key) !== String(env.OP_KEY)) {
                return j(env, origin, { ok:false, error:"forbidden" }, 403);
              }
              if (!order_id) {
                return j(env, origin, { ok:false, error:"order_id_required" }, 400);
              }
      
              const T = env.AT_ORDERS || "Orders";
              const rows = await atListByField(env, T, "order_id", order_id);
              const rec  = rows && rows[0];
              if (!rec) {
                return j(env, origin, { ok:false, error:"order_not_found" }, 404);
              }
      
              const f = rec.fields || {};
              const pm    = String(f.payment_method || "");
              const total = Number(f.total_amount || f.total || 0) || 0;
      
              const fields = {};
      
              // æ›´æ–°è¨‚é‡‘æ¬„ä½ï¼ˆå¦‚æœæœ‰å¸¶ï¼‰
              let depAmt = null;
              if (deposit_amount !== null && deposit_amount !== "") {
                const n = Number(deposit_amount);
                if (!isNaN(n)) depAmt = n;
              } else if (f.deposit_amount != null) {
                depAmt = Number(f.deposit_amount) || null;
              }
              const depLast5 = (deposit_last5 || f.deposit_last5 || "").trim();
      
              if (depAmt != null)  fields.deposit_amount = depAmt;
              if (depLast5)        fields.deposit_last5  = depLast5;
      
              let pay_status = f.pay_status || "";
              let status     = f.status     || "submitted";
              let msgCore    = "";   // çµ¦å®¢äººçš„ä¸»è¦è¨Šæ¯å…§å®¹

              // çµ¦ã€Œè¨‚é‡‘ Flex å¡ç‰‡ã€ç”¨çš„æ–‡å­—
let depositAmtText  = "";
let depositHoldText = "";
      
              // âœ… å¾Œå°å¯æ‰‹å‹•æ¨™è¨˜ï¼šok / zc_failï¼ˆåˆ†æœŸå¤±æ•—ï¼‰ / yufu_failï¼ˆèˆŠæŒ‰éˆ•ï¼Œä¿ç•™ç›¸å®¹ï¼‰
const isFailMode = (mode === "zc_fail" || mode === "yufu_fail");

// âœ… å¦‚æœæ˜¯è£•å¯Œå–®ï¼Œå°±ç®—æŒ‰çš„æ˜¯ zc_fail ä¹Ÿè¦ç”¨è£•å¯Œçš„å¤±æ•—æ–‡æ¡ˆ
const isYufuFail = isFailMode && (mode === "yufu_fail" || pm.startsWith("yufu_inst_"));
const isZcFail   = isFailMode && !isYufuFail;
const isFail     = isFailMode;

if (isFail) {
  // ä¸­ç§Ÿ or è£•å¯Œ å¯©æ ¸å¤±æ•— â†’ å–æ¶ˆï¼‹é€€è³¼ç‰©é‡‘ï¼‹è£œåº«å­˜ï¼ˆè£œåº«å­˜/é€€è³¼ç‰©é‡‘åœ¨ä¸‹é¢å¦æœ‰è™•ç†ï¼‰
  pay_status = "failed";
  status     = "cancelled";
  fields.pay_status = pay_status;
  fields.status     = status;

  msgCore = isYufuFail
    ? "æ‚¨çš„è£•å¯Œåˆ†æœŸç”³è«‹ç›®å‰æœªé€šéå¯©æ ¸ï¼Œè¨‚å–®å·²å–æ¶ˆï¼Œåº«å­˜å·²é‡‹æ”¾ï¼Œè³¼ç‰©é‡‘å·²é€€å›ã€‚è«‹é‡æ–°çµå¸³ã€‚"
    : "æ‚¨çš„ç”³è«‹ç›®å‰æœªé€šéå¯©æ ¸ï¼Œè¨‚å–®å·²å–æ¶ˆï¼Œåº«å­˜å·²é‡‹æ”¾ï¼Œè³¼ç‰©é‡‘å·²é€€å›ã€‚è«‹é‡æ–°çµå¸³ã€‚";

} else {
  // mode === "ok" / "yufu_ok" â†’ ä¾ä»˜æ¬¾æ–¹å¼æ±ºå®šè¦æ¨™è¨˜æˆã€Œè¨‚é‡‘ã€é‚„æ˜¯ã€Œå·²ä»˜æ¬¾ã€
  if (pm.startsWith("zero_card_")) {
    // ä¸­ç§Ÿå¯©æ ¸é€šé â†’ å·²ä»˜æ¬¾å¾…å‡ºè²¨
    pay_status = "paid_ok";
    status     = "paid";
    fields.pay_status = pay_status;
    fields.status     = status;
    msgCore = "æ‚¨çš„ä¸­ç§Ÿåˆ†æœŸå·²é€šéå¯©æ ¸ï¼Œè¨‚å–®å·²æ’å…¥å‡ºè²¨æµç¨‹ã€‚";

  } else if (pm.startsWith("paid_")) {
    // ç·šä¸Šæ”¯ä»˜æ‰‹å‹•è£œæ¨™ï¼ˆå‚™ç”¨ï¼‰
    pay_status = "paid_ok";
    status     = "paid";
    fields.pay_status = pay_status;
    fields.status     = status;
    msgCore = "å·²ç¢ºèªæ‚¨çš„ç·šä¸Šä»˜æ¬¾æˆåŠŸï¼Œè¨‚å–®å·²æ’å…¥å‡ºè²¨æµç¨‹ã€‚";

  } else if (pm.startsWith("yufu_inst_")) {
    // âœ… è£•å¯Œå¯©æ ¸é€šé â†’ å·²ä»˜æ¬¾å¾…å‡ºè²¨
    pay_status = "paid_ok";
    status     = "paid";
    fields.pay_status = pay_status;
    fields.status     = status;
    msgCore = "æ‚¨çš„è£•å¯Œåˆ†æœŸå·²é€šéå¯©æ ¸ï¼Œè¨‚å–®å·²æ’å…¥å‡ºè²¨æµç¨‹ã€‚";

  } else if (pm.includes("deposit") || pm.includes("atm") || pm.includes("bank_transfer")) {
    // åŒ¯æ¬¾ / è¨‚é‡‘ï¼ˆåŸæœ¬é‚è¼¯ä¿æŒä¸å‹•ï¼‰
    const full = (
      pm.includes("new_full") || pm.includes("full") ||
      (depAmt != null && total && depAmt >= total)
    );

    if (full) {
      pay_status = "paid_ok";
      status     = "paid";
      fields.pay_status = pay_status;
      fields.status     = status;
      const amtText = depAmt != null ? `NT$ ${Math.round(depAmt).toLocaleString("zh-TW")}` : "";
      msgCore = `å·²ç¢ºèªæ‚¨çš„åŒ¯æ¬¾ï¼ˆå…¨é¡ï¼‰${amtText ? "ï¼š" + amtText : ""}ï¼Œè¨‚å–®å·²æ’å…¥å‡ºè²¨æµç¨‹ã€‚`;
    } else {
                    // éƒ¨åˆ†åŒ¯æ¬¾ / è¨‚é‡‘ â†’ åªæ¨™è¨˜è¨‚é‡‘æ”¶åˆ°ï¼Œä¸æ”¹ status
                    pay_status = "deposit_ok";
                    fields.pay_status = pay_status;
                    const amtText = depAmt != null ? `NT$ ${depAmt}` : "å®šé‡‘";
                    depositAmtText = amtText;  // â† å­˜èµ·ä¾†çµ¦ä¸‹é¢ Flex ç”¨
           
                    // â˜… ç”¨å®¢äººå¡«å¯«çš„ä¿ç•™æ—¥æœŸï¼ˆå…ˆçœ‹ hold_untilï¼Œæ²’æœ‰å°±ç”¨ deposit_expire_atï¼‰
                    const holdRaw = f.hold_until || f.deposit_expire_at || "";
                    let holdText = "";
                    if (holdRaw) {
                      const d = new Date(holdRaw);
                      if (!isNaN(d.getTime())) {
                        const y = d.getFullYear();
                        const m = String(d.getMonth() + 1).padStart(2, "0");
                        const day = String(d.getDate()).padStart(2, "0");
                        holdText = `${y}å¹´${m}æœˆ${day}æ—¥`;
                      } else {
                        // å¦‚æœ Airtable å·²ç¶“æ˜¯æ’ç‰ˆå¥½çš„å­—ä¸²ï¼Œå°±ç›´æ¥ç”¨
                        holdText = String(holdRaw);
                      }
                    }
                    depositHoldText = holdText;  // â† é€™è£¡ä¹Ÿå­˜èµ·ä¾†
           
                    if (holdText) {
                      msgCore = `å·²ç¢ºèªæ”¶åˆ°æ‚¨çš„å®šé‡‘ ${amtText}ï¼Œæˆ‘å€‘æœƒç‚ºæ‚¨ä¿ç•™å•†å“è‡³ ${holdText}ã€‚`;
                    } else {
                      msgCore = `å·²ç¢ºèªæ”¶åˆ°æ‚¨çš„å®šé‡‘ ${amtText}ï¼Œæˆ‘å€‘æœƒç‚ºæ‚¨ä¿ç•™å•†å“ï¼ˆä¾ç³»çµ±è¨˜éŒ„ä¹‹ä¿ç•™æœŸé™ï¼‰ã€‚`;
                    }
                  }
                } else {
                  // å…¶ä»–æƒ…æ³å–®ç´”æ¨™è¨˜ paid_ok
                  pay_status = "paid_ok";
                  status     = "paid";
                  fields.pay_status = pay_status;
                  fields.status     = status;
                  msgCore = "å·²ç¢ºèªæ‚¨çš„æ¬¾é …ï¼Œè¨‚å–®å·²æ’å…¥å‡ºè²¨æµç¨‹ã€‚";
                           
                }
              }
      
              // å¯«å› Airtable
              await at(env, "PATCH", T, "", {
                records: [{ id: rec.id, fields }]
              });

              // âœ… æˆåŠŸ paid_okï¼šè£œæ‰£è³¼ç‰©é‡‘ï¼ˆå…§å»ºå»é‡ï¼Œä¸æœƒé‡è¤‡æ‰£ï¼‰
try {
  const rows2 = await atListByField(env, T, "order_id", order_id);
  const rec2  = rows2 && rows2[0];
  const f2 = rec2?.fields || {};

  const payAfter = String((fields.pay_status ?? f2.pay_status) || "").toLowerCase();
  const pm2 = String(f2.payment_method || pm || "");

  // åªæœ‰ã€ŒæˆåŠŸä»˜æ¬¾é¡ã€æ‰åœ¨ paid_ok æ‰£è³¼ç‰©é‡‘
  const shouldSpendOnPaid = /^(paid_|zero_card_|yufu_inst_)/i.test(pm2);

  if (payAfter === "paid_ok" && shouldSpendOnPaid) {
    await spendCreditIfNeeded(env, rec2); // ä½ æª”æ¡ˆè£¡å·²æœ‰é€™æ”¯å°±ç›´æ¥ç”¨
    console.log("Admin confirm-pay: credit spent", order_id);
  }
} catch (e) {
  console.log("Admin confirm-pay: spend credit error", order_id, e);
}
              
// â˜… zc_fail / yufu_failï¼šå¾¹åº•å–æ¶ˆï¼ˆé€€è³¼ç‰©é‡‘ + è£œåº«å­˜ï¼‰ï¼Œä¸¦åšå»é‡é¿å…é‡è¤‡ +1
if (mode === "zc_fail" || mode === "yufu_fail") {
  try {
    const f0 = rec.fields || {};
    const note0 = String(f0.internal_note || "");

    const isYufu = (mode === "yufu_fail");
    const RESTOCK_TAG = isYufu
      ? "[AUTO_RESTOCK_YUFU_ADMIN_FAIL]"
      : "[AUTO_RESTOCK_ZC_ADMIN_FAIL]";

    const alreadyRestocked = note0.includes(RESTOCK_TAG);

    if (!alreadyRestocked) {
      // è£œåº«å­˜
      let items = [];
      try { items = JSON.parse(f0.items_json || "[]"); } catch (e) { items = []; }
      try { await adjustStockByItems(env, items, +1); } catch (e) {
        console.log("admin fail: restock error", order_id, e);
      }
    }

    // é€€è³¼ç‰©é‡‘ï¼ˆå…§å»ºå·²å…· idempotentï¼‰
    try {
      await refundCreditIfNeeded(env, rec, isYufu ? "yufu_audit_fail" : "zc_audit_fail");
    } catch (e) {
      console.log("admin fail: refund credit error", order_id, e);
    }

    // å¯«å…¥å»é‡æ¨™è¨˜ï¼ˆé¿å…å†æ¬¡é»æ“Šé‡è¤‡è£œåº«å­˜ï¼‰
    if (!alreadyRestocked) {
      const note1 = (note0 ? note0 + " " : "") + RESTOCK_TAG + " " + nowISO();
      try {
        await at(env, "PATCH", T, "", {
          records: [{ id: rec.id, fields: { internal_note: note1 } }]
        });
      } catch (e) {
        console.log("admin fail: mark restock tag error", order_id, e);
      }
    }
  } catch (e) {
    console.log("admin fail handler error", order_id, e);
  }
}// â˜… å¦‚æœæ˜¯ ç·šä¸Šæ”¯ä»˜ / é›¶å¡ æ‰‹å‹•è£œæ¨™ç‚ºæˆåŠŸï¼Œå°±é †ä¾¿è£œé–‹ç™¼ç¥¨
if ((mode === "ok" || mode === "yufu_ok") && (pm.startsWith("paid_") || pm.startsWith("zero_card_") || pm.startsWith("yufu_inst_"))) {
  try {
    const realOrderId = String(order_id || "").trim();
    await issueEcpayInvoiceByOrderId(env, realOrderId);
  } catch (e) {
    console.log("ECPay Invoice (admin confirm) error", order_id, e);
  }
}
      
              // === æ‰¾ LINE userIdï¼ˆé‚è¼¯æ²¿ç”¨ /admin/order/shipï¼‰ ===
              let shipInfo = {};
              try {
                shipInfo = JSON.parse(f.shipping_info || "{}");
              } catch (e) {
                shipInfo = {};
              }
      
              const ship = shipInfo.ship || {};
              let line   = shipInfo.line || shipInfo.line_profile || {};
              let lineUserId =
                line.user_id || line.userId || line.LINE_USER_ID || "";
              let displayName =
                line.display_name || line.displayName || line.name || "";
      
              // æ²’æœ‰å¾è¨‚å–®è£¡å­˜åˆ° LINEï¼Œå°±ç”¨é›»è©± / Email å» LineMembers æ‰¾
              if (!lineUserId) {
                const phone = ship.phone || "";
                const email = ship.email || "";
                if (phone || email) {
                  const TM = env.AT_LINE_MEMBERS || "LineMembers";
                  const parts = [];
                  if (phone) parts.push(`{Phone}='${esc(phone)}'`);
                  if (email) parts.push(`{Email}='${esc(email)}'`);
                  if (parts.length) {
                    const formula =
                      parts.length === 1 ? parts[0] : `OR(${parts.join(",")})`;
                    const res = await at(env, "GET", TM, "", null, {
                      filterByFormula: formula,
                      maxRecords: "1"
                    });
                    const mrec = res.records && res.records[0];
                    if (mrec) {
                      const mf = mrec.fields || {};
                      lineUserId =
                        mf.LineUserId ||
                        mf.LINE_USER_ID ||
                        mf.line_user_id ||
                        "";
                      displayName =
                        displayName ||
                        mf.DisplayName ||
                        mf.display_name ||
                        mf.Name ||
                        "";
                    }
                  }
                }
              }
      
              // === æ‰¾ LINE userIdï¼ˆé‚è¼¯æ²¿ç”¨ /admin/order/shipï¼‰ ===
// ï¼ˆä¸Šé¢é‚£ä¸€å¤§æ®µæ‰¾ lineUserId / displayName çš„ç¨‹å¼ç¢¼ä¿æŒä¸å‹•ï¼‰

  // â˜… æ ¹æ“šç‹€æ…‹æ±ºå®šè¦ç™¼ä»€éº¼é€šçŸ¥
  try {
    const newPayStatus =
      (fields && fields.pay_status) || f.pay_status || "";

    console.log("confirm-pay flex", {
      order_id,
      mode,
      pay_status_before: f.pay_status || "",
      pay_status_after: fields.pay_status || "",
      newPayStatus,
    });

    // 1) ä¸­ç§Ÿ / ä»˜æ¬¾å¤±æ•— â†’ å¤±æ•—å¡ç‰‡
    if (mode === "zc_fail" || newPayStatus === "failed") {
      const reason =
        msgCore ||
        "æ‚¨çš„ä»˜æ¬¾ç›®å‰æœªèƒ½é †åˆ©å®Œæˆï¼Œè«‹æ”¹ç”¨å…¶ä»–ä»˜æ¬¾æ–¹å¼æˆ–æ´½è©¢å®¢æœã€‚";

      await sendPayResultFlex(env, rec, {
        success: false,
        failReason: reason,
      });

    // 2) ä¸€èˆ¬å…¨é¡ä»˜æ¬¾æˆåŠŸï¼ˆç·šä¸Šã€åŒ¯æ¬¾ã€ä¸­ç§ŸæˆåŠŸï¼‰ â†’ é€šç”¨ã€Œä»˜æ¬¾æˆåŠŸã€å¡ç‰‡
    } else if (newPayStatus === "paid_ok" || newPayStatus === "paid") {
      await sendPayResultFlex(env, rec, { success: true });

    // 3) è¨‚é‡‘æˆåŠŸï¼ˆdeposit_okï¼‰ â†’ ç”¨è¨‚é‡‘ Flex å¡ç‰‡
  } else if (newPayStatus === "deposit_ok") {
    await sendPayResultFlex(env, rec, { success: true });
  }
  } catch (e) {
    console.log("LINE Flex push (confirm-pay) error", order_id, e);
  }

  // æœ€å¾Œä¸€æ¨£å›å‰ç«¯ okï¼ˆåªä¿ç•™é€™ä¸€å€‹ returnï¼‰
  return j(env, origin, { ok: true });
}

// ===== Admin: æ‰‹å‹•åŒæ­¥ TL -> ODï¼ˆåªåœ¨ä½ å¾Œå°æŒ‰æŒ‰éˆ•æ™‚æœƒè·‘ï¼‰=====
// POST /admin/tail/sync-to-parent
// body: { op_key, tail_order_id }
// å›å‚³: { ok:true, tail_order_id, parent_order_id }
if (req.method === "POST" && path === "/admin/tail/sync-to-parent") {
  const { op_key, tail_order_id } = await body();

  // 1) é©—è­‰ OP_KEYï¼ˆå®Œå…¨æ²¿ç”¨ä½ æ—¢æœ‰ admin è¦å‰‡ï¼‰
  if (!op_key || String(op_key) !== String(env.OP_KEY)) {
    return j(env, origin, { ok:false, error:"forbidden" }, 403);
  }

  const tailId = String(tail_order_id || "").trim();
  if (!tailId) return j(env, origin, { ok:false, error:"tail_order_id_required" }, 400);

  const T = env.AT_ORDERS || "Orders";

  // 2) æ‰¾ TL è¨‚å–®
  const tailRec = await atFindByField(env, T, "order_id", tailId);
  if (!tailRec) return j(env, origin, { ok:false, error:"tail_order_not_found" }, 404);

  const tf = tailRec.fields || {};
  const isTail =
    !!tf.is_tail ||
    String(tf.order_type || "").toLowerCase() === "tail" ||
    String(tf.parent_order_id || "").trim() ||
    String(tf.order_id || "").toUpperCase().startsWith("TL");

  if (!isTail) {
    return j(env, origin, { ok:false, error:"not_a_tail_order" }, 400);
  }

  const parentId = String(tf.parent_order_id || "").trim();
  if (!parentId) {
    return j(env, origin, { ok:false, error:"tail_missing_parent_order_id" }, 400);
  }

  // 3) âœ… å‘¼å«ä½ æ—¢æœ‰åŒæ­¥å‡½å¼ï¼ˆä¿ç•™ä½ åŸæœ¬çš„é˜²é‡ TAG / snapshot / patch è¡Œç‚ºï¼‰
  try {
    await syncTailPaidToParent(env, tailRec, "manual");
  } catch (e) {
    console.log("admin tail sync error", tailId, e);
    return j(env, origin, { ok:false, error:"sync_failed" }, 500);
  }

  return j(env, origin, {
    ok: true,
    tail_order_id: tailId,
    parent_order_id: parentId
  });
}

      
            // --- Adminï¼šè¨‚å–®å‡ºè²¨ + ç™¼ LINE é€šçŸ¥ ---
            if (req.method === "POST" && path === "/admin/order/ship") {
              const { op_key, order_id, tracking_no = "", shipping_fee = null } = await body();
      
              // å¾Œå°ä¸€å®šè¦å¸¶ OP_KEY
              if (!op_key || String(op_key) !== String(env.OP_KEY)) {
                return j(env, origin, { ok: false, error: "forbidden" }, 403);
              }
              if (!order_id) {
                return j(env, origin, { ok: false, error: "order_id_required" }, 400);
              }
      
              const T = env.AT_ORDERS || "Orders";
              const rows = await atListByField(env, T, "order_id", order_id);
              const rec = rows && rows[0];
              if (!rec) {
                return j(env, origin, { ok: false, error: "order_not_found" }, 404);
              }
      
              const f = rec.fields || {};
              const parentId = String(f.parent_order_id || "").trim();
const isTail =
  !!f.is_tail ||
  String(f.order_type || "").toLowerCase() === "tail" ||
  String(order_id || "").toUpperCase().startsWith("TL") ||
  !!parentId;

// âœ… å‡ºè²¨é€šçŸ¥/å¡ç‰‡é¡¯ç¤ºç”¨ï¼šå°¾æ¬¾å–®å‡ºè²¨æ™‚ï¼Œæ”¹é¡¯ç¤ºåŸå–® OD
const displayOrderId = (isTail && parentId) ? parentId : order_id;
const now = nowISO();
const fields = {
  status: "shipped",
  ship_status: "shipped",   // â† æ–°å¢ï¼šå¾Œå°å‡ºè²¨ç‹€æ…‹ä¸€èµ·è®Šã€Œå·²å‡ºè²¨ã€
  shipped_at: now
};
if (tracking_no) fields.tracking_no = String(tracking_no);
if (shipping_fee != null) fields.shipping_fee = Number(shipping_fee) || 0;
      
              // å…ˆå¯«å› Airtable
              await at(env, "PATCH", T, "", {
                records: [{ id: rec.id, fields }]
              });

              // âœ… è‹¥é€™å¼µæ˜¯å°¾æ¬¾å–® TLï¼Œå‡ºè²¨æ¬„ä½åŒæ­¥å›åŸå–® ODï¼ˆåŒæ¨£æ¬„ä½ï¼štracking_no / shipping_fee / shipped_atï¼‰
if (isTail && parentId) {
  try {
    const rowsP = await atListByField(env, T, "order_id", parentId);
    const pRec = rowsP && rowsP[0];
    if (pRec?.id) {
      // ä½ è‹¥ã€Œåªæƒ³åŒæ­¥ä¸‰æ¬„ã€ï¼šæŠŠ parentFields æ”¹æˆåªå« tracking_no/shipping_fee/shipped_at
      const parentFields = {
        shipped_at: now,
        ship_status: "shipped",
        status: "shipped",
      };
      
      if (tracking_no) parentFields.tracking_no = String(tracking_no);
      if (shipping_fee != null) parentFields.shipping_fee = Number(shipping_fee) || 0;
      await at(env, "PATCH", T, "", {
        records: [{ id: pRec.id, fields: parentFields }]
      });
    } else {
      console.log("admin ship: parent order not found", parentId, "for tail", order_id);
    }
  } catch (e) {
    // ä¸é˜»æ–·å‡ºè²¨ä¸»æµç¨‹ï¼šTL å·²å‡ºè²¨æˆåŠŸï¼ŒOD åŒæ­¥å¤±æ•—åªè¨˜ log
    console.log("admin ship: sync to parent error", order_id, parentId, e?.message || e);
  }
}
      
              // å¾ shipping_info ä¸­æŠŠåŸºæœ¬è³‡è¨ŠæŠ“å‡ºä¾†
              let shipInfo = {};
              try {
                shipInfo = JSON.parse(f.shipping_info || "{}");
              } catch (e) {
                shipInfo = {};
              }
      
              const ship = shipInfo.ship || {};
      
              // 1) å…ˆçœ‹è¨‚å–®æœ¬èº«æœ‰æ²’æœ‰å­˜ LINE
              let line = shipInfo.line || shipInfo.line_profile || {};
              let lineUserId =
                line.user_id || line.userId || line.LINE_USER_ID || "";
              let displayName =
                line.display_name || line.displayName || line.name || "";
      
              // 2) å¦‚æœè¨‚å–®æ²’å­˜ LINEï¼Œå°±ç”¨é›»è©± / Email å» LineMembers æ‰¾
              if (!lineUserId) {
                const phone = ship.phone || "";
                const email = ship.email || "";
      
                if (phone || email) {
                  const TM = env.AT_LINE_MEMBERS || "LineMembers";
      
                  const parts = [];
                  if (phone) parts.push(`{Phone}='${esc(phone)}'`);
                  if (email) parts.push(`{Email}='${esc(email)}'`);
      
                  if (parts.length) {
                    const formula =
                      parts.length === 1 ? parts[0] : `OR(${parts.join(",")})`;
      
                    const res = await at(env, "GET", TM, "", null, {
                      filterByFormula: formula,
                      maxRecords: "1"
                    });
      
                    const mrec = res.records && res.records[0];
                    if (mrec) {
                      const mf = mrec.fields || {};
                      lineUserId =
                        mf.LineUserId ||
                        mf.LINE_USER_ID ||
                        mf.line_user_id ||
                        "";
                      displayName =
                        displayName ||
                        mf.DisplayName ||
                        mf.display_name ||
                        mf.Name ||
                        "";
                    }
                  }
                }
              }
      
              if (lineUserId) {
                // å‡ºè²¨æ™‚é–“ï¼šç”¨å‰›å‰›å¯«å…¥çš„ shipped_at
                const shipAt = fields.shipped_at || nowISO();
                const datePart = shipAt.slice(0, 10);      // YYYY-MM-DD
                const timePart = shipAt.slice(11, 16);     // HH:MM
                const shipTimeText = `${datePart} ${timePart}`;
            
                // å–è²¨æ–¹å¼ï¼šçœ‹ ship.type åˆ¤æ–·
                const shipType = ship.type || "";
                let shipLabel = "";
                if (shipType === "711" || shipType === "cvs_711" || shipType === "711_cvs") {
                  shipLabel = "7-11 è¶…å•†å–è²¨";
                } else if (shipType === "post" || shipType === "post_home") {
                  shipLabel = "éƒµå±€ / å®…é…";
                } else {
                  shipLabel = shipType || "";
                }
            
                 // â˜… æ‡‰ä»˜é‡‘é¡ï¼šå„ªå…ˆä½¿ç”¨æŠ˜æŠµå¾Œé‡‘é¡ = total_amount - credit_used
    const baseTotal  = Number(f.total_amount || f.total || 0) || 0;
    const creditUsed = Number(f.credit_used || 0) || 0;
    const netTotal   = baseTotal - creditUsed;

    // æŠ˜æŠµå®Œ <= 0 å°± fallback å›åŸåƒ¹
    const totalForMsg = netTotal > 0 ? netTotal : baseTotal;

    const amountText = totalForMsg
      ? `NT$ ${totalForMsg.toLocaleString("zh-TW")}`
      : "";
            
                // === æ–‡å­—ç‰ˆé€šçŸ¥ï¼ˆä¿ç•™åŸæœ¬é‚è¼¯ï¼Œä¸æ”¹ï¼‰ ===
                let msg = `ã€å‡ºè²¨é€šçŸ¥ã€‘\n\n`;
                if (displayName) {
                  msg += `${displayName} æ‚¨å¥½ï½\n`;
                }
                msg += `æ‚¨çš„è¨‚å–® ${displayOrderId} å·²æ–¼ ${shipTimeText} å®‰æ’å‡ºè²¨ã€‚\n`;
                msg += `ç‰©æµå–®è™Ÿï¼š${tracking_no || ""}\n`;
                msg += `å–è²¨æ–¹å¼ï¼š${shipLabel}\n`;
                msg += `æ‡‰ä»˜é‡‘é¡ï¼š${amountText}\n\n`;
                msg += `åŒ…è£¹å¯„å‡ºå¾Œï¼Œå¯¦éš›åˆ°åº—/é€é”æ™‚é–“ä»ä»¥ç‰©æµç‚ºä¸»ï¼Œå¦‚æœ‰ä»»ä½•å•é¡Œéƒ½å¯ä»¥ç›´æ¥å›è¦†æ­¤è¨Šæ¯ï¼Œè¬è¬æ‚¨ğŸ’–`;
            
                

                // === æ–°å¢ï¼šå‡ºè²¨ Flex å¡ç‰‡ï¼ˆé«˜ç´šç‰ˆï¼‰ ===
                try {
                  // å–ä¸€å€‹æ¯”è¼ƒå¥½çœ‹çš„ã€Œå–è²¨åœ°é»ã€
                  let shipPlace = "";
                  if (ship.store_name) {
                    shipPlace = String(ship.store_name);
                  } else if (ship.store_addr) {
                    shipPlace = String(ship.store_addr);
                  } else if (ship.addr) {
                    shipPlace = String(ship.addr);
                  } else {
                    shipPlace = shipLabel;
                  }

                  // å¾ Airtable æ¬„ä½æŠ“å‡ºå¯„é€ / é–€å¸‚ / åœ°å€ / ä»˜æ¬¾æ–¹å¼
const shipMethodLabel = f["å¯„é€æ–¹å¼_ä¸­æ–‡"] || "";   // ä¾‹ï¼š7-11 è¶…å•†å–è²¨ / éƒµå¯„
const payMethodLabel  = f["ä»˜æ¬¾æ–¹å¼_ä¸­æ–‡"] || "";   // ä¾‹ï¼š7-11 å–è²¨ä»˜æ¬¾ / LINE Pay

const storeId   = f["è¶…å•†åº—è™Ÿ"]   || "";
const storeName = f["è¶…å•†åº—å"]   || "";
const storeAddr = f["è¶…å•†åœ°å€"]   || "";
const zip       = f["éƒµéå€è™Ÿ"]   || "";
const addr      = f["æ”¶ä»¶åœ°å€"]   || "";

// çµ„ã€Œå–è²¨åœ°é»ã€å­—ä¸²ï¼ˆç”¨ shipPlaceTextï¼Œé¿å…è·Ÿå…¶ä»–è®Šæ•¸æ’åï¼‰
let shipPlaceText = "";

if (shipMethodLabel.includes("7-11")) {
  // 7-11 è¶…å•†å–è²¨
  const main = storeName || storeId || "";
  shipPlaceText =
    "7-11 è¶…å•†å–è²¨ï½œ" +
    main +
    (storeAddr ? `ï¼ˆ${storeAddr}ï¼‰` : "");
} else if (shipMethodLabel.includes("éƒµå¯„") || shipMethodLabel.includes("å®…é…")) {
  // éƒµå¯„ / å®…é…
  const zipPart  = zip ? `${zip} ` : "";
  shipPlaceText = `éƒµå¯„ï½œ${zipPart}${addr}`.trim();
}

// âœ… æ”¶ä»¶äººåç¨±ï¼šå„ªå…ˆç”¨ã€Œå¡«å–®æ”¶ä»¶äººã€(ship.name)ï¼Œæ²’æœ‰æ‰ç”¨ LINE æš±ç¨±
const customerName =
  String(ship.name || "").trim() ||
  String(displayName || "").trim() ||
  "";

// å‡ºè²¨é€šçŸ¥å¡ç‰‡
const flexBubble = buildShippingFlexBubbleV2({
  customerName,
  pickupPhone: ship.phone,
  orderId: displayOrderId,
  trackingNo: tracking_no || "",
  shipPlace: shipPlaceText,   // â† å‚³é€²å»ç”¨ shipPlace é€™å€‹æ¬„ä½åç¨±ï¼Œä½†å…§å®¹æ˜¯ shipPlaceText
  amountText,
  payMethodLabel
});

await linePushFlex(
  env,
  lineUserId,
  `æ‚¨çš„è¨‚å–® ${displayOrderId} å·²å‡ºè²¨`,
  flexBubble
);


                } catch (e) {
                  console.log("LINE Flex push (ship) error", order_id, e);
                }
              }
            
              return j(env, origin, { ok: true });
            }
                        // --- Adminï¼šç™¼å°¾æ¬¾çµå¸³é€£çµ + ç™¼ LINE é€šçŸ¥ ---
                        if (req.method === "POST" && path === "/admin/deposit/send-tail-link") {
                          const { op_key, order_id } = await body();
            
                          // é©—è­‰ OP_KEY
                          if (!op_key || String(op_key) !== String(env.OP_KEY)) {
                            return j(env, origin, { ok:false, error:"forbidden" }, 403);
                          }
                          if (!order_id) {
                            return j(env, origin, { ok:false, error:"order_id_required" }, 400);
                          }
            
                          const T = env.AT_ORDERS || "Orders";
                          const rows = await atListByField(env, T, "order_id", order_id);
                          const rec = rows && rows[0];
                          if (!rec) {
                            return j(env, origin, { ok:false, error:"order_not_found" }, 404);
                          }
            
                          const f = rec.fields || {};
            
                          // âœ… å°¾æ¬¾ = (ç¸½é¡ - è³¼ç‰©é‡‘æŠ˜æŠµ) - è¨‚é‡‘ ï¼›é¿å…è² æ•¸
const grossTotal = Number(f.total_amount || f.total || 0) || 0;
const creditUsed = Number(f.credit_used || 0) || 0;
const netTotal   = grossTotal - creditUsed;

const dep = Number(f.deposit_amount || 0) || 0;
const tailAmount = Math.max(0, netTotal - dep);
            
                          // ä¿ç•™æ—¥æœŸï¼ˆå¦‚æœæœ‰ï¼‰
                          const holdDateRaw =
                            (f.hold_until || f.deposit_expire_at || "").slice(0, 10);
                          const holdText = holdDateRaw ? holdDateRaw.replace(/-/g, "/") : "";
            
                          // è§£æ shipping_info æ‹¿ line è³‡è¨Š
                          let shipInfo = {};
                          try {
                            shipInfo = JSON.parse(f.shipping_info || "{}");
                          } catch (e) {
                            shipInfo = {};
                          }
            
                          const ship = shipInfo.ship || {};
                          let line   = shipInfo.line || shipInfo.line_profile || {};
            
                          let lineUserId =
                            line.user_id || line.userId || line.LINE_USER_ID || "";
                          let displayName =
                            line.display_name || line.displayName || line.name || "";
            
                          // æ²’æœ‰å­˜åˆ° Orders å°±ç”¨é›»è©± / Email å» LineMembers æ‰¾
                          if (!lineUserId) {
                            const phone = ship.phone || "";
                            const email = ship.email || "";
                            if (phone || email) {
                              const TM = env.AT_LINE_MEMBERS || "LineMembers";
                              const parts = [];
                              if (phone) parts.push(`{Phone}='${esc(phone)}'`);
                              if (email) parts.push(`{Email}='${esc(email)}'`);
                              if (parts.length) {
                                const formula =
                                  parts.length === 1 ? parts[0] : `OR(${parts.join(",")})`;
                                try {
                                  const res = await at(env, "GET", TM, "", null, {
                                    filterByFormula: formula,
                                    maxRecords: "1"
                                  });
                                  const mrec = res.records && res.records[0];
                                  if (mrec) {
                                    const mf = mrec.fields || {};
                                    lineUserId =
                                      mf.LineUserId ||
                                      mf.LINE_USER_ID ||
                                      mf.line_user_id ||
                                      "";
                                    displayName =
                                      displayName ||
                                      mf.DisplayName ||
                                      mf.display_name ||
                                      mf.Name ||
                                      "";
                                  }
                                } catch (e) {
                                  console.log("send_tail LineMembers search error", order_id, e);
                                }
                              }
                            }
                          }
            
                          if (!lineUserId) {
                            return j(env, origin, { ok:false, error:"no_line_user" }, 400);
                          }
            
                          const tailUrl = buildTailCheckoutUrl(env, order_id);
if (!tailUrl) {
  return j(env, origin, { ok:false, error:"invalid_order_id_for_link" }, 400);
}

// å°¾æ¬¾é‡‘é¡å­—ä¸²ï¼ˆå¸¶ NT$ï¼‰
const tailText =
  tailAmount > 0
    ? "NT$ " + tailAmount.toLocaleString("zh-TW")
    : "NT$ 0";

// çµ„å°¾æ¬¾æé†’ Flex å¡ç‰‡
const bubble = buildTailRemindFlexBubble({
  customerName: displayName || "",
  orderId: order_id || "",
  holdUntilText: holdText,
  tailAmountText: tailText,
  tailUrl
});

try {
  await linePushFlex(
    env,
    lineUserId,
    "å®šé‡‘å°¾æ¬¾æé†’",
    bubble
  );
} catch (e) {
  console.log("send_tail linePushFlex error", order_id, e);
  return j(env, origin, { ok:false, error:"line_push_error" }, 500);
}

return j(env, origin, { ok:true });

                        }
      

      // --- LINEï¼šæœƒå“¡ç¶å®š ---
      if (req.method === "POST" && path === "/line/bind-member") {
        const {
          line_user_id,
          display_name = "",
          picture_url = "",
          status_message = "",
          phone = "",
          email = "",
          name = ""
        } = await body();

        if (!line_user_id) {
          return j(env, origin, { ok: false, error: "line_user_id_required" }, 400);
        }

        const T = env.AT_LINE_MEMBERS || "LineMembers";

        // ç”¨ LineUserId æ‰¾èˆŠè¨˜éŒ„
        const rec = await atFindByField(env, T, "LineUserId", line_user_id);

        const fields = {
          LineUserId: line_user_id,
          DisplayName: display_name || null,
          Phone: phone || null,
          Email: email || null,
          Name: name || null,
          PictureUrl: picture_url || null,
          StatusMessage: status_message || null,
          updated_at: nowISO()
        };

        if (!rec) {
          fields.created_at = nowISO();
          await at(env, "POST", T, "", {
            records: [{ fields }]
          });
        } else {
          await at(env, "PATCH", T, "", {
            records: [{ id: rec.id, fields }]
          });
        }

        // âœ… é€™è£¡ï¼šç¶å®šæˆåŠŸ â†’ ç›´æ¥ç™¼ä¸€å¼µç¶å®šæˆåŠŸå¡ç‰‡åˆ°å®˜æ–¹ LINE
  try {
    await sendBindResultFlex(env, line_user_id, {
      success: true,
      displayName: display_name || name || ""
    });
  } catch (e) {
    console.log("LINE bind-member flex push error", line_user_id, e);
  }

        return j(env, origin, { ok: true });
      }

      // --- LINEï¼šå–å¾—æœƒå“¡è³‡æ–™ ---
if (req.method === "GET" && path === "/line/member-info") {
  const userId = url.searchParams.get("user_id") || "";
  if (!userId) {
    return j(env, origin, { ok: false, error: "missing_user_id" }, 400);
  }

  const T = env.AT_LINE_MEMBERS || "LineMembers";
  const rec = await atFindByField(env, T, "LineUserId", userId);
  if (!rec) {
    return j(env, origin, { ok: false, error: "not_found" }, 404);
  }

  const f = rec.fields || {};

  // å°å·¥å…·ï¼šåŒæ™‚æ”¯æ´ã€Œæ–‡å­—æ¬„ä½ã€è·Ÿã€ŒæŸ¥æ‰¾(lookup) é™£åˆ—æ¬„ä½ã€
  const pick = (v) => {
    if (Array.isArray(v)) {
      return (v[0] ?? "") + ""; // åªå–ç¬¬ä¸€å€‹å€¼
    }
    return v || "";
  };

   // âœ… è³¼ç‰©é‡‘é¤˜é¡ï¼šä¸€å¾‹ä»¥ CreditsLedger å³æ™‚åŠ ç¸½ç‚ºæº–ï¼ˆæ–¹æ¡ˆ 1ï¼‰
let creditRaw = 0;
try {
  creditRaw = await getCreditBalance(env, userId); // userId å°±æ˜¯ LineUserId
} catch (e) {
  console.log("member-info getCreditBalance error", e);
  creditRaw = 0;
}

  // é è¨­ 7-11 é–€å¸‚ï¼ˆå¯ä»¥æ˜¯æ–‡å­—æ¬„ä½ï¼Œä¹Ÿå¯ä»¥æ˜¯ lookupï¼‰
  const storeId   = pick(f.SevenStoreId);
  const storeName = pick(f.SevenStoreName);
  const storeAddr = pick(f.SevenStoreAddr);

  // é è¨­éƒµå¯„åœ°å€ & éƒµéå€è™Ÿï¼ˆä¹‹å¾Œä½ å¯ä»¥åŒæ¨£è¨­æˆæ–‡å­—æˆ– lookupï¼‰
  const shipZip   = pick(f.ShipZip);
  const shipAddr  = pick(f.ShipAddr);

  return j(env, origin, {
    ok: true,

    // èˆŠç‰ˆ key
    user_id: userId,
    display_name: f.DisplayName || "",
    picture_url: f.PictureUrl || "",
    status_message: f.StatusMessage || "",

    // çµ¦ checkout ç”¨
    userId,
    lineDisplayName: f.DisplayName || "",
    name:  pick(f.Name),
    phone: pick(f.Phone),
    email: pick(f.Email),
    credit: Number(creditRaw) || 0,

    storeId,
    storeName,
    storeAddr,
    shipZip,
    shipAddr,
  });
}

// =====================
// æœƒå“¡ç¶å®šçµæœ Flex å¡ç‰‡ï¼ˆåœ“åœˆï¼‹å‹¾å‹¾ç‰ˆï¼‰
// =====================
function buildBindResultFlex({ success = true } = {}) {
  const title = success ? "æœƒå“¡ç¶å®šæˆåŠŸï¼" : "æœƒå“¡ç¶å®šå¤±æ•—";
  const subtitle = success
    ? "æ­å–œæ‚¨ï¼Œæ‚¨çš„æœƒå“¡å¸³æˆ¶å·²æˆåŠŸç¶å®šã€‚"
    : "ç¶å®šæ²’æœ‰æˆåŠŸï¼Œè«‹ç¨å¾Œå†è©¦ä¸€æ¬¡æˆ–è¯ç¹«å®¢æœå”åŠ©è™•ç†ã€‚";

  const icon = success ? "âœ“" : "âœ•";
  const circleColorOuter = success ? "#7DD3FC" : "#FCA5A5";
  const circleColorInner = success ? "#0EA5E9" : "#EF4444";

  return {
    type: "flex",
    altText: title,
    contents: {
      type: "bubble",
      size: "mega",
      body: {
        type: "box",
        layout: "vertical",
        paddingAll: "20px",
        backgroundColor: "#FFFFFF", // ç™½åº•
        contents: [
          // ä¸Šæ–¹åœ“åœˆï¼‹å‹¾å‹¾
          {
            type: "box",
            layout: "vertical",
            alignItems: "center",
            contents: [
              {
                type: "box",
                layout: "vertical",
                width: "96px",
                height: "96px",
                cornerRadius: "100px",
                backgroundColor: circleColorOuter,
                justifyContent: "center",
                alignItems: "center",
                contents: [
                  {
                    type: "box",
                    layout: "vertical",
                    width: "76px",
                    height: "76px",
                    cornerRadius: "100px",
                    backgroundColor: circleColorInner,
                    justifyContent: "center",
                    alignItems: "center",
                    contents: [
                      {
                        type: "text",
                        text: icon,
                        size: "xl",
                        weight: "bold",
                        color: "#FFFFFF",
                        align: "center"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          // æ¨™é¡Œï¼šæœƒå“¡ç¶å®šæˆåŠŸï¼
          {
            type: "text",
            text: title,
            margin: "lg",
            size: "lg",
            weight: "bold",
            align: "center",
            color: "#111827"
          },
          // å°å­—èªªæ˜
          {
            type: "text",
            text: subtitle,
            margin: "sm",
            size: "sm",
            align: "center",
            color: "#6B7280",
            wrap: true
          }
        ]
      }
    }
  };
}

// æ¨é€ç¶å®šçµæœ Flexï¼ˆæˆåŠŸ / å¤±æ•—å…±ç”¨ï¼‰
async function sendBindResultFlex(env, lineUserId, opts = {}) {
  if (!lineUserId) return;

  const msg = buildBindResultFlex(opts);

  await fetch("https://api.line.me/v2/bot/message/push", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${env.LINE_CHANNEL_ACCESS_TOKEN}`,
    },
    body: JSON.stringify({
      to: lineUserId,
      messages: [msg],
    }),
  });
}

// --- Checkout ---
// âœ… æ³¨æ„ï¼šè«‹ç”¨é€™æ•´æ®µå®Œæ•´å–ä»£ä½ åŸæœ¬çš„ /checkout å€å¡Šï¼ˆä¸è¦æ··è²¼ï¼‰
if (req.method === "POST" && path === "/checkout") {
  const {
    cart_token,
    payment_method = "bank_transfer",
    shipping_info = {},
    tail_of_order = "",
    is_tail = false
  } = await body();
  const order_id = "OD" + Date.now();

  // âœ… è‹¥ä½ æª”æ¡ˆåŸæœ¬å°±æœ‰ resolveLineUserFromShippingï¼Œå°±ç”¨åŸæœ¬çš„ï¼›æ²’æœ‰æ‰è£œä¸Šï¼ˆé¿å…é‡è¤‡å®£å‘Šï¼‰
  if (typeof globalThis.resolveLineUserFromShipping !== "function") {
    globalThis.resolveLineUserFromShipping = async function resolveLineUserFromShipping(env, shipping_info) {
      const shipInfo = shipping_info || {};
      const ship = shipInfo.ship || {};

      // å…ˆåƒ shipping_info è£¡çš„ line
      const line = shipInfo.line || shipInfo.line_profile || shipInfo.lineProfile || {};
      let lineUserId =
        line.user_id || line.userId || line.LINE_USER_ID ||
        shipInfo.line_user_id || shipInfo.lineUserId || "";
      let displayName =
        line.display_name || line.displayName || line.name || "";

      // æ²’æœ‰å°±ç”¨ phone/email å» LineMembers æ‰¾
      if (!lineUserId) {
        const phone = String(ship.phone || "").trim();
        const email = String(ship.email || "").trim();

        if (phone || email) {
          const TM = env.AT_LINE_MEMBERS || "LineMembers";
          const parts = [];
          if (phone) parts.push(`{Phone}='${esc(phone)}'`);
          if (email) parts.push(`{Email}='${esc(email)}'`);
          const formula = parts.length === 1 ? parts[0] : `OR(${parts.join(",")})`;

          const res = await at(env, "GET", TM, "", null, { filterByFormula: formula, maxRecords: "1" });
          const mrec = res?.records && res.records[0];
          if (mrec) {
            const mf = mrec.fields || {};
            lineUserId = mf.LineUserId || mf.LINE_USER_ID || mf.line_user_id || "";
            displayName = displayName || mf.DisplayName || mf.display_name || mf.Name || "";
          }
        }
      }

      return { lineUserId, displayName };
    };
  }
  const resolveLineUserFromShipping = globalThis.resolveLineUserFromShipping;

  // =========
  // 0) åŸºæœ¬æª¢æŸ¥ï¼ˆå…ˆæ“‹æ‰ç¼º cart_tokenï¼‰
  // =========
  const cartToken = String(cart_token || "").trim();
  if (!cartToken) {
    return j(env, origin, { ok: false, error: "missing_cart_token" }, 400);
  }

  const pmRaw = String(payment_method || "").trim().toLowerCase();
const pm = (pmRaw === "cod711" || pmRaw === "pickup_711" || pmRaw === "pickup711") ? "cod_711" : pmRaw;
  const policy = creditPolicy(pm);

  // =========
  // 1) å…ˆæŠ“ CartToken è¨˜éŒ„ï¼ˆä¸€å®šè¦åœ¨æœ€å‰é¢ï¼Œé¿å… CT/cartRec0 å…ˆç”¨å¾Œå®£å‘Šç´…å­—ï¼‰
  // =========
  const CT = env.AT_CARTS || "CartToken";
  const cartRec0 = await atFindByField(env, CT, "CartToken", cartToken);
  if (!cartRec0) {
    return j(env, origin, {
      ok: false,
      error: "cart_token_not_found",
      message: "æ‰¾ä¸åˆ°æ­¤è³¼ç‰©è»Šï¼Œè«‹å›åˆ°è³¼ç‰©è»Šé‡æ–°é€²å…¥çµå¸³é ã€‚"
    }, 400);
  }

  const cartF0 = cartRec0.fields || {};
  const cartStatus0 = String(cartF0.status || cartF0.Status || "").toLowerCase();
  const boundOrderId = String(cartF0.checked_out_order_id || cartF0.checked_out_orderId || "").trim();

  const isCheckingOut = (cartStatus0 === "checking_out");
const isBoundOrSubmitted = (!!cartF0.checked_out || cartStatus0 === "submitted");

function msgNeedSupport(id) {
  const oid = String(id || "").trim();
  return (
    "æ­¤è³¼ç‰©è»Šå·²é€å‡ºï¼Œè‹¥æ‚¨åœ¨è·³è½‰ä»˜æ¬¾é€”ä¸­é—œé–‰é é¢ã€åˆ·å¡å¤±æ•—ã€æˆ–ç³»çµ±ç„¡æ³•å®Œæˆçµå¸³ï¼Œè«‹è¯ç¹« LINE å®˜æ–¹å®¢æœå”åŠ©è™•ç†" +
    (oid ? `ï¼ˆè«‹æä¾›æˆ–æˆªåœ–è¨‚å–®ç·¨è™Ÿï¼š${oid}ï¼‰` : "")
  );
}

if (isCheckingOut) {
  return j(env, origin, {
    ok: false,
    error: "cart_locked",
    message: msgNeedSupport(boundOrderId),
    order_id: boundOrderId || ""
  }, 409);
}

// =========
// âœ… ä¸€è»Šä¸€å–®ï¼ˆæ­£å¼é›»å•†ç‰ˆï¼‰ï¼š
// - å·²æœ‰ active pendingï¼šåŒå–®æ›´æ–°ä»˜æ¬¾æ–¹å¼/æ”¶ä»¶è³‡æ–™ï¼ˆä¸æ”¹å•†å“/é‡‘é¡/è³¼ç‰©é‡‘/é‹è²»ï¼‰
// - æ‰¾ä¸åˆ° activeï¼šè¦–ç‚º staleï¼Œæ¸…æ‰ CartToken ç¶å®šï¼Œè®“æµç¨‹å¾€ä¸‹å»ºæ–°å–®
if (isBoundOrSubmitted) {
  const active = await findActiveOrderByCartToken(env, cartToken);

  // âœ… staleï¼šCT é¡¯ç¤ºç¶å–®ï¼Œä½†å¯¦éš›æ‰¾ä¸åˆ°è¨‚å–®
  if (!active || !active.id) {
    try {
      await at(env, "PATCH", CT, "", {
        records: [{
          id: cartRec0.id,
          fields: {
            checked_out: false,
            checked_out_order_id: "",
            status: "open",
            closed_at: ""
          }
        }]
      });
    } catch (e) {
      console.log("checkout: clear stale cart binding failed", e?.message || e);
    }
    // âœ… ä¸ returnï¼Œç¹¼çºŒå¾€ä¸‹èµ°ã€ŒåŠ é–â†’å»ºæ–°å–®ã€
  } else {
    const af = active.fields || {};
    const existingOrderId = String(af.order_id || active.id || "").trim();
    const ps = String(af.pay_status || "").toLowerCase();
    const st = String(af.status || "").toLowerCase();
    const oldPm = String(af.payment_method || "").trim().toLowerCase();

    // 1) å·²ä»˜æ¬¾/å‡ºè²¨/å®Œæˆï¼šé–ä½
    const isFinal =
      ps === "paid_ok" ||
      ps === "deposit_ok" ||
      st === "shipped" ||
      st === "completed";

    if (isFinal) {
      return j(env, origin, {
        ok: false,
        error: "already_checked_out",
        order_id: existingOrderId,
        message: msgNeedSupport(existingOrderId)
      }, 409);
    }

    // 2) åˆ†æœŸé€å¯©ä¸­ï¼šé–ä½
    const isInstallmentReview =
      oldPm.startsWith("zero_card_") ||
      oldPm.startsWith("yufu_inst_");

    if (isInstallmentReview) {
      return j(env, origin, {
        ok: false,
        error: "installment_reviewing",
        order_id: existingOrderId,
        message: msgNeedSupport(existingOrderId)
      }, 409);
    }

// 3) pendingï¼šå…è¨±æ›´æ›ä»˜æ¬¾æ–¹å¼ï¼ˆåŒå–®ï¼‰
const pmNew = String(payment_method || "").trim().toLowerCase();

// âœ… é‡ç”¨ pending å–®æ™‚ï¼šè¦åŒæ­¥ credit_used / net_amountï¼Œä¸ç„¶ PayUNI æœƒç”¨èˆŠå€¼è«‹æ¬¾
const baseTotal = Number(af.total_amount || af.total || 0) || 0;
let usedReq = 0;
try {
  usedReq = Math.max(0, Math.floor(Number(shipping_info?.credit_used ?? 0) || 0));
} catch (e) {}
usedReq = Math.min(usedReq, baseTotal);
const netNew = Math.max(0, Math.round(baseTotal - usedReq));

// è®“ shipping_info ä¹Ÿä¸€è‡´ï¼ˆé¿å…å‰ç«¯/å¾Œç«¯çœ‹ä¸åŒï¼‰
try {
  if (shipping_info && typeof shipping_info === "object") {
    if (usedReq > 0) shipping_info.credit_used = usedReq;
    else delete shipping_info.credit_used;
  }
} catch (e) {}

const shipNewStr = JSON.stringify(shipping_info || {});
const T = env.AT_ORDERS || "Orders";

try {
  const patchFields = {
    shipping_info: shipNewStr,
    credit_used: usedReq,
    net_amount: netNew
  };
  if (pmNew && pmNew !== oldPm) patchFields.payment_method = pmNew;

  await at(env, "PATCH", T, "", {
    records: [{ id: active.id, fields: patchFields }]
  });
} catch (e) {
  console.log("checkout: reuse pending patch failed", existingOrderId, e?.message || e);
}

    // âœ… ç¢ºä¿ CartToken æŒ‡å‘åŒä¸€å¼µè¨‚å–®
    try {
      await at(env, "PATCH", CT, "", {
        records: [{
          id: cartRec0.id,
          fields: {
            checked_out: true,
            checked_out_order_id: existingOrderId,
            status: "submitted",
            closed_at: nowISO()
          }
        }]
      });
    } catch (e) {}

    // âœ… åªæœ‰é›¢ç·šä»˜æ¬¾æ‰ç™¼ã€Œçµå–®å®Œæˆã€å¡ï¼ˆç·šä¸Šä»˜æ¬¾è¦ç­‰ notify/return æˆåŠŸï¼‰
    try {
      const isOnline =
        pmNew.startsWith("paid_") ||
        pmNew === "aftee_direct" ||
        pmNew === "paid_aftee_direct";

      if (!isOnline) {
        let _lineUserId = String(af.line_user_id || "").trim();
        let _displayName = String(af.display_name || af.customer_name || "").trim();

        try {
          const si = (typeof shipping_info === "string") ? JSON.parse(shipping_info) : (shipping_info || {});
          const line = si.line || si.line_profile || {};
          if (!_lineUserId) _lineUserId = String(line.user_id || line.userId || line.LINE_USER_ID || "").trim();
          if (!_displayName) _displayName = String(line.display_name || line.displayName || "").trim();
        } catch (e) {}

        if (_lineUserId) {
          await sendCheckoutCompleteFlex(env, {
            lineUserId: _lineUserId,                 // âœ… ä¿®æ­£ï¼šä¸è¦ç”¨ä¸å­˜åœ¨çš„ lineUserId
            displayName: _displayName || "",         // âœ… ä¿®æ­£ï¼šä¸è¦ç”¨ä¸å­˜åœ¨çš„ displayName
            orderId: existingOrderId,
            amount: Number(af.net_amount || af.total_amount || 0) || 0,
            paymentMethod: pmNew,
            shipping_info
          });
        }
      }
    } catch (e) {
      console.log("checkout reuse: send flex failed", existingOrderId, e?.message || e);
    }

    // âœ… é‡ç”¨æˆåŠŸï¼šå›å‚³çµ¦å‰ç«¯ï¼Œå‰ç«¯æ¥è‘—ç”¨é€™å¼µå–®å»èµ° payuni/start æˆ–é›¢ç·šæç¤º
    return j(env, origin, {
      ok: true,
      order_id: existingOrderId,
      reused: true,
      updated_payment_method: (pmNew && pmNew !== oldPm),
      payment_method: pmNew || oldPm,
      status: String(af.status || ""),
      pay_status: String(af.pay_status || ""),
      total_amount: baseTotal,
      net_amount: netNew,
      credit_used: usedReq
    }, 200);
  }
}
  // lock ç‹€æ…‹æ——æ¨™ï¼ˆfinally ç”¨ï¼‰
  let lockId = "";
  let lockAcquired = false;    // å·²å¯«å…¥ checking_out
  let lockCommitted = false;   // å·²æˆåŠŸç¶å®š orderï¼ˆä¸è©²è§£é–ï¼‰
  let stockDeducted = false;   // è‹¥æ‰£åº«å­˜æˆåŠŸï¼Œå¾Œé¢å¤±æ•—è¦è£œå›

  try {
    // =========
    // 2) é é– checking_outï¼šé˜²é€£é»åŒæ™‚é€²ä¾†
    // =========
    lockId =
      (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function")
        ? crypto.randomUUID()
        : ("ck_" + Date.now() + "_" + Math.random().toString(16).slice(2));

    await at(env, "PATCH", CT, "", {
      records: [{
        id: cartRec0.id,
        fields: {
          status: "checking_out",
          checkout_lock_id: lockId,
          checkout_lock_at: nowISO()
        }
      }]
    });

    // âœ… å›è®€é©—è­‰ï¼šä¸æ˜¯æˆ‘çš„ lock å°±æ“‹
    let cartRec1 = null;
    try { cartRec1 = await atFindByField(env, CT, "CartToken", cartToken); } catch {}
    const lockNow = String(cartRec1?.fields?.checkout_lock_id || "").trim();
    const stNow = String(cartRec1?.fields?.status || cartRec1?.fields?.Status || "").toLowerCase();

    if (lockNow !== lockId || stNow !== "checking_out") {
      return j(env, origin, {
        ok: false,
        error: "cart_locked_by_other",
        message: "æ­¤è³¼ç‰©è»Šæ­£åœ¨çµå¸³ä¸­ï¼Œè«‹å‹¿é‡è¤‡é€å‡ºã€‚"
      }, 409);
    }

    lockAcquired = true;

    // =========
    // 4) è³¼ç‰©é‡‘ request æª¢æŸ¥ï¼ˆæœƒå“¡/é¤˜é¡/ç¦ç”¨æƒ…å¢ƒï¼‰
    // =========
    const creditUsedReq = Math.max(0, Number(shipping_info?.credit_used ?? 0) || 0);

    // âœ… åŒ¯æ¬¾å®šé‡‘ä¸å¯ç”¨è³¼ç‰©é‡‘ï¼ˆä¿ç•™ä½ çš„è¦å‰‡ï¼‰
    if (policy === "DISALLOW" && creditUsedReq > 0) {
      return j(env, origin, {
        ok: false,
        error: "deposit_old_no_credit",
        message: "åŒ¯æ¬¾å®šé‡‘ä¸å¯ä½¿ç”¨è³¼ç‰©é‡‘"
      }, 400);
    }

    // æŠ½ line_user_idï¼ˆæ”¯æ´å¤šå‘½åï¼‰
    let creditLineUserId =
      String(shipping_info?.line_user_id || "").trim() ||
      String(shipping_info?.lineUserId || "").trim() ||
      String(shipping_info?.line?.user_id || "").trim() ||
      String(shipping_info?.line?.userId || "").trim() ||
      String(shipping_info?.line?.LINE_USER_ID || "").trim() ||
      String(shipping_info?.line_profile?.user_id || "").trim() ||
      String(shipping_info?.line_profile?.userId || "").trim();

    // å‰ç«¯æ²’å¸¶ line idï¼Œä½†æœ‰ phone/email â†’ è£œ
    if (creditUsedReq > 0 && !creditLineUserId) {
      try {
        const r = await resolveLineUserFromShipping(env, shipping_info);
        creditLineUserId = String(r?.lineUserId || "").trim();
      } catch (e) {
        console.log("resolveLineUserFromShipping for credit check error", e);
      }
    }

    // æœªç¶å®šé‚„å¸¶ credit_used â†’ ç›´æ¥æ‹’çµ•
    let creditBalance = 0;
    if (creditUsedReq > 0) {
      const is_bound = await isBoundMember(env, creditLineUserId);
      if (!is_bound) {
        return j(env, origin, {
          ok: false,
          error: "credit_member_required",
          message: "è³¼ç‰©é‡‘åƒ…é™å·²ç™»å…¥/å·²ç¶å®šæœƒå“¡ä½¿ç”¨"
        }, 400);
      }

      creditBalance = await getCreditBalance(env, creditLineUserId);
      if (creditUsedReq > creditBalance) {
        return j(env, origin, {
          ok: false,
          error: "credit_insufficient",
          message: "è³¼ç‰©é‡‘é¤˜é¡ä¸è¶³"
        }, 400);
      }
    }

    // âœ… åŒ¯æ¬¾å®šé‡‘ä¸é–‹æ”¾é¢äº¤
    if (policy === "DISALLOW" && shipping_info?.ship?.type === "meetup") {
      return j(env, origin, { ok: false, error: "deposit_old_no_meetup", message: "åŒ¯æ¬¾å®šé‡‘ä¸é–‹æ”¾é¢äº¤" }, 400);
    }

    // =========
    // 5) æ–°ç‰ˆæª¢æŸ¥ï¼špaid_ok æ“‹ã€pending é‡ç”¨ã€offline pending æ“‹
    // =========
    {
      const T = env.AT_ORDERS || "Orders";
      const existList = await atListByField(env, T, "cart_token", cartToken) || [];

      const paidOk = existList.find(r => {
        const f = r.fields || {};
        const st = String(f.status || "").toLowerCase();
        const ps = String(f.pay_status || "").toLowerCase();
        return (st === "paid" || st === "shipped" || st === "completed" || ps === "paid_ok");
      });

      if (paidOk) {
        return j(env, origin, {
          ok: false,
          error: "cart_already_submitted",
          message: "æ­¤è³¼ç‰©è»Šå·²å®Œæˆçµå¸³ï¼Œè«‹ä¸è¦é‡è¤‡é€å‡º"
        }, 400);
      }

      const pm2 = pm;

      // offline pending æ“‹
      const isOffline =
        pm2.startsWith("cod_") ||
        pm2.startsWith("atm_") ||
        pm2.startsWith("atm") ||
        pm2.startsWith("deposit_") ||
        pm2.startsWith("deposit") ||
        pm2.startsWith("deposit_old") ||
        pm2 === "deposit_old" ||
        pm2 === "bank_transfer" ||
        pm2 === "meetup_cash";

      if (isOffline) {
        const pendingOffline = existList.find(r => {
          const f = r.fields || {};
          const oldPm = String(f.payment_method || "");
          const st = String(f.status || "").toLowerCase();
          const ps = String(f.pay_status || "").toLowerCase();
          if (st === "cancelled" || st === "failed" || ps === "cancelled" || ps === "failed") return false;

          const oldIsOffline =
            oldPm.startsWith("cod_") ||
            oldPm.startsWith("atm_") ||
            oldPm.startsWith("atm") ||
            oldPm.startsWith("deposit_") ||
            oldPm.startsWith("deposit") ||
            oldPm.startsWith("deposit_old") ||
            oldPm === "deposit_old" ||
            oldPm === "bank_transfer" ||
            oldPm === "meetup_cash";

          return oldIsOffline && (st === "submitted" || st === "pending" || ps === "pending");
        });

        if (pendingOffline) {
          return j(env, origin, {
            ok: false,
            error: "offline_payment_pending",
            message: "æ­¤è³¼ç‰©è»Šå·²æœ‰åŒ¯æ¬¾/è²¨åˆ°ä»˜æ¬¾è¨‚å–®å¾…è™•ç†ï¼Œå¦‚éœ€ä¿®æ”¹è«‹è¯çµ¡å®¢æœ"
          }, 400);
        }
      }

      // pending ZeroCard â†’ é– CartToken + æ“‹
      const pendingZero = existList.find(r => {
        const f = r.fields || {};
        const oldPm = String(f.payment_method || "");
        const st = String(f.status || "").toLowerCase();
        const ps = String(f.pay_status || "").toLowerCase();
        if (st === "cancelled" || st === "failed" || ps === "cancelled" || ps === "failed") return false;
        return oldPm.startsWith("zero_card_") && (st === "submitted" || st === "pending" || ps === "pending");
      });

      if (pendingZero?.fields?.order_id) {
        const oid = String(pendingZero.fields.order_id || "").trim();
        try {
          await at(env, "PATCH", CT, "", {
            records: [{
              id: cartRec0.id,
              fields: {
                checked_out: true,
                checked_out_order_id: oid,
                checked_out_at: nowISO(),
                status: "submitted",
                closed_at: nowISO()
              }
            }]
          });
          lockCommitted = true;
        } catch {}

        return j(env, origin, {
          ok: false,
          error: "cart_already_submitted",
          message: "æ­¤è³¼ç‰©è»Šå·²æœ‰é›¶å¡è¨‚å–®å¾…è™•ç†ï¼Œè«‹å‹¿é‡è¤‡é€å‡ºã€‚",
          order_id: oid
        }, 409);
      }

      // pending YUFU â†’ é– CartToken + æ“‹
      if (pm2.startsWith("yufu_inst_")) {
        const pendingYufu = existList.find(r => {
          const f = r.fields || {};
          const oldPm = String(f.payment_method || "");
          const st = String(f.status || "").toLowerCase();
          const ps = String(f.pay_status || "").toLowerCase();
          if (st === "cancelled" || st === "failed" || ps === "cancelled" || ps === "failed") return false;
          return oldPm.startsWith("yufu_inst_") && (st === "submitted" || st === "pending" || ps === "pending");
        });

        const oid = String(pendingYufu?.fields?.order_id || "").trim();
        if (oid) {
          try {
            await at(env, "PATCH", CT, "", {
              records: [{
                id: cartRec0.id,
                fields: {
                  checked_out: true,
                  checked_out_order_id: oid,
                  checked_out_at: nowISO(),
                  status: "submitted",
                  closed_at: nowISO()
                }
              }]
            });
            lockCommitted = true;
          } catch {}

          return j(env, origin, {
            ok: false,
            error: "cart_already_submitted",
            message: "æ­¤è³¼ç‰©è»Šå·²æœ‰è£•å¯Œåˆ†æœŸè¨‚å–®å¾…è™•ç†ï¼Œè«‹å‹¿é‡è¤‡é€å‡ºã€‚",
            order_id: oid
          }, 409);
        }
      }

      // pending paid_ åŒä»˜æ¬¾æ–¹å¼ â†’ é‡ç”¨ï¼ˆå› 200ï¼‰
      if (pm2.startsWith("paid_")) {
        const pendingPaid = existList.find(r => {
          const f = r.fields || {};
          const oldPm = String(f.payment_method || "");
          const st = String(f.status || "").toLowerCase();
          const ps = String(f.pay_status || "").toLowerCase();
          if (st === "cancelled" || st === "failed" || ps === "cancelled" || ps === "failed") return false;
          return (oldPm === pm2) && (st === "submitted" || st === "pending" || ps === "pending");
        });

        if (pendingPaid?.fields?.order_id) {
          const f = pendingPaid.fields || {};
          try {
            await at(env, "PATCH", CT, "", {
              records: [{
                id: cartRec0.id,
                fields: {
                  checked_out: true,
                  checked_out_order_id: String(f.order_id || ""),
                  checked_out_at: nowISO(),
                  status: "submitted",
                  closed_at: nowISO()
                }
              }]
            });
            lockCommitted = true;
          } catch {}

          // âœ… åŒä»˜æ¬¾æ–¹å¼é‡ç”¨ pendingï¼šä¹Ÿè¦åŒæ­¥ credit_used / net_amountï¼ˆç”¨æœ¬æ¬¡ shipping_infoï¼‰
try {
  const baseTotal2 = Number(f.total_amount || f.total || 0) || 0;
  let usedReq2 = 0;
  try {
    usedReq2 = Math.max(0, Math.floor(Number(shipping_info?.credit_used ?? 0) || 0));
  } catch (e) {}
  usedReq2 = Math.min(usedReq2, baseTotal2);
  const netNew2 = Math.max(0, Math.round(baseTotal2 - usedReq2));

  // åŒæ­¥ shipping_info.credit_used
  try {
    if (shipping_info && typeof shipping_info === "object") {
      if (usedReq2 > 0) shipping_info.credit_used = usedReq2;
      else delete shipping_info.credit_used;
    }
  } catch (e) {}

  const shipStr2 = JSON.stringify(shipping_info || {});
  await at(env, "PATCH", T, "", {
    records: [{
      id: pendingPaid.id,
      fields: {
        shipping_info: shipStr2,
        credit_used: usedReq2,
        net_amount: netNew2
      }
    }]
  });

  // ä¹ŸæŠŠè¦å›å‚³çµ¦å‰ç«¯çš„ f å€¼è¦†è“‹ï¼ˆé¿å…å‰ç«¯é¡¯ç¤ºèˆŠå€¼ï¼‰
  f.credit_used = usedReq2;
  f.net_amount  = netNew2;
} catch (e) {
  console.log("checkout: reuse same-paid patch credit/net failed", String(f?.order_id || ""), e?.message || e);
}

          return j(env, origin, {
            ok: true,
            order_id: f.order_id,
            reused: true,
            locked: true,
            payment_method: String(f.payment_method || ""),
            status: String(f.status || ""),
            pay_status: String(f.pay_status || ""),
            credit_used: Number(f.credit_used || 0) || 0,
            net_amount: Number(f.net_amount || 0) || 0,
            next_url: "" // âœ… é‡ç”¨æ—¢æœ‰ pending å–®ï¼Œä¸å¼·åˆ¶æ”¹è·³è½‰
          }, 200);
        }
      }
    }

    // =========
    // 6) å–å¾—è³¼ç‰©è»Šã€è¨ˆç®—é‡‘é¡ã€æ±ºå®šæœ€çµ‚ credit_used
    // =========
    const list = await cartItems(env, cartToken);
    if (!list.length) {
      return j(env, origin, { ok: false, error: "empty_cart" }, 400);
    }

    const sum = sumCart(list);
    const baseTotal = Number(sum.total || 0) || 0;

    // æœ€çµ‚å…¥å–®è³¼ç‰©é‡‘ï¼ˆä¸Šé™ = baseTotalï¼‰
    let creditUsedFinal = 0;
    try {
      const raw = shipping_info?.credit_used ?? 0;
      const n = Math.floor(Number(raw) || 0);
      if (!Number.isNaN(n) && n > 0) creditUsedFinal = Math.min(n, baseTotal);
    } catch {}
    if (shipping_info && typeof shipping_info === "object") shipping_info.credit_used = creditUsedFinal;

    // =========
    // 7) ä»˜æ¬¾æ–¹å¼ç‰¹æ®Šè¦å‰‡ï¼ˆè¨‚é‡‘ä¸å¯ç”¨è³¼ç‰©é‡‘ã€ç·šä¸Šä»˜æ¬¾éœ€è‡³å°‘ 1 å…ƒï¼‰
    // =========
    const ship = (shipping_info && shipping_info.ship) || {};
    const phone = String(ship.phone || "").trim();
    const email = String(ship.email || "").trim();

    // è¨‚é‡‘/éƒ¨åˆ†åŒ¯æ¬¾ï¼šå¾Œç«¯ç¡¬æ“‹ã€Œä¸èƒ½ç”¨è³¼ç‰©é‡‘ã€
    const isDepositOnly =
      (pm.includes("deposit") && !pm.includes("full") && !pm.includes("new_full")) ||
      (ship?.deposit && ship.deposit?.type && String(ship.deposit.type).includes("partial"));

    if (isDepositOnly && creditUsedFinal > 0) {
      return j(env, origin, { ok: false, error: "deposit_cannot_use_credit" }, 400);
    }

    // ç·šä¸Šä»˜æ¬¾/åˆ†æœŸå¿…é ˆè‡³å°‘ç•™ 1 å…ƒå¯¦ä»˜
    const needsPositivePay =
      pm.startsWith("paid_") ||
      pm.startsWith("zero_card_") ||
      pm.startsWith("yufu_inst_");

    const netPay = Math.round(baseTotal - creditUsedFinal);
    if (needsPositivePay && baseTotal > 0 && netPay <= 0) {
      return j(env, origin, {
        ok: false,
        error: "credit_full_not_allowed",
        message: "ç·šä¸Šä»˜æ¬¾/åˆ†æœŸéœ€ä¿ç•™è‡³å°‘ NT$1 å¯¦ä»˜é‡‘é¡ï¼Œè³¼ç‰©é‡‘ä¸å¯å…¨é¡æŠ˜æŠµã€‚è«‹èª¿æ•´è³¼ç‰©é‡‘æˆ–æ”¹ç”¨åŒ¯æ¬¾/è²¨åˆ°ä»˜æ¬¾/é¢äº¤ã€‚"
      }, 400);
    }

    // =========
    // 8) COD å¿…é ˆå·²ç¶å®šæœƒå“¡ï¼ˆä¿ç•™ä½ çš„é‚è¼¯ï¼‰
    // =========
    if (pm.startsWith("cod_")) {
      const LM = env.AT_LINE_MEMBERS || "LineMembers";
      let bound = false;

      if (phone) {
        const m1 = await atFindByField(env, LM, "Phone", phone);
        if (m1) bound = true;
      }
      if (!bound && email) {
        const m2 = await atFindByField(env, LM, "Email", email);
        if (m2) bound = true;
      }

      if (!bound) {
        return j(env, origin, {
          ok: false,
          error: "cod_need_bind",
          message: "ç¬¬ä¸€æ¬¡è²¨åˆ°ä»˜æ¬¾è«‹å…ˆåœ¨å®˜æ–¹ LINE å®Œæˆæœƒå“¡ç¶å®šï¼Œæˆ–æ”¹ç”¨åŒ¯æ¬¾ / ç·šä¸Šä»˜æ¬¾ã€‚"
        }, 400);
      }
    }

    // =========
    // 9) è¨‚å–®ç‹€æ…‹ / ä»˜æ¬¾ç‹€æ…‹
    // =========
    let status = "submitted";
    let pay_status = "pending";

    // ä½ åŸæœ¬çš„ï¼šCOD è¦–ç‚ºå·²ç¢ºèªå¾…å‡ºè²¨
    if (pm.startsWith("cod_")) {
      status = "paid";
      pay_status = "paid_ok";
    } else if (
      pm.startsWith("paid_") ||
      pm.startsWith("zero_card_") ||
      pm.startsWith("yufu_inst_") ||
      pm.startsWith("deposit") ||
      pm.startsWith("atm")
    ) {
      status = "submitted";
      pay_status = "pending";
    }

    // =========
    // 10) å•†å“æ˜ç´°ï¼ˆnormItems / items_text / items_jsonï¼‰
    // =========
    const normItems = (sum.items || list || []).map(it => {
      const sku = it.sku || it.SKU || it.Sku || it.SkuNo || "";
      const name = it.name || it.Name || it.product_name || it.ProductName || sku;
      const qty = Number(it.qty ?? it.Qty ?? it.quantity ?? it.Quantity ?? 1);
      const price = Number(it.price ?? it.Price ?? it.unit_price ?? it.UnitPrice ?? 0);
      return { sku, name, qty, price };
    });

    const items_text = normItems.map(it =>
      `ãƒ»${it.name} x ${it.qty}ï¼ˆNT$ ${Number(it.price || 0).toLocaleString("zh-TW")}ï¼‰`
    ).join("\n");

    const items_json = JSON.stringify(normItems);

    // =========
    // 11) å– lineUserId / displayNameï¼ˆä¸¦åŒæ­¥çµ¦ shipping_infoï¼‰
    // =========
    let lineUserId =
      (shipping_info && shipping_info.line && shipping_info.line.user_id) || "";

    let displayName =
      (shipping_info && shipping_info.line &&
        (shipping_info.line.display_name || shipping_info.line.displayName || shipping_info.line.name)) || "";

    try {
      const r = await resolveLineUserFromShipping(env, shipping_info);
      if (!lineUserId && r?.lineUserId) lineUserId = String(r.lineUserId).trim();
      if (!displayName && r?.displayName) displayName = String(r.displayName).trim();
    } catch (e) {
      console.log("resolveLineUserFromShipping error", e);
    }

// 12) å…ˆæ‰£åº«å­˜ï¼ˆéå°¾æ¬¾ï¼‰
// âœ… æ”¹æˆï¼šåªæœ‰ã€Œéç·šä¸Šå³æ™‚é‡‘æµã€æ‰å…ˆæ‰£ï¼ˆé¿å…æœªä»˜æ¬¾å¡åº«å­˜ï¼‰
// ç·šä¸Šå³æ™‚é‡‘æµï¼špaid_* / zero_card_* / yufu_*  -> ç­‰ä»˜æ¬¾æˆåŠŸæ‰æ‰£
let stockDeducted = false;

const isOnlinePay =
  pm.startsWith("paid_") ||
  pm.startsWith("zero_card_") ||
  pm.startsWith("yufu_");

if (!is_tail && !isOnlinePay) {
  try {
    await adjustStockByItems(env, normItems || [], -1);
    stockDeducted = true;
    console.log("[Checkout] stock deducted for order:", order_id);
  } catch (e) {
    if (String(e?.message || "").includes("out_of_stock")) {
      return j(env, origin, { ok:false, error:"out_of_stock" }, 409);
    }
    throw e;
  }
} else if (!is_tail && isOnlinePay) {
  console.log("[Checkout] online pay => skip stock deduct at checkout, wait for pay success:", order_id);
}

    // =========
    // 13) å»ºå–®ï¼ˆOrdersï¼‰
    // =========
    const T = env.AT_ORDERS || "Orders";

    const used = Math.max(0, Number(creditUsedFinal || 0) || 0);
    const netAmount = Math.max(0, Math.round(baseTotal - used));

    // è£•å¯Œç”³è«‹è³‡æ–™æ–‡å­—åŒ–ï¼ˆä¿ç•™ï¼‰
    let yufuApply = null;
    if (pm.startsWith("yufu_inst_") && shipping_info && typeof shipping_info === "object") {
      yufuApply = shipping_info.yufu_apply || shipping_info.yufuApply || null;

      if (yufuApply && !shipping_info.installment_apply_text) {
        const name = String(yufuApply.name || "").trim();
        const idno = String(yufuApply.idno || yufuApply.id || "").trim();
        const p2 = String(yufuApply.phone || "").trim();
        const e2 = String(yufuApply.email || "").trim();

        shipping_info.installment_apply_text =
          `è£•å¯Œåˆ†æœŸç”³è«‹è³‡æ–™\n` +
          `å§“åï¼š${name}\n` +
          `èº«åˆ†è­‰ï¼š${idno}\n` +
          `é›»è©±ï¼š${p2}\n` +
          `Emailï¼š${e2}`;
      }
    }

    // deposit_old åŒæ„å‹¾é¸ï¼ˆæ²’å‹¾å°±æ“‹ + å­˜è­‰ï¼‰
    const depAgree =
      !!(shipping_info?.deposit_agree ||
         shipping_info?.deposit?.agree ||
         shipping_info?.deposit?.agreement);

    if (pm === "deposit_old") {
      if (!depAgree) {
        return j(env, origin, {
          ok: false,
          error: "deposit_agree_required",
          message: "è«‹å…ˆå‹¾é¸åŒæ„ï¼šé€¾æœŸè¦–åŒæ£„æ¨™ï¼Œå®šé‡‘ä¸é€€é‚„ã€‚"
        }, 400);
      }
    }

    // ===== deposit ä¾†æºæ•´åˆï¼šå…¼å®¹ã€Œship.depositã€èˆ‡èˆŠç‰ˆã€Œshipping_info.depositã€=====
const depObj = (() => {
  if (!shipping_info || typeof shipping_info !== "object") return {};
  // ä½ å‰ç«¯æ˜¯æ”¾åœ¨ ship.deposit
  const d1 = shipping_info?.ship?.deposit;
  if (d1 && typeof d1 === "object") return d1;

  // å…¼å®¹å…¶ä»–å¯èƒ½å‘½å
  const d2 = shipping_info?.shipping?.deposit;
  if (d2 && typeof d2 === "object") return d2;

  // èˆŠç‰ˆï¼šç›´æ¥æ”¾åœ¨ shipping_info.deposit / shipping_info.dep
  const d3 = shipping_info?.deposit || shipping_info?.dep;
  if (d3 && typeof d3 === "object") return d3;

  return {};
})();

const depAmountRaw =
shipping_info?.deposit_amount ??
depObj?.amount ??
depObj?.deposit_amount ??
0;

const depAmount = Number(depAmountRaw || 0) || 0;

const depLast5 = String(
shipping_info?.deposit_last5 ??
depObj?.last5 ??
depObj?.bank_last5 ??
""
).trim();

const depExpireAt = String(
  shipping_info?.deposit_expire_at ??
  depObj?.expire_at ??
  depObj?.due_at ??
  depObj?.hold_until ??   // âœ… åŠ é€™è¡Œ
  ""
).trim();

const holdUntil = String(
shipping_info?.hold_until ??
depObj?.hold_until ??
""
).trim();

    // âœ… æŠŠè¨‚å–®é¡å‹ & æ¯è¨‚å–®ä¸€èµ·è¨˜éŒ„ï¼ˆä¿ç•™ï¼‰
    const fields = {
      order_id,
      cart_token: cartToken,
      status,
      pay_status,
      total_amount: baseTotal,
      net_amount: netAmount,
      payment_method: pm,
      shipping_info: JSON.stringify(shipping_info || {}),
      deposit_agree: !!shipping_info?.deposit_agree,
      deposit_agree_text: String(shipping_info?.deposit_agree_text || ""),
      deposit_agree_at: (shipping_info?.deposit_agree_at ? String(shipping_info.deposit_agree_at) : undefined),
      installment_apply_text: String(shipping_info?.installment_apply_text || ""),
      items_text,
      items_json,
      created_at: nowISO(),
      stock_deduct_done: stockDeducted,
      line_user_id: lineUserId,

      credit_used: used,
      credit_spend_done: false,
      credit_refund_done: false,

      order_type: is_tail ? "tail" : "normal",
      parent_order_id: (is_tail && tail_of_order) ? String(tail_of_order) : ""
    };

    // âœ… æœ‰å€¼æ‰å¯«ï¼ˆé¿å… undefined/ç©ºå­—ä¸²é€ æˆ Airtable ä¸åƒï¼‰
if (depAmount > 0) fields.deposit_amount = depAmount;
if (depLast5) fields.deposit_last5 = depLast5;
if (depExpireAt) fields.deposit_expire_at = depExpireAt;
if (holdUntil) fields.hold_until = holdUntil;

    if (pm === "deposit_old") {
      fields.deposit_agree = true;
      fields.deposit_agree_text = "æˆ‘å·²é–±è®€ä¸¦åŒæ„ï¼šé€¾æœŸè¦–åŒæ£„æ¨™ï¼Œå®šé‡‘ä¸é€€é‚„ã€‚";
      fields.deposit_agree_at = nowISO();
    }

    // å»ºå–®ï¼ˆè‹¥å¤±æ•—ä¸”ä¹‹å‰æ‰£åº«å­˜æˆåŠŸï¼Œè¦è£œå›ï¼‰
    let created = null;
    try {
      created = await at(env, "POST", T, "", { records: [{ fields }] });
    } catch (e) {
      // âœ… è£œå›åº«å­˜ï¼ˆåªæœ‰çœŸçš„æ‰£éæ‰è£œï¼‰
      if (stockDeducted && !is_tail) {
        try { await adjustStockByItems(env, normItems || [], +1); } catch {}
      }
      throw e;
    }

    const orderRec = created?.records?.[0];

    // âœ… ç«‹åˆ»ç¶å®š cart -> orderï¼ˆé–æ­»ï¼Œé˜²æ­¢é‡è¤‡é€ï¼‰
    await at(env, "PATCH", CT, "", {
      records: [{
        id: cartRec0.id,
        fields: {
          checked_out: true,
          checked_out_order_id: order_id,
          checked_out_at: nowISO(),
          status: "submitted",
          closed_at: nowISO()
        }
      }]
    });
    lockCommitted = true;

    // =========
    // 14) AT_CHECKOUT é¡ï¼šå»ºå–®å°±æ‰£è³¼ç‰©é‡‘ï¼ˆON_PAID é¡äº¤çµ¦ä»˜æ¬¾æˆåŠŸå¾Œæ‰£ï¼‰
    // =========
    try {
      if (used > 0 && lineUserId && orderRec?.id && policy === "AT_CHECKOUT") {
        const already = await creditLedgerExists(env, String(order_id || ""), "use");
        if (!already) {
          const TM = env.AT_LINE_MEMBERS || "LineMembers";
          const memberRec =
            (await atFindByField(env, TM, "LineUserId", lineUserId)) ||
            (await atFindByField(env, TM, "line_user_id", lineUserId));

            const ledgerFields = {
              LineUserId: String(lineUserId || ""),
              OrderId: String(order_id || ""),
              Type: "use",
              Amount: -Math.abs(Number(used) || 0),
              Reason: "paid_success",
              DisplayName: creditDisplayName("use", String(order_id || ""), "paid_success")
            };
          if (memberRec?.id) ledgerFields.Member = [memberRec.id];

          await creditLedgerAdd(env, ledgerFields);

          await at(env, "PATCH", (env.AT_ORDERS || "Orders"), "", {
            records: [{
              id: orderRec.id,
              fields: {
                credit_spend_done: true,
                credit_spend_at: nowISO(),
                credit_spend_reason: "paid_success"
              }
            }]
          });
        }
      }
    } catch (e) {
      console.log("checkout credit spend error", order_id, e?.message || e);
    }

    // =========
    // 15)ï¼ˆå¯é¸ï¼‰å»ºå–®æˆåŠŸé€šçŸ¥å¡ï¼ˆä½ åŸæœ¬æœ‰å°±æœƒç”¨å¾—åˆ°ï¼‰
    // =========
    try {
      if (lineUserId && typeof sendCheckoutCompleteFlex === "function") {
        await sendCheckoutCompleteFlex(env, {
          lineUserId,
          displayName,
          orderId: order_id,
          amount: "NT$ " + (netAmount || 0).toLocaleString("zh-TW"),
          paymentMethod: pm,
          shipping_info
        });
      }
    } catch (e) {
      console.log("sendCheckoutCompleteFlex error", order_id, e?.message || e);
    }

    // =========
// 16) å›å‚³æˆåŠŸ
// =========
// âœ… ä½ çš„å‰ç«¯æœƒè‡ªå·±æ‹¿ order_id å»å‘¼å« /payuni/start (POST)ï¼Œæ‰€ä»¥é€™è£¡ä¸éœ€è¦ next_url
let next_url = "";

return j(env, origin, {
  ok: true,
  order_id,
  next_url,
  net_amount: netAmount,
  credit_used: used,
  status,
  pay_status,
  payment_method: pm
}, 200);

  } finally {
    // âœ… ä¿éšªè§£é–ï¼šåªæœ‰ã€Œå·²ä¸Šé– checking_outã€ä½†ã€Œæ²’æœ‰æˆåŠŸç¶å®šè¨‚å–®ã€æ‰è§£é–
    if (lockAcquired && !lockCommitted) {
      try {
        await at(env, "PATCH", CT, "", {
          records: [{
            id: cartRec0.id,
            fields: {
              status: "",               // å›åˆ°å¯å†æ¬¡å˜—è©¦
              checkout_lock_id: "",
              checkout_lock_at: ""
            }
          }]
        });
      } catch (e) {
        console.log("checkout finally unlock failed", cartToken, e?.message || e);
      }
    }
  }
}
                      

      /* é€™è£¡é–‹å§‹è²¼æ–°çš„ Tail Info */
// --- Order Infoï¼šçµ¦ /meetup/confirm.html è‡ªå‹•å¸¶è³‡æ–™ç”¨ ---
if (req.method === "GET" && path === "/order/info") {
  const oid = url.searchParams.get("order_id") || url.searchParams.get("oid") || "";
  if (!oid) return j(env, origin, { ok:false, error:"missing_order_id" }, 400);

  const T = env.AT_ORDERS || "Orders";
  const rec = await atFindByField(env, T, "order_id", oid);
  if (!rec) return j(env, origin, { ok:false, error:"order_not_found" }, 404);

  const f = rec.fields || {};

  let shipInfo = {};
  try { shipInfo = JSON.parse(f.shipping_info || "{}"); } catch {}

  const ship = (shipInfo && shipInfo.ship) || {};
  const amount = Number(f.net_amount ?? f.total_amount ?? 0) || 0;

  const pm = String(f.payment_method || "");
  const payMethodLabel =
    pm === "meetup_cash" ? "é¢äº¤ç¾é‡‘" :
    (String(ship.type || "").toLowerCase() === "meetup" ? "é¢äº¤ï¼ˆç·šä¸Šä»˜æ¬¾ï¼‰" : "");

  // âš ï¸ åªå›å‚³ã€Œé é¢éœ€è¦çš„ã€æ¬„ä½ï¼Œé¿å…æŠŠ phone/email å…¨åå‡ºå»
  return j(env, origin, {
    ok: true,
    order_id: oid,
    customerName: String(ship.name || ""),
    amount,
    meetPlace: String(ship.meet_place || ""),
    payMethodLabel
  }, 200);
}

// --- Order Statusï¼šçµ¦å‰ç«¯ pending pay é˜²é‡é€ç”¨ ---
if (req.method === "GET" && path === "/order/status") {
  const oid =
    String(url.searchParams.get("order_id") || url.searchParams.get("oid") || "").trim();

  if (!oid) {
    return j(env, origin, { ok: false, error: "missing_order_id" }, 400);
  }

  const T = env.AT_ORDERS || "Orders";
  const rec = await atFindByField(env, T, "order_id", oid);
  if (!rec) {
    return j(env, origin, { ok: false, error: "order_not_found" }, 404);
  }

  const f = rec.fields || {};
  return j(env, origin, {
    ok: true,
    order_id: oid,
    pay_status: String(f.pay_status || ""),
    status: String(f.status || ""),
    yufu_status: String(f.yufu_status || "")
  }, 200);
}
// --- Tail Infoï¼šå–å¾—å°¾æ¬¾ç”¨çš„åŸè¨‚å–®è³‡è¨Š ---
if (req.method === "GET" && path === "/tail/info") {
  const parentId =
    url.searchParams.get("order_id") ||
    url.searchParams.get("parent_order_id") ||
    "";

  if (!parentId) {
    return j(env, origin, { ok: false, error: "missing_parent_order_id" }, 400);
  }

  const T = env.AT_ORDERS || "Orders";
  const rec = await atFindByField(env, T, "order_id", parentId);
  if (!rec) {
    return j(env, origin, { ok: false, error: "order_not_found" }, 404);
  }

  const f = rec.fields || {};
  const total = Number(f.total_amount || f.total || 0) || 0;
  const dep   = Number(f.deposit_amount || 0) || 0;
  const tailAmount = total > dep ? (total - dep) : 0;

  let shipping_info = {};
  try {
    shipping_info = JSON.parse(f.shipping_info || "{}");
  } catch (e) {
    shipping_info = {};
  }

  const items_text = f.items_text || "";

  // ğŸ”¹ æ–°å¢ï¼šæ±ºå®šè¦é¡¯ç¤ºçš„ä¿ç•™åˆ°æœŸæ—¥
  const hold =
    (shipping_info && shipping_info.hold_until) ||
    (f.hold_until || "");

  return j(env, origin, {
    ok: true,
    parent_order_id: parentId,
    total_amount: total,
    deposit_amount: dep,
    tail_amount: tailAmount,
    items_text,
    shipping_info,
    hold_until: hold   // å¢é€™ä¸€è¡Œ
  });
}

// âœ… æª¢æŸ¥åŒä¸€ç­†æ‰£æ¬¾åŸå› æ˜¯å¦å·²å¯«å…¥ï¼ˆé¿å…é‡è¤‡æ‰£ï¼‰
async function creditLedgerReasonExists(env, lineUserId, reason) {
  const CL = env.AT_CREDITS_LEDGER || "CreditsLedger";

  // â—ä½ çš„ CreditsLedger æ²’æœ‰ Status æ¬„ä½ â†’ åƒè¬ä¸è¦å¼•ç”¨ {Status}
  const filter = `AND(
    {LineUserId}='${esc(String(lineUserId))}',
    {Reason}='${esc(String(reason))}'
  )`;

  const res = await at(env, "GET", CL, "", null, {
    filterByFormula: filter,
    maxRecords: "1"
  });

  return !!res?.records?.[0]?.id;
}

async function captureCreditHoldIfNeeded(env, orderId) {
  const T = env.AT_ORDERS || "Orders";
  const CL = env.AT_CREDITS_LEDGER || "CreditsLedger";

  const orec = await atFindByField(env, T, "order_id", orderId);
  if (!orec) return;

  const f = orec.fields || {};
  if (f.credit_capture_done) return;

  const used = Number(f.credit_used || 0) || 0;
  if (!(used > 0)) {
    // æ²’ç”¨è³¼ç‰©é‡‘ä¹Ÿç®—å®Œæˆ
    await at(env, "PATCH", T, "", { records:[{ id: orec.id, fields:{ credit_capture_done:true } }] });
    return;
  }

  const uid = String(f.line_user_id || "").trim();
  if (!uid) return;

  const reason = `hold:${orderId}`;

  // æ‰¾åˆ°é‚£ç­† hold
  const filter = `AND({LineUserId}='${esc(uid)}',{Reason}='${esc(reason)}',{Status}='hold')`;
  const res = await at(env, "GET", CL, "", null, { filterByFormula: filter, maxRecords: "1" });
  const holdRec = res?.records?.[0];
  if (!holdRec?.id) return;

  // æŠŠ hold è½‰æˆ useï¼ˆæ›´æ–°åŒä¸€ç­†ï¼Œé¿å…å¤šç®—ï¼‰
  await at(env, "PATCH", CL, "", {
    records: [{
      id: holdRec.id,
      fields: { Type:"use", Status:"used", Amount: -Math.abs(Number(holdRec?.fields?.Amount || used) || 0), Reason:`used:${orderId}`, DisplayName: (typeof creditDisplayName==="function" ? creditDisplayName("use", orderId, "paid_success") : `è³¼ç‰©é‡‘æŠ˜æŠµï¼ˆ${orderId}ï¼‰`) }}]
  });

  await at(env, "PATCH", T, "", {
    records:[{ id: orec.id, fields:{ credit_capture_done:true, credit_spend_done:true } }]
  });
}

// âœ… è£œï¼šé‡‹æ”¾ã€Œè³¼ç‰©é‡‘ holdã€ï¼ˆçµ¦ abandoned cleanup / é‡‘æµå¤±æ•—æ™‚ç”¨ï¼‰
// ä¾ Orders æ¬„ä½åˆ¤æ–·ï¼šcredit_used / credit_hold_done / credit_spend_done / credit_hold_release_done



async function tailCreditUseExists(env, uid, parent_order_id) {
  const CL = env.AT_CREDITS_LEDGER || "CreditsLedger";
  const reason = `tail:${parent_order_id}`;

  // åªè¦åŒæœƒå“¡ + åŒ reason + type=use æœ‰ä»»ä¸€ç­†ï¼Œå°±è¦–ç‚ºå·²æ‰£é
  const filter = `AND(
    {LineUserId}='${esc(uid)}',
    {Type}='use',
    {Reason}='${esc(reason)}'
  )`;

  const resp = await at(env, "GET", CL, "", null, { filterByFormula: filter, maxRecords: "1" });
  return !!resp?.records?.[0]?.id;
}
// --- Tail Checkoutï¼šå°¾æ¬¾çµå¸³ï¼ˆä¸æ‰£åº«å­˜ï¼‰ ---
if (req.method === "POST" && path === "/tail/checkout") {
  const {
    parent_order_id,
    items_json,
    tail_amount,
    payment_method,
    shipping_info,
    atm_last5,     // âœ… å‰ç«¯æœ‰å‚³å°±æ”¶ï¼ˆå­˜åˆ° shipping_info JSONï¼‰
    credit_used,   // âœ… æœ¬æ¬¡æŠ˜æŠµ
    line_user_id   // âœ… æœƒå“¡ idï¼ˆå¯ä¸å‚³ï¼Œæœƒå¾ shipping_info è£œï¼‰
  } = await body();

  if (!parent_order_id) {
    return j(env, origin, { ok:false, error:"missing_parent_order_id" }, 400);
  }

  const T   = env.AT_ORDERS || "Orders";
  const now = nowISO();

  const pm = String(payment_method || "").trim();
  const tailAmount = Math.round(Number(tail_amount || 0) || 0);
  const creditUsed = Math.max(0, Math.round(Number(credit_used || 0) || 0));

  // è§£æ shipping_info
  let shipInfo = shipping_info || {};
  try { if (typeof shipInfo === "string") shipInfo = JSON.parse(shipInfo || "{}"); } catch { shipInfo = {}; }

  // æŠŠ atm_last5 æ”¾é€² shipping_infoï¼ˆä¸æ–°å¢ Airtable æ¬„ä½ï¼Œé¿å…ç ´å£ï¼‰
  const last5 = String(atm_last5 || "").trim();
// âœ… å…è¨±ï¼š5 ç¢¼æ•¸å­— OR æ–‡å­—ã€Œè³¼ç‰©é‡‘ã€
if (last5 && (/^\d{5}$/.test(last5) || last5 === "è³¼ç‰©é‡‘")) {
  shipInfo.atm_last5 = last5;
}

  // å–å¾— line_user_idï¼ˆå„ªå…ˆç”¨ bodyï¼Œå…¶æ¬¡å¾ shipping_info è£œï¼‰
  let uid = String(line_user_id || "").trim();
  if (!uid) {
    try {
      const line = shipInfo.line || shipInfo.line_profile || {};
      uid = String(line.user_id || line.userId || line.LINE_USER_ID || shipInfo.line_user_id || "").trim();
    } catch {}
  }

  // ç·šä¸Šæ”¯ä»˜ / é›¶å¡ï¼šè‡³å°‘è¦ä»˜ 1 å…ƒï¼ˆé¿å… 0 å…ƒé‡‘æµï¼‰
  const isOnline =
  pm.startsWith("paid_") ||
  pm.startsWith("zero_card_") ||
  pm.startsWith("yufu_inst_");
  if (isOnline && tailAmount > 0 && creditUsed >= tailAmount) {
    return j(env, origin, { ok:false, error:"credit_used_too_much_need_pay_at_least_1" }, 400);
  }

  // âœ… æœ€å®‰å…¨é˜²é‡ï¼šåŒä¸€å¼µåŸå–®ï¼ˆparent_order_idï¼‰åªå…è¨±å­˜åœ¨ 1 å¼µå°¾æ¬¾ TL
// - åªè¦æ‰¾åˆ° tail å–®ï¼ˆpending / paid_okï¼‰å°±ã€Œä¸€å¾‹é‡ç”¨ã€
// - è‹¥å·² paid_okï¼šç›´æ¥æ“‹ä¸‹ï¼Œä¸å…è¨±å†é–‹æ–°çš„ TLï¼ˆé¿å…é›™é‡ä»˜æ¬¾ï¼‰
// - è‹¥ pendingï¼šå›å‚³æ—¢æœ‰ TL çš„ payment_method / credit_used / net_amountï¼Œå‰ç«¯å¿…é ˆç…§é€™å¼µ TL èµ°
try {
  const pid = String(parent_order_id || "").trim();

  const filter = `AND(
    {is_tail}=1,
    {parent_order_id}='${esc(pid)}',
    OR({pay_status}='pending',{pay_status}='submitted',{pay_status}='paid_ok')
  )`;

  const res = await at(env, "GET", T, "", null, {
    filterByFormula: filter,
    maxRecords: "1"
  });

  const r0 = res?.records?.[0];
  const rf = r0?.fields || {};
  const existId = String(rf.order_id || "").trim();

  if (existId) {
    const existPayStatus = String(rf.pay_status || "").toLowerCase();
    const existPm = String(rf.payment_method || "").trim();
    const existCu = Number(rf.credit_used || 0) || 0;
    const existNet = Number(rf.net_amount || 0) || 0;

    // âœ… å·²ä»˜æ¸…ï¼šç¦æ­¢å†é–‹å°¾æ¬¾ï¼ˆé¿å…åŒåŸå–®è¢«ä»˜å…©æ¬¡ï¼‰
    if (existPayStatus === "paid_ok") {
      return j(env, origin, {
        ok: false,
        error: "tail_already_paid",
        message: "æ­¤ç­†è¨‚å–®å°¾æ¬¾å·²çµæ¸…ï¼Œè«‹å‹¿é‡è¤‡çµå¸³ã€‚",
        order_id: existId
      }, 409);
    }

    // âœ… pendingï¼šä¸€å¾‹é‡ç”¨ï¼Œä¸¦é–å®šä»˜æ¬¾æ–¹å¼/æŠ˜æŠµ
    return j(env, origin, {
      ok: true,
      order_id: existId,
      reused: true,
      locked: true,
      payment_method: existPm,
      credit_used: existCu,
      net_amount: existNet,
      message: "æ­¤ç­†è¨‚å–®å·²æœ‰å°¾æ¬¾å¾…ä»˜æ¬¾ï¼Œå·²ç‚ºæ‚¨æ¥çºŒåŸå°¾æ¬¾å–®ã€‚"
    }, 200);
  }
} catch (e) {
  console.log("tail/checkout reuse/lock check error", e?.message || e);
}

  // âœ… æœ‰æŠ˜æŠµå°±é©—è­‰æœƒå“¡ & é¤˜é¡
  if (creditUsed > 0) {
    if (!uid) return j(env, origin, { ok:false, error:"line_user_id_required_for_credit" }, 400);

    const bound = await isBoundMember(env, uid);
    if (!bound) return j(env, origin, { ok:false, error:"member_not_bound" }, 400);

    const info = await getMemberCreditInfo(env, uid);
const available = info ? info.avail : 0;
if (creditUsed > available) {
  return j(env, origin, { ok:false, error:"insufficient_credit", available }, 400);
}
    // âœ… æ­¢è¡€ï¼šåŒä¸€å¼µåŸå–®å°¾æ¬¾ï¼ˆtail:OD...ï¼‰è³¼ç‰©é‡‘åªèƒ½æ‰£ä¸€æ¬¡
  const already = await tailCreditUseExists(env, uid, parent_order_id);
  if (already) {
    return j(env, origin, { ok:false, error:"tail_credit_already_used" }, 409);
  }
  }

  const order_id  = "TL" + Date.now();
const netAmount = Math.max(0, tailAmount - creditUsed);

// âœ… ç´”è³¼ç‰©é‡‘ï¼šå°¾æ¬¾è¢«æŠ˜åˆ° 0ï¼Œç›´æ¥è¦–ç‚ºå·²ä»˜æ¬¾ï¼ˆä¸èµ° COD/ATM/é‡‘æµï¼‰
const isCreditOnly = (tailAmount > 0 && creditUsed > 0 && netAmount === 0);
const pmEff = isCreditOnly ? "credit_only_tail" : pm;

// âœ… ä½ é¸ Bï¼šCOD ç›´æ¥è¦–ç‚ºå·²æ”¶æ¬¾
const isCod = String(pmEff || "").toLowerCase().startsWith("cod_");
const isCodPaidNow = isCod;

const payStatusEff = (isCreditOnly || isCodPaidNow) ? "paid_ok" : "pending";
const statusEff    = (isCreditOnly || isCodPaidNow) ? "confirmed" : "submitted";

// âœ… è£•å¯Œï¼šæŠ“æœŸæ•¸ + ç”³è«‹äººè³‡æ–™ï¼ˆå‰ç«¯é€ installment_applyï¼‰
let yufuPeriod = null;
let yufuApplicant = null;

if (pm.startsWith("yufu_inst_")) {
  const m = pm.match(/^yufu_inst_(\d+)/);
  if (m) yufuPeriod = Number(m[1]);

  // âœ… é€™è£¡å»ºè­°ç”¨ä½ å‰é¢å·² parse éçš„ shipInfoï¼ˆé¿å… shipping_info æ˜¯å­—ä¸²æ™‚å–ä¸åˆ°ï¼‰
  const inst = shipInfo?.installment_apply || shipInfo?.installmentApply;
  if (inst && inst.provider === "yufu") {
    yufuApplicant = inst.applicant || null;
  }
}

// å…ˆå»ºå–®
const fields = {
  order_id,
  order_type: "tail",
  line_user_id: uid,
  parent_order_id,

  status: statusEff,
  pay_status: payStatusEff,
  payment_method: pmEff,

  total_amount: tailAmount,

  // âœ… é—œéµæ¬„ä½ï¼šè«‹æ¬¾/ç™¼ç¥¨é‡‘é¡ = å°¾æ¬¾-æŠ˜æŠµ
  credit_used: creditUsed,
  net_amount: netAmount,

  items_text: items_json || "",
  shipping_info: JSON.stringify(shipInfo || {}),
  created_at: now,
  is_tail: true
};

  if (pm.startsWith("yufu_inst_")) {
    if (yufuPeriod) fields.yufu_period = yufuPeriod;
  
    if (yufuApplicant) {
      if (yufuApplicant.name)  fields.yufu_name  = String(yufuApplicant.name);
      if (yufuApplicant.idno)  fields.yufu_idno  = String(yufuApplicant.idno);
      if (yufuApplicant.phone) fields.yufu_phone = String(yufuApplicant.phone);
      if (yufuApplicant.email) fields.yufu_email = String(yufuApplicant.email);
    }
  }

  const created = await at(env, "POST", T, "", { records: [{ fields }] });
  const recId = created?.records?.[0]?.id;

  // âœ… å»ºå–®å¾Œï¼šæœ‰æŠ˜æŠµå°±å…ˆã€Œä¿ç•™è³¼ç‰©é‡‘ã€ï¼ˆä¸è¦å¯¦æ‰£ï¼‰
// - ç·šä¸Šæ”¯ä»˜é€”ä¸­é—œæ‰ä¹Ÿä¸æœƒæ‰£ StoreCredit
// - ç­‰ PayUNI æˆåŠŸæ™‚å†è½‰æˆå¯¦æ‰£
if (creditUsed > 0 && uid) {
  try {
    if (isCreditOnly || isCodPaidNow) {
      // âœ… ç´”è³¼ç‰©é‡‘ or CODè¦–ç‚ºå·²æ”¶æ¬¾ï¼šç›´æ¥æ‰£
      await spendCredit(env, {
        lineUserId: uid,
        orderId: String(order_id || "").trim(),
        amount: creditUsed,
        reason: isCreditOnly
          ? `credit_only_tail:${parent_order_id}`
          : `cod_paid_now_tail:${parent_order_id}`
      });

      if (recId) {
        await at(env, "PATCH", T, "", {
          records: [{ id: recId, fields: { credit_spend_done: true, credit_spend_at: nowISO() } }]
        });
      }
    } else {
      // å…¶ä»–æƒ…å¢ƒæ‰å…ˆä¿ç•™ï¼ˆä¾‹å¦‚ç·šä¸Šä»˜æ¬¾ pendingï¼‰
      await holdCreditForOrder(env, {
        lineUserId: uid,
        orderRecId: recId,
        orderId: order_id,
        amount: creditUsed,
        reason: `tail:${parent_order_id}`
      });
    }
  } catch (e) {
    console.log("tail/checkout credit hold/spend error", order_id, e?.message || e);
    return j(env, origin, { ok:false, error:"credit_hold_failed_try_again", order_id }, 500);
  }
}
  // âœ… å°¾æ¬¾çµå¸³å®Œæˆ â†’ åªåœ¨ã€Œä¸éœ€è¦ç­‰é‡‘æµå›èª¿ã€çš„æƒ…æ³æ‰ç™¼
// ç·šä¸Šä»˜æ¬¾ï¼ˆpaid_* / aftee_directï¼‰å¿…é ˆç­‰ PayUNI notify/return æˆåŠŸæ‰ç®—å®Œæˆ
try {
  const pm = String(pmEff || "").toLowerCase();
  const isOnlinePay = (pm.startsWith("paid_") || pm === "aftee_direct");

  if (uid && !isOnlinePay) {
    await sendTailCheckoutCompleteFlex(env, {
      lineUserId: uid,
      orderId: order_id,
      parentOrderId: parent_order_id,
      tailAmount: tailAmount,
      creditUsed: creditUsed,
      netAmount: netAmount,
      paymentMethod: pmEff
    });
  } else {
    // ç·šä¸Šä»˜æ¬¾ï¼šä¸ç™¼ã€Œå®Œæˆã€å¡ï¼ˆé¿å…æœªä»˜æ¬¾å°±é¡¯ç¤ºå®Œæˆï¼‰
    // ä½ è‹¥æƒ³æ”¹æˆç™¼ã€Œå·²å»ºç«‹ï¼Œè«‹å®Œæˆä»˜æ¬¾ã€çš„å¡ç‰‡ï¼Œæˆ‘å†çµ¦ä½ ä¸€å€‹æ–°å‡½å¼ä¸å½±éŸ¿èˆŠæ¨£å¼
    console.log("skip tail complete flex (online pay):", order_id, pmEff);
  }
} catch (e) {
  console.log("sendTailCheckoutCompleteFlex error", order_id, e?.message || e);
}

  return j(env, origin, { ok:true, order_id }, 200);
}

// --- Tailï¼šå–æ¶ˆã€Œæœªå®Œæˆå°¾æ¬¾ TLã€ä¸¦é‡‹æ”¾è³¼ç‰©é‡‘ holdï¼ˆä¸å½±éŸ¿ä¸€èˆ¬è³¼ç‰©è»Šï¼‰ ---
// POST /tail/cancel-pending
// body: { parent_order_id, line_user_id, reason? }
if (req.method === "POST" && path === "/tail/cancel-pending") {
  const b = await body();
  const parent_order_id = String(b?.parent_order_id || "").trim();
  const line_user_id    = String(b?.line_user_id || "").trim();
  const reason          = String(b?.reason || "user_cancel_rebuild").trim();

  if (!parent_order_id) return j(env, origin, { ok:false, error:"missing_parent_order_id" }, 400);
  if (!line_user_id)    return j(env, origin, { ok:false, error:"missing_line_user_id" }, 400);

  const T = env.AT_ORDERS || "Orders";

  // æ‰¾å‡ºæ­¤ parent çš„ã€Œæœªå®Œæˆ TLã€
  const filter = `AND(
    {is_tail}=1,
    {parent_order_id}='${esc(parent_order_id)}',
    OR({pay_status}='pending',{pay_status}='submitted',{pay_status}='paid_ok')
  )`;

  const res = await at(env, "GET", T, "", null, {
    filterByFormula: filter,
    maxRecords: "1",
    "sort[0][field]": "created_at",
    "sort[0][direction]": "desc"
  });

  const rec = res?.records?.[0];
  if (!rec?.id) {
    // æ²’æœ‰æœªå®Œæˆ TL â†’ è¦–ç‚ºå·²ç¶“å¯ä»¥é‡å»º
    return j(env, origin, { ok:true, cancelled:false, message:"no_active_tail" }, 200);
  }

  const f = rec.fields || {};
  const oid = String(f.order_id || "").trim();
  const ps  = String(f.pay_status || "").toLowerCase();

  // å·²ä»˜æ¸…å°±ä¸å…è¨±å–æ¶ˆé‡å»º
  if (ps === "paid_ok") {
    return j(env, origin, {
      ok:false,
      error:"tail_already_paid",
      order_id: oid,
      message:"æ­¤ç­†å°¾æ¬¾å·²ä»˜æ¸…ï¼Œç„¡æ³•å–æ¶ˆé‡å»ºã€‚"
    }, 409);
  }

  // é©—è­‰æ­¸å±¬ï¼šåªèƒ½å–æ¶ˆè‡ªå·±çš„ TL
  const owner = String(f.line_user_id || "").trim();
  if (!owner || owner !== line_user_id) {
    return j(env, origin, { ok:false, error:"forbidden" }, 403);
  }

  // é‡‹æ”¾ holdï¼ˆåªé‡å° TLï¼›ä¸è£œåº«å­˜ã€ä¸åš refund ledgerï¼‰
  const cu = Math.round(Number(f.credit_used || 0) || 0);

  try {
    // 1) å…ˆæŠŠ TL æ¨™è¨˜æˆå–æ¶ˆï¼ˆè®“ /tail/checkout ä¸‹æ¬¡ä¸æœƒé‡ç”¨å®ƒï¼‰
    await at(env, "PATCH", T, "", {
      records: [{
        id: rec.id,
        fields: {
          status: "cancelled",
          pay_status: "failed",
          pay_notify_status: `CANCEL_REBUILD:${reason}`,
          // å¯é¸ï¼šç•™å€‹å‚™è¨»æ–¹ä¾¿ä½ æŸ¥
          internal_note: ((String(f.internal_note || "") + " ").trim() + `[TAIL_CANCEL_REBUILD] ${nowISO()}`).trim()
        }
      }]
    });

    // 2) å†é‡‹æ”¾ holdï¼ˆreleaseCreditHold å…§å»ºåŒå–®å»é‡ credit_hold_release_doneï¼‰
    if (cu > 0 && !f.credit_spend_done) {
      await releaseCreditHold(env, {
        lineUserId: line_user_id,
        orderRecId: rec.id,
        amount: cu,
        reason: `tail_cancel_rebuild:${oid}`
      });
    }

    return j(env, origin, {
      ok:true,
      cancelled:true,
      order_id: oid,
      released_credit: cu
    }, 200);

  } catch (e) {
    console.log("tail/cancel-pending error", oid, e?.message || e);
    return j(env, origin, { ok:false, error:"cancel_tail_failed" }, 500);
  }
}

// --- æŸ¥è©¢ LINE æœƒå“¡è³¼ç‰©é‡‘é¤˜é¡ ---
if (req.method === "POST" && path === "/line/credits/balance") {
  const { line_user_id } = await body();

  if (!line_user_id) {
    return j(env, origin, { ok: false, error: "missing_line_user_id" }, 400);
  }

  const LM = env.AT_LINE_MEMBERS    || "LineMembers";
  const CL = env.AT_CREDITS_LEDGER  || env.AT_CREDITS || "CreditsLedger";

  // â‘  æ‰¾æœƒå“¡
  const memberRec =
    (await atFindByField(env, LM, "LineUserId", line_user_id)) ||
    (await atFindByField(env, LM, "line_user_id", line_user_id));

  if (!memberRec) {
    return j(env, origin, { ok: false, error: "member_not_found" }, 404);
  }

  const mf = memberRec.fields || {};
  const memberId =
    memberRec.id ||
    mf.MemberId ||
    mf.member_id ||
    null;

  // â‘¡ ç®—è³¼ç‰©é‡‘é¤˜é¡ï¼ˆCreditsLedger å…¨éƒ¨åŠ ç¸½ï¼‰
  let balance = 0;

  try {
    const resp = await at(env, "GET", CL, "", null);
    const records = (resp && resp.records) || [];

    for (const rec of records) {
      const f = rec.fields || {};

      // ç”¨ memberId æˆ– line_user_id å°æ‡‰ï¼Œå…©ç¨®éƒ½è©¦
      const matchByMember =
  memberId && Array.isArray(f.Member) && f.Member.includes(memberId);
      const matchByLineId =
        f.LineUserId === line_user_id || f.line_user_id === line_user_id;

      if (!matchByMember && !matchByLineId) continue;

      const status = (f.Status || f.status || "").toString().toLowerCase();
      if (status.includes("void") || status.includes("cancel")) continue;

      const amt = Number(f.Amount || f.amount || 0) || 0;
      balance += amt;
    }
  } catch (e) {
    console.log("credits balance error:", e);
    return j(env, origin, { ok: false, error: "airtable_error" }, 500);
  }

  return j(env, origin, { ok: true, balance }, 200);
}

/* ç„¶å¾Œæ¥ä½ ã€ŒåŸæœ¬å°±æœ‰çš„ã€ Tail Checkoutï¼Œä¸è¦å‹•è£¡é¢çš„å…§å®¹ */
// --- OPï¼šå¾å®˜æ–¹ LINE ç™¼çµå¸³å¡ç‰‡ ---
if (req.method === "POST" && path === "/op/cart/send-link") {
  const { op_key, cart_token, line_user_id, customer_name = "" } = await body();

  // â‘  é©—è­‰ OP KEYï¼ˆè·Ÿ /op/auth ç”¨åŒä¸€çµ„ï¼‰
  const ADMIN = env.ADMIN_KEY || env.OP_KEY || "";
  if (!op_key || op_key !== ADMIN) {
    return j(env, origin, { ok: false, error: "bad_op_key" }, 403);
  }

  if (!cart_token || !line_user_id) {
    return j(env, origin, { ok: false, error: "missing_params" }, 400);
  }

  const C  = env.AT_CARTS        || "CartToken";
  const CI = env.AT_CART_ITEMS   || "CartItems";
  const LM = env.AT_LINE_MEMBERS || "LineMembers";

  // â‘¡ æ‰¾è³¼ç‰©è»Šä¸»æª”
  const cartRec = await atFindByField(env, C, "CartToken", cart_token);
  if (!cartRec) {
    return j(env, origin, { ok: false, error: "cart_not_found" }, 404);
  }
  const cf = cartRec.fields || {};

  // âœ… â‘¡-0 ç™¼å¡ç‰‡å‰ï¼šæŠŠ line_user_id / customer_name å¯«å› CartTokenï¼ˆåªè£œç©ºå€¼ï¼Œä¸è¦†è“‹ï¼‰
try {
  const patch = { updated_at: nowISO() };

  if (line_user_id && !String(cf.line_user_id || "").trim()) {
    patch.line_user_id = line_user_id;
  }
  if (customer_name && !String(cf.customer_name || "").trim()) {
    patch.customer_name = customer_name;
  }

  // åªè¦ patch æœ‰æ±è¥¿å°±å¯«å›
  if (Object.keys(patch).length) {
    await at(env, "PATCH", C, "", {
      records: [{ id: cartRec.id, fields: patch }]
    });
  }
} catch (e) {
  console.log("send-link patch cart meta error", e);
}

  // â‘¡-1 å¾ CartItems æŠŠåŒä¸€å€‹ CartToken çš„æ‰€æœ‰å•†å“åŠ ç¸½
  let sum = 0;
  try {
    // å…ˆæŠŠé€™å€‹è¡¨ç›®å‰çš„ records æ’ˆå›ä¾†
    const itemsResp = await at(env, "GET", CI, "", null);
    const records = (itemsResp && itemsResp.records) || [];

    for (const rec of records) {
      const f = rec.fields || {};
      // åªåŠ ç¸½åŒä¸€å¼µ CartToken
      if (f.CartToken !== cart_token) continue;

      const price = Number(f.Price || f.price || 0) || 0;
      const qty   = Number(f.Qty   || f.qty   || 0) || 0;
      sum += price * qty;
    }
  } catch (e) {
    console.log("send-link sum error (list)", e);
  }

  // â‘¡-2 å¦‚æœä¸Šé¢ç®—å‡ºä¾†é‚„æ˜¯ 0ï¼Œå°±é€€å›æŠ“ç¬¬ä¸€ç­†ç•¶ä¿åº•ï¼ˆé¿å…é¡¯ç¤º -ï¼‰
  if (!sum) {
    try {
      const itemRec = await atFindByField(env, CI, "CartToken", cart_token);
      if (itemRec) {
        const f = itemRec.fields || {};
        const price = Number(f.Price || f.price || 0) || 0;
        const qty   = Number(f.Qty   || f.qty   || 0) || 0;
        sum = price * qty;
      }
    } catch (e) {
      console.log("send-link sum error (fallback)", e);
    }
  }

  // â‘¢ æ‰¾æœƒå“¡ï¼ˆLineMembersï¼‰
  const memberRec =
    (await atFindByField(env, LM, "LineUserId", line_user_id)) ||
    (await atFindByField(env, LM, "line_user_id", line_user_id));
  if (!memberRec) {
    return j(env, origin, { ok: false, error: "member_not_found" }, 404);
  }
  const mf = memberRec.fields || {};
  const displayName = mf.DisplayName || mf.Name || "";

  // â‘£ çµ„çµå¸³é€£çµï¼ˆâœ… æ­£ç¢º LIFF æ ¼å¼ï¼šliff.line.me/{LIFF_ID}?url=ENCODED(ä½ çš„çµå¸³é ç¶²å€)ï¼‰
  const LIFF_ID = "2008430261-KLwoQjm4";
  const front = (env.FRONT_ORIGIN || "https://murain.tw").replace(/\/$/, "");
  
  // âœ… ä½ çš„ LINE Developers Endpoint URL æ˜¯ .htmlï¼Œæ‰€ä»¥é€™è£¡ä¹Ÿç”¨ .html
  const endpoint = `${front}/liff-checkout?cart_token=${encodeURIComponent(cart_token)}&force=1`;
  
  // âœ… æ­£ç¢ºï¼šliff.line.me/{LIFF_ID}?url=ENCODED(endpoint)
  const checkoutUrl = `https://liff.line.me/${LIFF_ID}?url=${encodeURIComponent(endpoint)}`;

  // â‘¤ ç™¼é€ Flex å¡ç‰‡ â€”â€” åªå‚³ amount é€™ä¸€å€‹æ•¸å­—
  try {
    await sendCartLinkFlex(env, line_user_id, {
      url: checkoutUrl,
      displayName,
      amount: sum,                       // ğŸ‘ˆ é€™è£¡å°±æ˜¯å‰›å‰›ç®—å‡ºä¾†çš„ã€Œå¤šå•†å“ç¸½é¡ã€
      orderId: cf.CartToken || cart_token
    });
  } catch (e) {
    const msg = String((e && e.message) || "");
    if (msg.includes("404")) {
      return j(env, origin, { ok: false, error: "not_found" }, 404);
    }
    return j(env, origin, { ok: false, error: "line_push_failed" }, 500);
  }

  return j(env, origin, { ok: true }, 200);
}
// å»ºç«‹ã€Œå°ˆå±¬çµå¸³é€£çµã€ Flex å¡ç‰‡ï¼ˆâœ… æœ‰é‡‘é¡ç‰ˆï¼‰
function buildCartLinkFlexBubble(params) {
  const displayName = params?.displayName || params?.name || "";
  const orderId = params?.orderId || params?.order_id || "";

  // âœ… çµ±ä¸€è™•ç†é‡‘é¡ï¼š
  // å…ˆç”¨ net_amountï¼Œå…¶æ¬¡ total_amountï¼Œå†ä¾† sum / amountï¼Œæœ€å¾Œæ‰ 0
  const rawAmount =
    params?.net_amount ??
    params?.total_amount ??
    params?.sum ??
    params?.amount ??
    0;

  let amount = 0;
  if (typeof rawAmount === "number") {
    amount = rawAmount;
  } else if (typeof rawAmount === "string") {
    // æŠŠ NT$ã€é€—è™Ÿã€ç©ºç™½ ç­‰éæ•¸å­—å…¨éƒ¨æ‹¿æ‰å†è½‰æ•¸å­—
    const cleaned = rawAmount.replace(/[^\d.-]/g, "");
    amount = Number(cleaned) || 0;
  }

  // çµå¸³é€£çµ
  const link = params?.url || params?.link || "";

  const amountText =
    typeof params?.amountText === "string"
      ? params.amountText
      : (amount > 0 ? amount.toLocaleString() : "-");

 // é…è‰²å®šç¾©ï¼šéœ§é¢è«è˜­è¿ªè‰²ç³» (Matte Morandi Palette)
 const colors = {
  bg: "#2C2C2E",        // éœ§é¢æ·±ç‚­ç° (æ¯”ç´”é»‘æ›´æŸ”å’Œ)
  gold: "#C8B696",      // ä½é£½å’Œéœ§é¢é‡‘ (Muted Champagne)
  textMain: "#E5E5E5",  // æŸ”éœ§ç™½
  textSub: "#9E9E9E",   // ä¸­æ€§ç°
  buttonText: "#2C2C2E" // æŒ‰éˆ•å­—è‰² (åŒèƒŒæ™¯è‰²)
};

return {
  type: "bubble",
  size: "mega",
  body: {
    type: "box",
    layout: "vertical",
    backgroundColor: colors.bg,
    paddingAll: "0px", 
    contents: [
      // é ‚éƒ¨è£é£¾æ¢ (éœ§é¢é‡‘)
      {
        type: "box",
        layout: "horizontal",
        height: "4px",
        backgroundColor: colors.gold,
        contents: [] // âœ… å¿…é ˆè¦æœ‰ contents
      },
      // ä¸»è¦å…§å®¹å®¹å™¨
      {
        type: "box",
        layout: "vertical",
        paddingAll: "20px",
        spacing: "lg",
        contents: [
          // 1. å“ç‰Œè­˜åˆ¥å€ (å·²ç§»é™¤åœ–ç‰‡ï¼Œåƒ…ä¿ç•™æ–‡å­—)
          {
            type: "box",
            layout: "vertical",
            alignItems: "center",
            spacing: "sm",
            contents: [
              {
                type: "text",
                text: "XUYUAN COLLECTION",
                size: "xxs",
                color: colors.gold,
                weight: "bold",
                style: "normal"
              }
            ]
          },

          // 2. æ¨™é¡Œå€
          {
            type: "box",
            layout: "vertical",
            alignItems: "center",
            spacing: "sm",
            contents: [
              {
                type: "text",
                text: "ç›´æ’­é¸å“å¾…çµå¸³",
                size: "lg",
                color: colors.textMain,
                weight: "bold"
              },
              {
                type: "text",
                text: "Reservation Confirmed",
                size: "xxs",
                color: colors.textSub,
                style: "italic"
              }
            ]
          },

          // 3. è£é£¾åˆ†éš”ç·š
          {
            type: "box",
            layout: "vertical",
            alignItems: "center",
            contents: [
              {
                type: "box",
                layout: "horizontal",
                width: "24px", // æ›´çŸ­ä¸€é»ï¼Œæ›´ç²¾ç·»
                height: "1px",
                backgroundColor: colors.gold,
                contents: [] // âœ… å¿…é ˆè¦æœ‰ contents
              }
            ]
          },

          // 4. å®¢è£½åŒ–è¨Šæ¯
          {
            type: "box",
            layout: "vertical",
            alignItems: "center",
            contents: [
              {
                type: "text",
                text: displayName ? `Dear ${displayName}` : "Dear Guest,",
                size: "sm",
                color: colors.textMain,
                weight: "regular"
              },
              {
                type: "text",
                text: "æ‚¨çš„å°ˆå±¬å•†å“å·²æ•´ç†å®Œç•¢\né‚€è«‹æ‚¨å‰å¾€ç¢ºèªä¸¦å®Œæˆè¨‚å–®",
                size: "xs",
                color: colors.textSub,
                align: "center",
                margin: "md",
                lineSpacing: "4px",
                wrap: true
              }
            ]
          }
        ]
      }
    ]
  },
  footer: {
    type: "box",
    layout: "vertical",
    backgroundColor: colors.bg,
    paddingAll: "20px",
    paddingTop: "0px",
    contents: [
      // çµå¸³æŒ‰éˆ•
      {
        type: "button",
        style: "primary",
        color: colors.gold,
        height: "sm",
        action: {
          type: "uri",
          label: "å‰å¾€çµå¸³ / CHECKOUT",
          uri: link
        }
      },
      // åº•éƒ¨å®‰å…¨æç¤º (æ–°å¢ SSL)
      {
        type: "box",
        layout: "vertical", // æ”¹ç”¨ vertical è®“å…©è¡Œå­—å †ç–Šæˆ–ä½µæ’
        alignItems: "center",
        margin: "md",
        spacing: "xs",
        contents: [
          {
            type: "text",
            text: "ğŸ”’ SSL å®‰å…¨åŠ å¯†é€£ç·š", // æ–°å¢çš„ä¸­æ–‡å­—
            size: "xxs",
            color: "#505050", // è¼ƒæ·±çš„éœ§ç°è‰²
            align: "center"
          }
        ]
      }
    ]
  },
  styles: {
    body: { backgroundColor: colors.bg },
    footer: { backgroundColor: colors.bg }
  }
};
}
// å°å·¥å…·ï¼šå¯¦éš›ç™¼ Flex å¡ç‰‡
async function sendCartLinkFlex(env, lineUserId, params) {
  const url = params && params.url;
  if (!lineUserId || !url) return;

  const bubble = buildCartLinkFlexBubble(params);

  // é€™å€‹ linePushFlex ä½ åŸæœ¬æª”æ¡ˆè£¡å°±æœ‰äº†ï¼Œç›´æ¥æ‹¿ä¾†ç”¨
  await linePushFlex(env, lineUserId, "å°ˆå±¬çµå¸³é€£çµ", bubble);
}



// å…¶ä»–è·¯å¾‘æ²’å°åˆ° â†’ not_found
return j(env, origin, { ok:false, error:"not_found" }, 404);

} catch (e) {
  return j(env, origin, {
    ok:false,
    error: String((e && e.message) || e)
  }, 500);
}
},  // â† é€™è£¡å¾ˆé‡è¦ï¼Œå¤šä¸€å€‹é€—è™Ÿï¼ŒæŠŠ fetch çµæŸæ‰ï¼Œä¸‹é¢æ¥ scheduled

async scheduled(event, env, ctx) {
  const cron = String(event?.cron || "").trim();

  ctx.waitUntil((async () => {
    try {
      if (cron === "0 1 * * *") {
        await runDepositTailReminder(env);
      }
    } catch (e) {
      console.log("scheduled: runDepositTailReminder error", e?.message || e);
    }

    try {
      if (cron === "*/10 * * * *") {
        await runAbandonedOnlineCleanup(env, 30);
      }
    } catch (e) {
      console.log("scheduled: runAbandonedOnlineCleanup error", e?.message || e);
    }
  })());
}
};
